# S3

```{r, include = FALSE}
source("common.R")
```

## Exercises 13.2.1 

**Q1.** Describe the difference between `t.test()` and `t.data.frame()`. When is each function called?

**A1.** 

- `t.test()` is a **generic** function to perform a *t*-test.

- `t.data.frame` is a **method** for generic `t()` (a matrix transform function) and will be dispatched for `data.frame` class objects/instances that need to be transformed.

```{r}
library(sloop)

# function type
ftype(t.test)
ftype(t.data.frame)
```

**Q2.** Make a list of commonly used base R functions that contain `.` in their name but are not `S3` methods.

**A2.** Here are a few common R functions with `.` but that are not `S3` methods:

- `all.equal()`
- Most of `as.*` functions (like `as.data.frame()`, `as.numeric()`, etc.)
- `install.packages()`
- `on.exit()`
etc.

For full list, you could do:

```{r, eval=FALSE}
base_functions <- getNamespaceExports("base")

base_functions[grepl("(\\w+)(\\.)(\\w+)", base_functions)]
```

For example,

```{r}
ftype(as.data.frame)
ftype(on.exit)
```

**Q3.** What does the `as.data.frame.data.frame()` method do? Why is it confusing? How could you avoid this confusion in your own code?
 
**A3.** It's an `S3` **method** for **generic** `as.data.frame()`.

```{r}
ftype(as.data.frame.data.frame)
```

It can be seen in all methods supported by this generic:

```{r}
s3_methods_generic("as.data.frame") %>%
  dplyr::filter(class == "data.frame")
```


**Q4.** Describe the difference in behaviour in these two calls.

```{r}
set.seed(1014)
some_days <- as.Date("2017-01-31") + sample(10, 5)
mean(some_days)
mean(unclass(some_days))
```

**A4.** 

- Before unclassing, the `mean` generic dispatches `.Date` method:

```{r}
some_days <- as.Date("2017-01-31") + sample(10, 5)

some_days

s3_dispatch(mean(some_days))

mean(some_days)
```

- After unclassing, the `mean` generic dispatches `.numeric` method:

```{r}
unclass(some_days)

mean(unclass(some_days))

s3_dispatch(mean(unclass(some_days)))
```

**Q5.** What class of object does the following code return? What base type is it built on? What attributes does it use?

```{r, eval=FALSE}
x <- ecdf(rpois(100, 10))
x
```

**A5.** The object is based on base type `closure`^[of "object of type 'closure' is not subsettable" fame], which is a type of function.

```{r}
x <- ecdf(rpois(100, 10))
x

otype(x)
typeof(x)
```

Its class is `ecdf`, which has other superclasses.

```{r}
s3_class(x)
```

Apart from `class`, it has the following attributes:

```{r}
attributes(x)
```

**Q6.** What class of object does the following code return? What base type is it built on? What attributes does it use?

```{r, eval = FALSE}
x <- table(rpois(100, 5))
x
```

**A6.** The object is based on base type `integer`.

```{r}
x <- table(rpois(100, 5))
x

otype(x)
typeof(x)
```

Its class is `table`.

```{r}
s3_class(x)
```

Apart from `class`, it has the following attributes:

```{r}
attributes(x)
```

## Exercises 13.3.4

**Q1.** Write a constructor for `data.frame` objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?

**A1.** A data frame is built on top of a named list of atomic vectors and has attributes for row names:

```{r}
unclass(data.frame())
```

The restriction imposed on individual elements is that they need to have the same length. Additionally, the names need to be syntactically valid and unique.

```{r}
new_data_frame <- function(x = list(), row.names = character()) {
  # row names should be character
  if (!all(is.character(row.names))) {
    stop("Row name should be of `chracter` type.", call. = FALSE)
  }

  # all elements should have the same length
  unique_element_lengths <- unique(purrr::map_int(x, length))
  if (length(unique_element_lengths) > 1L) {
    stop("All list elements in `x` should have same length.", call. = FALSE)
  }

  # if not provided, generate row names
  # this is necessary if there is at least one element in the list
  if (length(x) > 0L && length(row.names) == 0L) {
    row.names <- .set_row_names(unique_element_lengths)
  }

  structure(x, class = "data.frame", row.names = row.names)
}
```

Let's try it out:

```{r, error=TRUE}
new_data_frame(list("x" = 1, "y" = c(2, 3)))

new_data_frame(list("x" = 1, "y" = c(2)), row.names = 1L)

new_data_frame(list())

new_data_frame(list("x" = 1, "y" = 2))

new_data_frame(list("x" = 1, "y" = 2), row.names = "row-1")
```

**Q2.** Enhance my `factor()` helper to have better behaviour when one or more `values` is not found in `levels`. What does `base::factor()` do in this situation?

**A2.** When one or more `values` is not found in `levels`, those values are converted to `NA` in `base::factor()`:

```{r}
base::factor(c("a", "b", "c"), levels = c("a", "c"))
```

In the new constructor, we can throw an error to inform the user:

```{r}
new_factor <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))

  structure(
    x,
    levels = levels,
    class = "factor"
  )
}

validate_factor <- function(x) {
  values <- unclass(x)
  levels <- attr(x, "levels")

  if (!all(!is.na(values) & values > 0)) {
    stop(
      "All `x` values must be non-missing and greater than zero",
      call. = FALSE
    )
  }

  if (length(levels) < max(values)) {
    stop(
      "There must be at least as many `levels` as possible values in `x`",
      call. = FALSE
    )
  }

  x
}

create_factor <- function(x = character(), levels = unique(x)) {
  ind <- match(x, levels)

  if (any(is.na(ind))) {
    missing_values <- x[which(is.na(match(x, levels)))]

    stop(
      paste0(
        "Following values from `x` are not present in `levels`:\n",
        paste0(missing_values, collapse = "\n")
      ),
      call. = FALSE
    )
  }

  validate_factor(new_factor(ind, levels))
}
```

Let's try it out:

```{r, error=TRUE}
create_factor(c("a", "b", "c"), levels = c("a", "c"))

create_factor(c("a", "b", "c"), levels = c("a", "b", "c"))
```

**Q3.** Carefully read the source code of `factor()`. What does it do that my constructor does not?

**A3.** The source code for `factor()` can be read [here](https://github.com/r-devel/r-svn/blob/master/src/library/base/R/factor.R).

There are a number ways in which the base version is more flexible.

- It allows labeling the values:

```{r}
x <- c("a", "b", "b")
levels <- c("a", "b", "c")
labels <- c("one", "two", "three")

factor(x, levels = levels, labels = labels)
```

- It checks that the levels are not duplicated.

```{r, error=TRUE}
x <- c("a", "b", "b")
levels <- c("a", "b", "b")

factor(x, levels = levels)

create_factor(x, levels = levels)
```

- The `levels` argument can be `NULL`.

```{r, error=TRUE}
x <- c("a", "b", "b")

factor(x, levels = NULL)

create_factor(x, levels = NULL)
```

**Q4.** Factors have an optional "contrasts" attribute. Read the help for `C()`, and briefly describe the purpose of the attribute. What type should it have? Rewrite the `new_factor()` constructor to include this attribute.


**Q5.** Read the documentation for `utils::as.roman()`. How would you write a constructor for this class? Does it need a validator? What might a helper do?

**A5.** `utils::as.roman()` converts Hindu-Arabic numerals to Roman numerals. Removing its class also reveals that it is implemented using the base type `integer`:

```{r}
as.roman(1)

typeof(unclass(as.roman(1)))
```

Therefore, we can create a simple constructor to create instance of this class:

```{r}
new_roman <- function(x = integer()) {
  stopifnot(is.integer(x))
  
  structure(x, class = "roman")
}
```

The docs mention the following:

> Only numbers between 1 and 3899 have a unique representation as roman numbers, and hence others result in as.roman(NA).

```{r}
as.roman(10000)
```

Therefore, we can warn the user and then return `NA` in a validator function:

```{r}
validate_new_roman <- function(x) {
  int_values <- unclass(x)
  
  if (any(int_values < 1L | int_values > 3899L)) {
    warning(
      "Integer should be between 1 and 3899. Returning `NA` otherwise.",
      call. = FALSE
    )
  }
  
  x
}
```

The helper function can coerce the entered input to integer type for convenience:

```{r}
roman <- function(x = integer()) {
    x <- as.integer(x)
  
  validate_new_roman(new_roman(x))
}
```

Let's try it out:

```{r}
roman(1)

roman(c(5, 20, 100, 150, 100000))
```


## Exercises 13.4.4

**Q1.** Read the source code for `t()` and `t.test()` and confirm that `t.test()` is an S3 generic and not an S3 method. What happens if you create an object with class `test` and call `t()` with it? Why?

```{r, results = FALSE}
x <- structure(1:10, class = "test")
t(x)
```

**A1.** Looking at source code of these functions, we can see that both of these are generic, and we can confirm the same using `{sloop}`:

```{r}
t
sloop::is_s3_generic("t")

t.test
sloop::is_s3_generic("t.test")
```

Looking at the `S3` dispatch, we can see that since R can't find `S3` method for `test` class for generic function `t()`, it dispatches the default method, which converts the structure to a matrix:

```{r}
x <- structure(1:10, class = "test")
t(x)
s3_dispatch(t(x))
```

The same behaviour can be observed with a vector:

```{r}
t(1:10)
```

**Q2.** What generics does the `table` class have methods for?

**A2.** The `table` class have methods for the following generics:

```{r}
s3_methods_class("table")
```

**Q3.** What generics does the `ecdf` class have methods for?

**A3.** The `ecdf` class have methods for the following generics:

```{r}
s3_methods_class("ecdf")
```

**Q4.** Which base generic has the greatest number of defined methods?

**A4.** To answer this question, first, let's list all functions base has and only retain the generics.

```{r}
library(purrr)
library(dplyr)

# getting all functions names
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)

# extracting only generics
genFuns <- names(funs) %>%
  purrr::keep(~ sloop::is_s3_generic(.x))
```

Now it's a simple matter of counting number of methods per generic and ordering the data frame in descending order of this count:

```{r}
purrr::map_dfr(
  genFuns,
  ~ s3_methods_generic(.)
) %>%
  dplyr::group_by(generic) %>%
  dplyr::tally() %>%
  dplyr::arrange(desc(n))
```

This reveals that the base generic function with most methods is `print()`.

**Q5.** Carefully read the documentation for `UseMethod()` and explain why the following code returns the results that it does. What two usual rules of function evaluation does `UseMethod()` violate?

```{r}
g <- function(x) {
  x <- 10
  y <- 10
  UseMethod("g")
}
g.default <- function(x) c(x = x, y = y)
x <- 1
y <- 1
g(x)
```

**Q6.** What are the arguments to `[`? Why is this a hard question to answer?

**A6.** It is difficult to say how many formal arguments the subsetting `[` operator has because it is a generic function with methods for vectors, matrices, arrays, lists, etc., and these different methods have different number of arguments:

```{r}
s3_methods_generic("[") %>%
  dplyr::filter(source == "base")
```

We can sample a few of them to see the diversity in the number of formal arguments:

```{r}
# table
names(formals(`[.table`))

# Date
names(formals(`[.Date`))

# data frame
names(formals(`[.data.frame`))

# etc.
```

## Exercises 13.5.1

**Q1.** Categorise the objects returned by `lm()`, `factor()`, `table()`, `as.Date()`, `as.POSIXct()` `ecdf()`, `ordered()`, `I()` into the styles described above.

**Q2.** What would a constructor function for `lm` objects, `new_lm()`, look like? Use `?lm` and experimentation to figure out the required fields and their types.

## Exercises 13.6.3

**Q1.** How does `[.Date` support subclasses? How does it fail to support subclasses?

**Q2.** R has two classes for representing date time data, `POSIXct` and `POSIXlt`, which both inherit from `POSIXt`. Which generics have different behaviours for the two classes? Which generics share the same behaviour?

**Q3.** What do you expect this code to return? What does it actually return? Why?

```{r, eval = FALSE}
generic2 <- function(x) UseMethod("generic2")
generic2.a1 <- function(x) "a1"
generic2.a2 <- function(x) "a2"
generic2.b <- function(x) {
  class(x) <- "a1"
  NextMethod()
}
generic2(structure(list(), class = c("b", "a2")))
```

## Exercises 13.7.5

**Q1.** Explain the differences in dispatch below:

```{r}
length.integer <- function(x) 10

x1 <- 1:5
class(x1)
s3_dispatch(length(x1))

x2 <- structure(x1, class = "integer")
class(x2)
s3_dispatch(length(x2))
```

**Q2.** What classes have a method for the `Math` group generic in base R? Read the source code. How do the methods work?

**Q3.** `Math.difftime()` is more complicated than I described. Why?
