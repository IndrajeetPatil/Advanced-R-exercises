[{"path":"index.html","id":"about","chapter":"About","heading":"About","text":"book provides solutions exercises Hadley Wickham’s Advanced R (2nd edition) book.started working book part process learn solving book’s exercises. comparing solutions official solutions manual, realized solutions took different approaches least explained differently. ’m sharing solutions case others might find another perspective explanation official solution manual helpful building understanding.Although tried make sure solutions correct, blame inaccuracies lies solely . ’d much appreciate suggestions corrections.","code":""},{"path":"introduction.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"exercises.","code":""},{"path":"names-and-values.html","id":"names-and-values","chapter":"2 Names and values","heading":"2 Names and values","text":"Loading needed libraries:","code":"\nlibrary(lobstr)"},{"path":"names-and-values.html","id":"binding-basics-exercise-2.2.2","chapter":"2 Names and values","heading":"2.1 Binding basics (Exercise 2.2.2)","text":"Q1. Explain relationship , b, c d following code:A1. names (, b, c) values point object memory, can seen identical memory addresses:Except d, different object, even value , b, c:Q2. following code accesses mean function multiple ways. point underlying function object? Verify lobstr::obj_addr().A2. listed function calls point underlying function object memory, shown object’s memory address:Q3. default, base R data import functions, like read.csv(), automatically convert non-syntactic names syntactic ones. might problematic? option allows suppress behaviour?A3. conversion non-syntactic names syntactic ones can sometimes corrupt data. datasets may require non-syntactic names.suppress behavior, one can set check.names = FALSE.Q4. rules make.names() use convert non-syntactic names syntactic ones?A4. make.names() uses following rules convert non-syntactic names syntactic ones:prepends non-syntactic names Xit converts invalid characters (like @) .adds . suffix name reserved keywordQ5. slightly simplified rules govern syntactic names. .123e1 syntactic name? Read ?make.names full details.A5. .123e1 syntacti name parsed number, string:docs mention (emphasis mine):syntactically valid name consists letters, numbers dot underline characters starts letter dot followed number.","code":"\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\nobj_addrs <- obj_addrs(list(a, b, c))\nunique(obj_addrs)\n#> [1] \"0x55f9972a5960\"\nobj_addr(d)\n#> [1] \"0x55f997768758\"\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")\nobj_addrs <- obj_addrs(list(\n  mean,\n  base::mean,\n  get(\"mean\"),\n  evalq(mean),\n  match.fun(\"mean\")\n))\n\nunique(obj_addrs)\n#> [1] \"0x55f994e41778\"\nmake.names(c(\"123abc\", \"@me\", \"_yu\", \"  gh\", \"else\"))\n#> [1] \"X123abc\" \"X.me\"    \"X_yu\"    \"X..gh\"   \"else.\"\ntypeof(.123e1)\n#> [1] \"double\""},{"path":"names-and-values.html","id":"copy-on-modify-exercise-2.3.6","chapter":"2 Names and values","heading":"2.2 Copy-on-modify (Exercise 2.3.6)","text":"Q1. tracemem(1:10) useful?A1. tracemem() traces copying objects R. example:since object created memory 1:10 assigned name, can’t addressed modified R, nothing trace.Q2. Explain tracemem() shows two copies run code. Hint: carefully look difference code code shown earlier section.A2. initial atomic vector type integer, 4 (4L) type double. new copy created.Trying integer create another copy:understand still produces copy, explanation official solutions manual:Please aware running code RStudio result additional copies reference environment pane.Q3. Sketch relationship following objects:A3. can understand relationship objects looking memory addresses:learn:name references object 1:10 memory.name b bound list two references memory address .name c also bound list references b, 1:10 object (bound name).Q4. happens run code?Draw picture.A4.don’t access OmniGraffle software, including figure official solution manual:","code":"\nx <- 1:10\n\ntracemem(x)\n#> [1] \"<0x55f998301b70>\"\n\nx <- x + 1\n\nuntracemem(x)\nobj_addr(1:10)\n#> [1] \"0x55f998e15cd0\"\n\ntracemem(1:10)\n#> [1] \"<0x55f998e802a0>\"\nx <- c(1L, 2L, 3L)\ntracemem(x)\n\nx[[3]] <- 4\nuntracemem(x)\nx <- c(1L, 2L, 3L)\ntypeof(x)\n#> [1] \"integer\"\ntracemem(x)\n#> [1] \"<0x55f99941d388>\"\n\nx[[3]] <- 4\n#> tracemem[0x55f99941d388 -> 0x55f999528dd8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local \n#> tracemem[0x55f999528dd8 -> 0x55f9994f4958]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\nuntracemem(x)\n\ntypeof(x)\n#> [1] \"double\"\nx <- c(1L, 2L, 3L)\ntypeof(x)\n#> [1] \"integer\"\ntracemem(x)\n#> [1] \"<0x55f999a66298>\"\n\nx[[3]] <- 4L\n#> tracemem[0x55f999a66298 -> 0x55f999ba42d8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\nuntracemem(x)\n\ntypeof(x)\n#> [1] \"integer\"\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\n\nref(a)\n#> [1:0x55f99a75e3e0] <int>\n\nref(b)\n#> █ [1:0x55f99a257db8] <list> \n#> ├─[2:0x55f99a75e3e0] <int> \n#> └─[2:0x55f99a75e3e0]\n\nref(c)\n#> █ [1:0x55f99a7ddfa8] <list> \n#> ├─█ [2:0x55f99a257db8] <list> \n#> │ ├─[3:0x55f99a75e3e0] <int> \n#> │ └─[3:0x55f99a75e3e0] \n#> ├─[3:0x55f99a75e3e0] \n#> └─[4:0x55f99a7f8d08] <int>\nx <- list(1:10)\nx[[2]] <- x\nx <- list(1:10)\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nobj_addr(x)\n#> [1] \"0x55f99a2535d8\"\n\nx[[2]] <- x\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> [[2]]\n#> [[2]][[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nobj_addr(x)\n#> [1] \"0x55f999a66118\"\n\nref(x)\n#> █ [1:0x55f999a66118] <list> \n#> ├─[2:0x55f99a227300] <int> \n#> └─█ [3:0x55f99a2535d8] <list> \n#>   └─[2:0x55f99a227300]"},{"path":"names-and-values.html","id":"object-size-exercise-2.4.1","chapter":"2 Names and values","heading":"2.3 Object size (Exercise 2.4.1)","text":"Q1. following example, object.size(y) obj_size(y) radically different? Consult documentation object.size().A1. mentioned docs object.size():function…detect elements list shared.sizes different:Q2. Take following list. size somewhat misleading?A2. functions externally created objects R, always available part base packages, doesn’t make much sense measure size never going available.Q3. Predict output following code:A3. Correctly predicted 😉Key pieces information keep mind make correct predictions:Size empty vectorSize single double: 8 bytesCopy--modify semantics","code":"\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\nobj_size(y)\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#> 8005648 bytes\n\nobj_size(y)\n#> 80.90 kB\nfuns <- list(mean, sd, var)\nobj_size(funs)\nfuns <- list(mean, sd, var)\nobj_size(funs)\n#> 18.76 kB\na <- runif(1e6)\nobj_size(a)\n\nb <- list(a, a)\nobj_size(b)\nobj_size(a, b)\n\nb[[1]][[1]] <- 10\nobj_size(b)\nobj_size(a, b)\n\nb[[2]][[1]] <- 10\nobj_size(b)\nobj_size(a, b)\na <- runif(1e6)\nobj_size(a)\n#> 8.00 MB\n\nb <- list(a, a)\nobj_size(b)\n#> 8.00 MB\nobj_size(a, b)\n#> 8.00 MB\n\nb[[1]][[1]] <- 10\nobj_size(b)\n#> 16.00 MB\nobj_size(a, b)\n#> 16.00 MB\n\nb[[2]][[1]] <- 10\nobj_size(b)\n#> 16.00 MB\nobj_size(a, b)\n#> 24.00 MB\nobj_size(double())\n#> 48 B\nobj_size(double(1))\n#> 56 B"},{"path":"names-and-values.html","id":"modify-in-place-exercise-2.5.3","chapter":"2 Names and values","heading":"2.4 Modify-in-place (Exercise 2.5.3)","text":"Q1. Explain following code doesn’t create circular list.A1. Copy--modify prevents creation circular list.Q2. Wrap two methods subtracting medians two functions, use ‘bench’ package carefully compare speeds. performance change number columns increase?A2. Let’s first microbenchmark functions create copies varying lengths number columns.Plotting benchmarks reveals performance gets increasingly worse number data frames increases:Q3. happens attempt use tracemem() environment?A3. doesn’t work documentation tracemem() makes clear :useful trace NULL, environments, promises, weak references, external pointer objects, duplicated","code":"\nx <- list()\nx[[1]] <- x\nx <- list()\n\nobj_addr(x)\n#> [1] \"0x55f99aa37ad8\"\n\ntracemem(x)\n#> [1] \"<0x55f99aa37ad8>\"\n\nx[[1]] <- x\n#> tracemem[0x55f99aa37ad8 -> 0x55f99aaf59e8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\n\nobj_addr(x[[1]])\n#> [1] \"0x55f99aa37ad8\"\nlibrary(bench)\nlibrary(tidyverse)\n\ngenerateDataFrame <- function(ncol) {\n  as.data.frame(matrix(runif(100 * ncol), nrow = 100))\n}\n\nwithCopy <- function(ncol) {\n  x <- generateDataFrame(ncol)\n  medians <- vapply(x, median, numeric(1))\n\n  for (i in seq_along(medians)) {\n    x[[i]] <- x[[i]] - medians[[i]]\n  }\n\n  return(x)\n}\n\nwithoutCopy <- function(ncol) {\n  x <- generateDataFrame(ncol)\n  medians <- vapply(x, median, numeric(1))\n\n  y <- as.list(x)\n\n  for (i in seq_along(medians)) {\n    y[[i]] <- y[[i]] - medians[[i]]\n  }\n\n  return(y)\n}\n\nbenchComparison <- function(ncol) {\n  bench::mark(\n    withCopy(ncol),\n    withoutCopy(ncol),\n    iterations = 100,\n    check = FALSE\n  ) %>%\n    dplyr::select(expression:total_time)\n}\n\nnColList <- list(1, 10, 50, 100, 250, 500, 1000)\n\nnames(nColList) <- as.character(nColList)\n\nbenchDf <- purrr::map_dfr(\n  .x = nColList,\n  .f = benchComparison,\n  .id = \"nColumns\"\n)\nggplot(\n  benchDf,\n  aes(\n    x = as.numeric(nColumns),\n    y = median,\n    group = as.character(expression),\n    color = as.character(expression)\n  )\n) +\n  geom_line() +\n  labs(\n    x = \"Number of Columns\",\n    y = \"Median Execution Time (ms)\",\n    colour = \"Type of function\"\n  )\n#> Warning: The `trans` argument of `continuous_scale()` is deprecated\n#> as of ggplot2 3.5.0.\n#> ℹ Please use the `transform` argument instead.\n#> This warning is displayed once every 8 hours.\n#> Call `lifecycle::last_lifecycle_warnings()` to see where\n#> this warning was generated.\ne <- rlang::env(a = 1, b = \"3\")\ntracemem(e)\n#> Error in tracemem(e): 'tracemem' is not useful for promise and environment objects"},{"path":"names-and-values.html","id":"session-information","chapter":"2 Names and values","heading":"2.5 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bench       * 1.1.3   2023-05-04 [1] RSPM\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  colorspace    2.1-1   2024-07-26 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  crayon        1.5.3   2024-06-20 [1] RSPM\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr       * 1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  farver        2.1.2   2024-05-13 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  forcats     * 1.0.0   2023-01-29 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  ggplot2     * 3.5.1   2024-04-23 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  grid          4.4.1   2024-08-22 [3] local\n#>  gtable        0.3.5   2024-04-22 [1] RSPM\n#>  highr         0.11    2024-05-26 [1] RSPM\n#>  hms           1.1.3   2023-03-21 [1] RSPM\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  labeling      0.4.3   2023-08-29 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  lobstr      * 1.1.2   2022-06-22 [1] RSPM\n#>  lubridate   * 1.9.3   2023-09-27 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  munsell       0.5.1   2024-04-01 [1] RSPM\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  prettyunits   1.2.0   2023-09-24 [1] RSPM\n#>  profmem       0.6.0   2020-12-13 [1] RSPM\n#>  purrr       * 1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  readr       * 2.1.5   2024-01-10 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  scales        1.3.0   2023-11-28 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  stringi       1.8.4   2024-05-06 [1] RSPM\n#>  stringr     * 1.5.1   2023-11-14 [1] RSPM\n#>  tibble      * 3.2.1   2023-03-20 [1] RSPM\n#>  tidyr       * 1.3.1   2024-01-24 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tidyverse   * 2.0.0   2023-02-22 [1] RSPM\n#>  timechange    0.3.0   2024-01-18 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  tzdb          0.4.0   2023-05-12 [1] RSPM\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"vectors.html","id":"vectors","chapter":"3 Vectors","heading":"3 Vectors","text":"","code":""},{"path":"vectors.html","id":"atomic-vectors-exercises-3.2.5","chapter":"3 Vectors","heading":"3.1 Atomic vectors (Exercises 3.2.5)","text":"Q1. create raw complex scalars? (See ?raw ?complex.)A1. R, scalars nothing vectors length 1, can created using constructor.Raw vectorsThe raw type holds raw bytes, can created using charToRaw(). example,alternative use .raw():Complex vectorsComplex vectors used represent (surprise!) complex numbers.Example complex scalar:Q2. Test knowledge vector coercion rules predicting output following uses c():A2. vector coercion rules dictate data type smaller size converted data type bigger size.Q3. 1 == \"1\" true? -1 < FALSE true? \"one\" < 2 false?A3. coercion rules vectors reveal comparisons return results .Q4. default missing value, NA, logical vector? ’s special logical vectors? (Hint: think c(FALSE, NA_character_).)A4. \"logical\" type lowest coercion hierarchy.NA defaulting type (e.g. \"numeric\") mean time missing element vector, rest elements converted type higher hierarchy, problematic types lower hierarchy.Q5. Precisely .atomic(), .numeric(), .vector() test ?A5. Let’s discuss one--one..atomic()function checks object vector atomic type (NULL).Quoting docs:.atomic true atomic types (“logical”, “integer”, “numeric”, “complex”, “character” “raw”) NULL..numeric()documentation says:.numeric return true base type class double integer values can reasonably regarded numericTherefore, function checks double integer base types types based top types (factor, Date, POSIXt, difftime)..vector()per documentation:.vector returns TRUE x vector specified mode attributes names. returns FALSE otherwise.Thus, function can incorrectif object attributes names.better way check vector:","code":"\nx <- \"A string\"\n\n(y <- charToRaw(x))\n#> [1] 41 20 73 74 72 69 6e 67\n\ntypeof(y)\n#> [1] \"raw\"\nas.raw(\"–\") # en-dash\n#> Warning: NAs introduced by coercion\n#> Warning: out-of-range values treated as 0 in coercion to\n#> raw\n#> [1] 00\nas.raw(\"—\") # em-dash\n#> Warning: NAs introduced by coercion\n#> Warning: out-of-range values treated as 0 in coercion to\n#> raw\n#> [1] 00\n(x <- complex(length.out = 1, real = 1, imaginary = 8))\n#> [1] 1+8i\n\ntypeof(x)\n#> [1] \"complex\"\nc(1, FALSE)\nc(\"a\", 1)\nc(TRUE, 1L)\nc(1, FALSE)\n#> [1] 1 0\n\nc(\"a\", 1)\n#> [1] \"a\" \"1\"\n\nc(TRUE, 1L)\n#> [1] 1 1\n1 == \"1\"\n#> [1] TRUE\n\nc(1, \"1\")\n#> [1] \"1\" \"1\"\n-1 < FALSE\n#> [1] TRUE\n\nc(-1, FALSE)\n#> [1] -1  0\n\"one\" < 2\n#> [1] FALSE\n\nc(\"one\", 2)\n#> [1] \"one\" \"2\"\n\nsort(c(\"one\", 2))\n#> [1] \"2\"   \"one\"\ntypeof(NA)\n#> [1] \"logical\"\n\nc(FALSE, NA_character_)\n#> [1] \"FALSE\" NA\nis.atomic(NULL)\n#> [1] FALSE\n\nis.atomic(list(NULL))\n#> [1] FALSE\nis.numeric(1L)\n#> [1] TRUE\n\nis.numeric(factor(1L))\n#> [1] FALSE\nx <- c(\"x\" = 1, \"y\" = 2)\n\nis.vector(x)\n#> [1] TRUE\n\nattr(x, \"m\") <- \"abcdef\"\n\nis.vector(x)\n#> [1] FALSE\nis.null(dim(x))\n#> [1] TRUE"},{"path":"vectors.html","id":"attributes-exercises-3.3.4","chapter":"3 Vectors","heading":"3.2 Attributes (Exercises 3.3.4)","text":"Q1. setNames() implemented? unname() implemented? Read source code.A1. Let’s look implementations functions.setNames()Given function signature, can see , first argument given, result still named vector.unname()unname() removes existing names (dimnames) setting NULL.Q2. dim() return applied 1-dimensional vector? might use NROW() NCOL()?A2. Dimensions 1-dimensional vector NULL. example,NROW() NCOL() helpful getting dimensions 1D vectors treating matrices dataframes.Q3. describe following three objects? makes different 1:5?A3. x1, x2, x3 one-dimensional arrays, different “orientations”, mentally visualize .x1 5 entries third dimension, x2 second dimension, x1 first dimension.Q4. early draft used code illustrate structure():print object don’t see comment attribute. ? attribute missing, something else special ? (Hint: try using help.)A4. ?attributes (emphasis mine):Note attributes (namely class, comment, dim, dimnames, names, row.names tsp) treated specially restrictions values can set.","code":"\nsetNames\n#> function (object = nm, nm) \n#> {\n#>     names(object) <- nm\n#>     object\n#> }\n#> <bytecode: 0x55a7db1745e0>\n#> <environment: namespace:stats>\nsetNames(, c(\"a\", \"b\"))\n#>   a   b \n#> \"a\" \"b\"\n\nsetNames(c(1, 2), c(\"a\", \"b\"))\n#> a b \n#> 1 2\nunname\n#> function (obj, force = FALSE) \n#> {\n#>     if (!is.null(names(obj))) \n#>         names(obj) <- NULL\n#>     if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n#>         dimnames(obj) <- NULL\n#>     obj\n#> }\n#> <bytecode: 0x55a7d8678d00>\n#> <environment: namespace:base>\nunname(setNames(, c(\"a\", \"b\")))\n#> [1] \"a\" \"b\"\ndim(c(1, 2))\n#> NULL\n# example-1\nx <- character(0)\n\ndim(x)\n#> NULL\n\nnrow(x)\n#> NULL\nNROW(x)\n#> [1] 0\n\nncol(x)\n#> NULL\nNCOL(x)\n#> [1] 1\n\n# example-2\ny <- 1:4\n\ndim(y)\n#> NULL\n\nnrow(y)\n#> NULL\nNROW(y)\n#> [1] 4\n\nncol(y)\n#> NULL\nNCOL(y)\n#> [1] 1\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))\nstructure(1:5, comment = \"my attribute\")\n#> [1] 1 2 3 4 5\nstructure(1:5, x = \"my attribute\")\n#> [1] 1 2 3 4 5\n#> attr(,\"x\")\n#> [1] \"my attribute\"\n\nstructure(1:5, comment = \"my attribute\")\n#> [1] 1 2 3 4 5"},{"path":"vectors.html","id":"s3-atomic-vectors-exercises-3.4.5","chapter":"3 Vectors","heading":"3.3 S3 atomic vectors (Exercises 3.4.5)","text":"Q1. sort object table() return? type? attributes ? dimensionality change tabulate variables?A1. table() returns array integer type dimensions scale number variables present.Q2. happens factor modify levels?A2. levels change underlying integer values remain .Q3. code ? f2 f3 differ f1?A3. code:f2: underlying integers reversed, levels remain unchanged.f3: levels underlying integers reversed.","code":"\n(x <- table(mtcars$am))\n#> \n#>  0  1 \n#> 19 13\n(y <- table(mtcars$am, mtcars$cyl))\n#>    \n#>      4  6  8\n#>   0  3  4 12\n#>   1  8  3  2\n(z <- table(mtcars$am, mtcars$cyl, mtcars$vs))\n#> , ,  = 0\n#> \n#>    \n#>      4  6  8\n#>   0  0  0 12\n#>   1  1  3  2\n#> \n#> , ,  = 1\n#> \n#>    \n#>      4  6  8\n#>   0  3  4  0\n#>   1  7  0  0\n\n# type\npurrr::map(list(x, y, z), typeof)\n#> [[1]]\n#> [1] \"integer\"\n#> \n#> [[2]]\n#> [1] \"integer\"\n#> \n#> [[3]]\n#> [1] \"integer\"\n\n# attributes\npurrr::map(list(x, y, z), attributes)\n#> [[1]]\n#> [[1]]$dim\n#> [1] 2\n#> \n#> [[1]]$dimnames\n#> [[1]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> \n#> [[1]]$class\n#> [1] \"table\"\n#> \n#> \n#> [[2]]\n#> [[2]]$dim\n#> [1] 2 3\n#> \n#> [[2]]$dimnames\n#> [[2]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> [[2]]$dimnames[[2]]\n#> [1] \"4\" \"6\" \"8\"\n#> \n#> \n#> [[2]]$class\n#> [1] \"table\"\n#> \n#> \n#> [[3]]\n#> [[3]]$dim\n#> [1] 2 3 2\n#> \n#> [[3]]$dimnames\n#> [[3]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> [[3]]$dimnames[[2]]\n#> [1] \"4\" \"6\" \"8\"\n#> \n#> [[3]]$dimnames[[3]]\n#> [1] \"0\" \"1\"\n#> \n#> \n#> [[3]]$class\n#> [1] \"table\"\nf1 <- factor(letters)\nlevels(f1) <- rev(levels(f1))\nf1 <- factor(letters)\nf1\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> 26 Levels: a b c d e f g h i j k l m n o p q r s t u ... z\nas.integer(f1)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n#> [19] 19 20 21 22 23 24 25 26\n\nlevels(f1) <- rev(levels(f1))\nf1\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> 26 Levels: z y x w v u t s r q p o n m l k j i h g f ... a\nas.integer(f1)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n#> [19] 19 20 21 22 23 24 25 26\nf2 <- rev(factor(letters))\nf3 <- factor(letters, levels = rev(letters))\nf2 <- rev(factor(letters))\nf2\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> 26 Levels: a b c d e f g h i j k l m n o p q r s t u ... z\nas.integer(f2)\n#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9\n#> [19]  8  7  6  5  4  3  2  1\nf3 <- factor(letters, levels = rev(letters))\nf3\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> 26 Levels: z y x w v u t s r q p o n m l k j i h g f ... a\nas.integer(f3)\n#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9\n#> [19]  8  7  6  5  4  3  2  1"},{"path":"vectors.html","id":"lists-exercises-3.5.4","chapter":"3 Vectors","heading":"3.4 Lists (Exercises 3.5.4)","text":"Q1. List ways list differs atomic vector.A1. table comparison:Q2. need use unlist() convert list atomic vector? doesn’t .vector() work?A2. list already (generic) vector, .vector() going change anything, .atomic.vector. Thus, need use unlist().Q3. Compare contrast c() unlist() combining date date-time single vector.A3. Let’s first create date datetime objectAnd check attributes underlying double representation:Behavior c()Since S3 method c() dispatches first argument, resulting class vector going first argument. , attributes lost.Behavior unlist()removes attributes left underlying double representations objects.","code":"\nx <- list(a = 1, b = 2)\n\nis.vector(x)\n#> [1] TRUE\nis.atomic(x)\n#> [1] FALSE\n\n# still a list\nas.vector(x)\n#> $a\n#> [1] 1\n#> \n#> $b\n#> [1] 2\n\n# now a vector\nunlist(x)\n#> a b \n#> 1 2\ndate <- as.Date(\"1947-08-15\")\ndatetime <- as.POSIXct(\"1950-01-26 00:01\", tz = \"UTC\")\nattributes(date)\n#> $class\n#> [1] \"Date\"\nattributes(datetime)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\n\nas.double(date) # number of days since the Unix epoch 1970-01-01\n#> [1] -8175\nas.double(datetime) # number of seconds since then\n#> [1] -628991940\nc(date, datetime)\n#> [1] \"1947-08-15\" \"1950-01-26\"\n\nattributes(c(date, datetime))\n#> $class\n#> [1] \"Date\"\n\nc(datetime, date)\n#> [1] \"1950-01-26 00:01:00 UTC\" \"1947-08-15 00:00:00 UTC\"\n\nattributes(c(datetime, date))\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\nunlist(list(date, datetime))\n#> [1]      -8175 -628991940\n\nunlist(list(datetime, date))\n#> [1] -628991940      -8175"},{"path":"vectors.html","id":"data-frames-and-tibbles-exercises-3.6.8","chapter":"3 Vectors","heading":"3.5 Data frames and tibbles (Exercises 3.6.8)","text":"Q1. Can data frame zero rows? zero columns?A1. Data frame 0 rows possible. basically list vector length 0.Data frame 0 columns also possible. empty list., finally, data frame 0 rows columns also possible:Although, might common create data frames, can results subsetting. example,Q2. happens attempt set rownames unique?A2. attempt set data frame rownames unique, work.Q3. df data frame, can say t(df), t(t(df))? Perform experiments, making sure try different column types.A3. Transposing data frame:transforms matrixcoerces elements typeQ4. .matrix() applied data frame columns different types? differ data.matrix()?A4. return type .matrix() depends data frame column types.docs .matrix() mention:method data frames return character matrix atomic columns non-(numeric/logical/complex) column, applying .vector factors format non-character columns. Otherwise usual coercion hierarchy (logical < integer < double < complex) used, e.g. -logical data frames coerced logical matrix, mixed logical-integer give integer matrix, etc.Let’s experiment:hand, data.matrix() always returns numeric matrix.documentation data.matrix():Return matrix obtained converting variables data frame numeric mode binding together columns matrix. Factors ordered factors replaced internal codes. […] Character columns first converted factors integers.Let’s experiment:","code":"\ndata.frame(x = numeric(0))\n#> [1] x\n#> <0 rows> (or 0-length row.names)\ndata.frame(row.names = 1)\n#> data frame with 0 columns and 1 row\ndata.frame()\n#> data frame with 0 columns and 0 rows\n\ndim(data.frame())\n#> [1] 0 0\nBOD[0, ]\n#> [1] Time   demand\n#> <0 rows> (or 0-length row.names)\n\nBOD[, 0]\n#> data frame with 0 columns and 6 rows\n\nBOD[0, 0]\n#> data frame with 0 columns and 0 rows\ndata.frame(row.names = c(1, 1))\n#> Error in data.frame(row.names = c(1, 1)): duplicate row.names: 1\n# original\n(df <- head(iris))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n\n# transpose\nt(df)\n#>              1        2        3        4        5       \n#> Sepal.Length \"5.1\"    \"4.9\"    \"4.7\"    \"4.6\"    \"5.0\"   \n#> Sepal.Width  \"3.5\"    \"3.0\"    \"3.2\"    \"3.1\"    \"3.6\"   \n#> Petal.Length \"1.4\"    \"1.4\"    \"1.3\"    \"1.5\"    \"1.4\"   \n#> Petal.Width  \"0.2\"    \"0.2\"    \"0.2\"    \"0.2\"    \"0.2\"   \n#> Species      \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\"\n#>              6       \n#> Sepal.Length \"5.4\"   \n#> Sepal.Width  \"3.9\"   \n#> Petal.Length \"1.7\"   \n#> Petal.Width  \"0.4\"   \n#> Species      \"setosa\"\n\n# transpose of a transpose\nt(t(df))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1 \"5.1\"        \"3.5\"       \"1.4\"        \"0.2\"      \n#> 2 \"4.9\"        \"3.0\"       \"1.4\"        \"0.2\"      \n#> 3 \"4.7\"        \"3.2\"       \"1.3\"        \"0.2\"      \n#> 4 \"4.6\"        \"3.1\"       \"1.5\"        \"0.2\"      \n#> 5 \"5.0\"        \"3.6\"       \"1.4\"        \"0.2\"      \n#> 6 \"5.4\"        \"3.9\"       \"1.7\"        \"0.4\"      \n#>   Species \n#> 1 \"setosa\"\n#> 2 \"setosa\"\n#> 3 \"setosa\"\n#> 4 \"setosa\"\n#> 5 \"setosa\"\n#> 6 \"setosa\"\n\n# is it a dataframe?\nis.data.frame(df)\n#> [1] TRUE\nis.data.frame(t(df))\n#> [1] FALSE\nis.data.frame(t(t(df)))\n#> [1] FALSE\n\n# check type\ntypeof(df)\n#> [1] \"list\"\ntypeof(t(df))\n#> [1] \"character\"\ntypeof(t(t(df)))\n#> [1] \"character\"\n\n# check dimensions\ndim(df)\n#> [1] 6 5\ndim(t(df))\n#> [1] 5 6\ndim(t(t(df)))\n#> [1] 6 5\n# example with mixed types (coerced to character)\n(df <- head(iris))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n\nas.matrix(df)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1 \"5.1\"        \"3.5\"       \"1.4\"        \"0.2\"      \n#> 2 \"4.9\"        \"3.0\"       \"1.4\"        \"0.2\"      \n#> 3 \"4.7\"        \"3.2\"       \"1.3\"        \"0.2\"      \n#> 4 \"4.6\"        \"3.1\"       \"1.5\"        \"0.2\"      \n#> 5 \"5.0\"        \"3.6\"       \"1.4\"        \"0.2\"      \n#> 6 \"5.4\"        \"3.9\"       \"1.7\"        \"0.4\"      \n#>   Species \n#> 1 \"setosa\"\n#> 2 \"setosa\"\n#> 3 \"setosa\"\n#> 4 \"setosa\"\n#> 5 \"setosa\"\n#> 6 \"setosa\"\n\nstr(as.matrix(df))\n#>  chr [1:6, 1:5] \"5.1\" \"4.9\" \"4.7\" \"4.6\" \"5.0\" \"5.4\" ...\n#>  - attr(*, \"dimnames\")=List of 2\n#>   ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ : chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ...\n\n# another example (no such coercion)\nBOD\n#>   Time demand\n#> 1    1    8.3\n#> 2    2   10.3\n#> 3    3   19.0\n#> 4    4   16.0\n#> 5    5   15.6\n#> 6    7   19.8\n\nas.matrix(BOD)\n#>      Time demand\n#> [1,]    1    8.3\n#> [2,]    2   10.3\n#> [3,]    3   19.0\n#> [4,]    4   16.0\n#> [5,]    5   15.6\n#> [6,]    7   19.8\ndata.matrix(df)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2       1\n#> 2          4.9         3.0          1.4         0.2       1\n#> 3          4.7         3.2          1.3         0.2       1\n#> 4          4.6         3.1          1.5         0.2       1\n#> 5          5.0         3.6          1.4         0.2       1\n#> 6          5.4         3.9          1.7         0.4       1\n\nstr(data.matrix(df))\n#>  num [1:6, 1:5] 5.1 4.9 4.7 4.6 5 5.4 3.5 3 3.2 3.1 ...\n#>  - attr(*, \"dimnames\")=List of 2\n#>   ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ : chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ..."},{"path":"vectors.html","id":"session-information-1","chapter":"3 Vectors","heading":"3.6 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  purrr         1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"subsetting.html","id":"subsetting","chapter":"4 Subsetting","heading":"4 Subsetting","text":"Attaching needed libraries:","code":"\nlibrary(tibble)"},{"path":"subsetting.html","id":"selecting-multiple-elements-exercises-4.2.6","chapter":"4 Subsetting","heading":"4.1 Selecting multiple elements (Exercises 4.2.6)","text":"Q1. Fix following common data frame subsetting errors:A1. Fixed versions commands:Q2. following code yield five missing values?A2. two reasons:default type NA R logical type.R recycles indexes match length vector.Q3. upper.tri() return? subsetting matrix work? need additional subsetting rules describe behaviour?A3. documentation upper.tri() states-Returns matrix logicals size given matrix entries TRUE upper triangleWhen used matrix subsetting, elements corresponding TRUE subsetting matrix selected. , instead matrix, returns vector:Q4. mtcars[1:20] return error? differ similar mtcars[1:20, ]?A4. indexed like list, data frame columns given indices selected.mtcars[1:20] doesn’t work 11 columns mtcars dataset.hand, mtcars[1:20, ] indexes dataframe like matrix, indeed 20 rows mtcars, columns rows selected.Q5. Implement function extracts diagonal entries matrix (behave like diag(x) x matrix).A5. can combine existing functions advantage:Q6. df[.na(df)] <- 0 ? work?A6. expression replaces every instance NA df 0..na(df) produces matrix logical values, provides way subsetting.","code":"mtcars[mtcars$cyl = 4, ]\nmtcars[-1:4, ]\nmtcars[mtcars$cyl <= 5]\nmtcars[mtcars$cyl == 4 | 6, ]\n# `==` instead of `=`\nmtcars[mtcars$cyl == 4, ]\n\n# `-(1:4)` instead of `-1:4`\nmtcars[-(1:4), ]\n\n# `,` was missing\nmtcars[mtcars$cyl <= 5, ]\n\n# correct subsetting syntax\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\nmtcars[mtcars$cyl %in% c(4, 6), ]\nx <- 1:5\nx[NA]\n#> [1] NA NA NA NA NA\ntypeof(NA)\n#> [1] \"logical\"\nx <- 1:5\nx[c(TRUE, FALSE)] # recycled to c(TRUE, FALSE, TRUE, FALSE, TRUE)\n#> [1] 1 3 5\nx <- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]\n(x <- outer(1:5, 1:5, FUN = \"*\"))\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]    2    4    6    8   10\n#> [3,]    3    6    9   12   15\n#> [4,]    4    8   12   16   20\n#> [5,]    5   10   15   20   25\n\nupper.tri(x)\n#>       [,1]  [,2]  [,3]  [,4]  [,5]\n#> [1,] FALSE  TRUE  TRUE  TRUE  TRUE\n#> [2,] FALSE FALSE  TRUE  TRUE  TRUE\n#> [3,] FALSE FALSE FALSE  TRUE  TRUE\n#> [4,] FALSE FALSE FALSE FALSE  TRUE\n#> [5,] FALSE FALSE FALSE FALSE FALSE\nx[upper.tri(x)]\n#>  [1]  2  3  6  4  8 12  5 10 15 20\nhead(mtcars[1:2])\n#>                    mpg cyl\n#> Mazda RX4         21.0   6\n#> Mazda RX4 Wag     21.0   6\n#> Datsun 710        22.8   4\n#> Hornet 4 Drive    21.4   6\n#> Hornet Sportabout 18.7   8\n#> Valiant           18.1   6\nnrow(mtcars[1:20, ])\n#> [1] 20\nx[!upper.tri(x) & !lower.tri(x)]\n#> [1]  1  4  9 16 25\n\ndiag(x)\n#> [1]  1  4  9 16 25\n(df <- tibble(x = c(1, 2, NA), y = c(NA, 5, NA)))\n#> # A tibble: 3 × 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     1    NA\n#> 2     2     5\n#> 3    NA    NA\n\nis.na(df)\n#>          x     y\n#> [1,] FALSE  TRUE\n#> [2,] FALSE FALSE\n#> [3,]  TRUE  TRUE\n\nclass(is.na(df))\n#> [1] \"matrix\" \"array\""},{"path":"subsetting.html","id":"selecting-a-single-element-exercises-4.3.5","chapter":"4 Subsetting","heading":"4.2 Selecting a single element (Exercises 4.3.5)","text":"Q1. Brainstorm many ways possible extract third value cyl variable mtcars dataset.A1. Possible ways extract third value cyl variable mtcars dataset:Q2. Given linear model, e.g., mod <- lm(mpg ~ wt, data = mtcars), extract residual degrees freedom. extract R squared model summary (summary(mod))A2. Given objects class lm lists, can use subsetting operators extract elements want.extracting residual degrees freedomextracting R squared model summary","code":"\nmtcars[[\"cyl\"]][[3]]\n#> [1] 4\nmtcars[[c(2, 3)]]\n#> [1] 4\nmtcars[3, ][[\"cyl\"]]\n#> [1] 4\nmtcars[3, ]$cyl\n#> [1] 4\nmtcars[3, \"cyl\"]\n#> [1] 4\nmtcars[, \"cyl\"][[3]]\n#> [1] 4\nmtcars[3, 2]\n#> [1] 4\nmtcars$cyl[[3]]\n#> [1] 4\nmod <- lm(mpg ~ wt, data = mtcars)\nclass(mod)\n#> [1] \"lm\"\ntypeof(mod)\n#> [1] \"list\"\nmod$df.residual \n#> [1] 30\nmod[[\"df.residual\"]]\n#> [1] 30\nsummary(mod)$r.squared\n#> [1] 0.7528328\nsummary(mod)[[\"r.squared\"]]\n#> [1] 0.7528328"},{"path":"subsetting.html","id":"applications-exercises-4.5.9","chapter":"4 Subsetting","heading":"4.3 Applications (Exercises 4.5.9)","text":"Q1. randomly permute columns data frame? (important technique random forests.) Can simultaneously permute rows columns one step?A1. Let’s create small data frame work .randomly permute columns data frame, can combine [ sample() follows:randomly permute columnsrandomly permute rowsrandomly permute columns rowsQ2. select random sample m rows data frame? sample contiguous (.e., initial row, final row, every row )?A2. Let’s create small data frame work .select random sample m rows data frame, can combine [ sample() follows:random non-contiguous sample m rows data framerandom contiguous sample m rows data frameQ3. put columns data frame alphabetical order?A3. can sort columns data frame alphabetical order using [ order():","code":"\ndf <- head(mtcars)\n\n# original\ndf\n#>                    mpg cyl disp  hp drat    wt  qsec vs am\n#> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1\n#> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1\n#> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1\n#> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0\n#> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0\n#> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0\n#>                   gear carb\n#> Mazda RX4            4    4\n#> Mazda RX4 Wag        4    4\n#> Datsun 710           4    1\n#> Hornet 4 Drive       3    1\n#> Hornet Sportabout    3    2\n#> Valiant              3    1\ndf[sample.int(ncol(df))]\n#>                   drat    wt carb am  qsec vs  hp  mpg disp\n#> Mazda RX4         3.90 2.620    4  1 16.46  0 110 21.0  160\n#> Mazda RX4 Wag     3.90 2.875    4  1 17.02  0 110 21.0  160\n#> Datsun 710        3.85 2.320    1  1 18.61  1  93 22.8  108\n#> Hornet 4 Drive    3.08 3.215    1  0 19.44  1 110 21.4  258\n#> Hornet Sportabout 3.15 3.440    2  0 17.02  0 175 18.7  360\n#> Valiant           2.76 3.460    1  0 20.22  1 105 18.1  225\n#>                   cyl gear\n#> Mazda RX4           6    4\n#> Mazda RX4 Wag       6    4\n#> Datsun 710          4    4\n#> Hornet 4 Drive      6    3\n#> Hornet Sportabout   8    3\n#> Valiant             6    3\ndf[sample.int(nrow(df)), ]\n#>                    mpg cyl disp  hp drat    wt  qsec vs am\n#> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1\n#> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1\n#> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1\n#> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0\n#> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0\n#> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0\n#>                   gear carb\n#> Datsun 710           4    1\n#> Mazda RX4 Wag        4    4\n#> Mazda RX4            4    4\n#> Hornet Sportabout    3    2\n#> Hornet 4 Drive       3    1\n#> Valiant              3    1\ndf[sample.int(nrow(df)), sample.int(ncol(df))]\n#>                    qsec vs gear am    wt drat carb disp  hp\n#> Mazda RX4         16.46  0    4  1 2.620 3.90    4  160 110\n#> Hornet 4 Drive    19.44  1    3  0 3.215 3.08    1  258 110\n#> Datsun 710        18.61  1    4  1 2.320 3.85    1  108  93\n#> Mazda RX4 Wag     17.02  0    4  1 2.875 3.90    4  160 110\n#> Valiant           20.22  1    3  0 3.460 2.76    1  225 105\n#> Hornet Sportabout 17.02  0    3  0 3.440 3.15    2  360 175\n#>                    mpg cyl\n#> Mazda RX4         21.0   6\n#> Hornet 4 Drive    21.4   6\n#> Datsun 710        22.8   4\n#> Mazda RX4 Wag     21.0   6\n#> Valiant           18.1   6\n#> Hornet Sportabout 18.7   8\ndf <- head(mtcars)\n\n# original\ndf\n#>                    mpg cyl disp  hp drat    wt  qsec vs am\n#> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1\n#> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1\n#> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1\n#> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0\n#> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0\n#> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0\n#>                   gear carb\n#> Mazda RX4            4    4\n#> Mazda RX4 Wag        4    4\n#> Datsun 710           4    1\n#> Hornet 4 Drive       3    1\n#> Hornet Sportabout    3    2\n#> Valiant              3    1\n\n# number of rows to sample\nm <- 2L\ndf[sample(nrow(df), m), ]\n#>                mpg cyl disp  hp drat    wt  qsec vs am gear\n#> Valiant       18.1   6  225 105 2.76 3.460 20.22  1  0    3\n#> Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4\n#>               carb\n#> Valiant          1\n#> Mazda RX4 Wag    4\n# select a random starting position from available number of rows\nstart_row <- sample(nrow(df) - m + 1, size = 1)\n\n# adjust ending position while avoiding off-by-one error\nend_row <- start_row + m - 1\n\ndf[start_row:end_row, ]\n#>               mpg cyl disp  hp drat    wt  qsec vs am gear\n#> Mazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4\n#> Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4\n#>               carb\n#> Mazda RX4        4\n#> Mazda RX4 Wag    4\n# columns in original order\nnames(mtcars)\n#>  [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"  \n#>  [9] \"am\"   \"gear\" \"carb\"\n\n# columns in alphabetical order\nnames(mtcars[order(names(mtcars))])\n#>  [1] \"am\"   \"carb\" \"cyl\"  \"disp\" \"drat\" \"gear\" \"hp\"   \"mpg\" \n#>  [9] \"qsec\" \"vs\"   \"wt\""},{"path":"subsetting.html","id":"session-information-2","chapter":"4 Subsetting","heading":"4.4 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tibble      * 3.2.1   2023-03-20 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"control-flow.html","id":"control-flow","chapter":"5 Control flow","heading":"5 Control flow","text":"","code":""},{"path":"control-flow.html","id":"choices-exercises-5.2.4","chapter":"5 Control flow","heading":"5.1 Choices (Exercises 5.2.4)","text":"Q1. type vector following calls ifelse() return?Read documentation write rules words.A1. rules call ifelse() might return:type unstable, .e. type return depend type condition true (yes , .e.):works cases test argument evaluates logical type:test argument logical type, NA, return NA:test argument doesn’t resolve logical type, try coerce output logical type:also clarified docs function:vector length attributes (including dimensions \"class\") test data values values yes . mode answer coerced logical accommodate first values taken yes values taken .Q2. following code work?A2. code works conditional expressions () - even though numeric type - can successfully coerced logical type.","code":"\nifelse(TRUE, 1, \"no\")\nifelse(FALSE, 1, \"no\")\nifelse(NA, 1, \"no\")\nifelse(TRUE, 1, \"no\") # `numeric` returned\n#> [1] 1\nifelse(FALSE, 1, \"no\") # `character` returned\n#> [1] \"no\"\nifelse(NA_real_, 1, \"no\")\n#> [1] NA\nifelse(NaN, 1, \"no\")\n#> [1] NA\nifelse(NA, 1, \"no\")\n#> [1] NA\n# will work\nifelse(\"TRUE\", 1, \"no\")\n#> [1] 1\nifelse(\"false\", 1, \"no\")\n#> [1] \"no\"\n\n# won't work\nifelse(\"tRuE\", 1, \"no\")\n#> [1] NA\nifelse(NaN, 1, \"no\")\n#> [1] NA\nx <- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"not empty\"\n\nx <- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"empty\"\nas.logical(length(1:10))\n#> [1] TRUE\n\nas.logical(length(numeric()))\n#> [1] FALSE"},{"path":"control-flow.html","id":"loops-exercises-5.3.3","chapter":"5 Control flow","heading":"5.2 Loops (Exercises 5.3.3)","text":"Q1. code succeed without errors warnings?A1. works 1:length(x) works positive negative directions.case, since x length 0, go 1 0.Additionally, since --bound (OOB) value atomic vectors NA, related operations OOB values also produce NA.way avoid unintended behavior use seq_along() instead:Q2. following code evaluated, can say vector iterated?A2. iterator variable x initially takes values vector xs. can check printing x iteration:worth noting x updated iteration; otherwise, take increasingly bigger values xs, loop never end executing.Q3. following code tell index updated?A3. () loop index updated beginning iteration. Otherwise, encounter infinite loop.Also, worth contrasting behavior () loop () loop:","code":"\nx <- numeric()\nout <- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] <- x[i]^2\n}\nout\n1:2\n#> [1] 1 2\n1:0\n#> [1] 1 0\n1:-3\n#> [1]  1  0 -1 -2 -3\nx <- numeric()\nout <- vector(\"list\", length(x))\n\nfor (i in 1:length(x)) {\n  print(paste(\"i:\", i, \", x[i]:\", x[i], \", out[i]:\", out[i]))\n\n  out[i] <- x[i]^2\n}\n#> [1] \"i: 1 , x[i]: NA , out[i]: NULL\"\n#> [1] \"i: 0 , x[i]:  , out[i]: \"\n\nout\n#> [[1]]\n#> [1] NA\nx <- numeric()\nout <- vector(\"list\", length(x))\n\nfor (i in seq_along(x)) {\n  out[i] <- x[i]^2\n}\n\nout\n#> list()\nxs <- c(1, 2, 3)\nfor (x in xs) {\n  xs <- c(xs, x * 2)\n}\nxs\n#> [1] 1 2 3 2 4 6\nxs <- c(1, 2, 3)\nfor (x in xs) {\n  cat(\"x:\", x, \"\\n\")\n  xs <- c(xs, x * 2)\n  cat(\"xs:\", paste(xs), \"\\n\")\n}\n#> x: 1 \n#> xs: 1 2 3 2 \n#> x: 2 \n#> xs: 1 2 3 2 4 \n#> x: 3 \n#> xs: 1 2 3 2 4 6\nfor (i in 1:3) {\n  i <- i * 2\n  print(i)\n}\n#> [1] 2\n#> [1] 4\n#> [1] 6\nfor (i in 1:3) {\n  cat(\"before: \", i, \"\\n\")\n  i <- i * 2\n  cat(\"after:  \", i, \"\\n\")\n}\n#> before:  1 \n#> after:   2 \n#> before:  2 \n#> after:   4 \n#> before:  3 \n#> after:   6\ni <- 1\nwhile (i < 4) {\n  cat(\"before: \", i, \"\\n\")\n  i <- i * 2\n  cat(\"after:  \", i, \"\\n\")\n}\n#> before:  1 \n#> after:   2 \n#> before:  2 \n#> after:   4"},{"path":"control-flow.html","id":"session-information-3","chapter":"5 Control flow","heading":"5.3 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"functions.html","id":"functions","chapter":"6 Functions","heading":"6 Functions","text":"Attaching needed libraries:","code":"\nlibrary(tidyverse, warn.conflicts = FALSE)"},{"path":"functions.html","id":"function-fundamentals-exercises-6.2.5","chapter":"6 Functions","heading":"6.1 Function fundamentals (Exercises 6.2.5)","text":"Q1. Given name, like \"mean\", match.fun() lets find function. Given function, can find name? doesn’t make sense R?A1. Given name, match.fun() lets find function., given function, doesn’t make sense find name can multiple names bound function.Q2. ’s possible (although typically useful) call anonymous function. two approaches correct? ?A2. first expression correct since function evaluate 3(), syntactically allowed since literals can’t treated like functions.correct way call anonymous function.Q3. good rule thumb anonymous function fit one line shouldn’t need use {}. Review code. used anonymous function instead named function? used named function instead anonymous function?A3. Self activity.Q4. function allows tell object function? function allows tell function primitive function?A4. Use .function() check object function:Use .primitive() check function primitive:Q5. code makes list functions base package.Use answer following questions:base function arguments?base function arguments?many base functions arguments? ’s special functions?many base functions arguments? ’s special functions?adapt code find primitive functions?adapt code find primitive functions?A5. provided code following:base function arguments?can use formals() extract number arguments, function returns NULL primitive functions.Therefore, focus non-primitive functions.scan() function arguments.many base functions arguments? ’s special functions?time writing, 47 base (non-primitive) functions arguments.adapt code find primitive functions?Q6. three important components function?A6. Except primitive functions, functions 3 important components:formals()body()environment()Q7. printing function show environment created ?A7. package functions print environment:two exceptions enclosing environment won’t printed:primitive functionsfunctions created global environment","code":"\nmatch.fun(\"mean\")\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x5594c2d28820>\n#> <environment: namespace:base>\nf1 <- function(x) mean(x)\nf2 <- f1\n\nmatch.fun(\"f1\")\n#> function (x) \n#> mean(x)\n\nmatch.fun(\"f2\")\n#> function (x) \n#> mean(x)\nfunction(x) 3()\n#> function (x) \n#> 3()\n(function(x) 3)()\n#> [1] 3\nf <- (function(x) 3())\nf\n#> function (x) \n#> 3()\nf()\n#> Error in f(): attempt to apply non-function\n\nrlang::is_syntactic_literal(3)\n#> [1] TRUE\ng <- (function(x) 3)\ng\n#> function (x) \n#> 3\ng()\n#> [1] 3\n# these are functions\nf <- function(x) 3\nis.function(mean)\n#> [1] TRUE\nis.function(f)\n#> [1] TRUE\n\n# these aren't\nis.function(\"x\")\n#> [1] FALSE\nis.function(new.env())\n#> [1] FALSE\n# primitive\nis.primitive(sum)\n#> [1] TRUE\nis.primitive(`+`)\n#> [1] TRUE\n\n# not primitive\nis.primitive(mean)\n#> [1] FALSE\nis.primitive(read.csv)\n#> [1] FALSE\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\nformals(\"!\")\n#> NULL\n\nlength(formals(\"!\"))\n#> [1] 0\nfuns <- purrr::discard(funs, is.primitive)\ndf_formals <- purrr::map_df(funs, ~ length(formals(.))) %>%\n  tidyr::pivot_longer(\n    cols = dplyr::everything(),\n    names_to = \"function\",\n    values_to = \"argumentCount\"\n  ) %>%\n  dplyr::arrange(desc(argumentCount))\n\ndf_formals\n#> # A tibble: 1,145 × 2\n#>    `function`        argumentCount\n#>    <chr>                     <int>\n#>  1 scan                         22\n#>  2 source                       17\n#>  3 format.default               16\n#>  4 formatC                      15\n#>  5 library                      13\n#>  6 merge.data.frame             13\n#>  7 prettyNum                    13\n#>  8 system2                      12\n#>  9 system                       11\n#> 10 all.equal.numeric            10\n#> # ℹ 1,135 more rows\ndplyr::filter(df_formals, argumentCount == 0)\n#> # A tibble: 47 × 2\n#>    `function`               argumentCount\n#>    <chr>                            <int>\n#>  1 .First.sys                           0\n#>  2 .NotYetImplemented                   0\n#>  3 .OptRequireMethods                   0\n#>  4 .standard_regexps                    0\n#>  5 .tryResumeInterrupt                  0\n#>  6 closeAllConnections                  0\n#>  7 contributors                         0\n#>  8 Cstack_info                          0\n#>  9 default.stringsAsFactors             0\n#> 10 extSoftVersion                       0\n#> # ℹ 37 more rows\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\nprimitives <- Filter(is.primitive, funs)\n\nlength(primitives)\n#> [1] 210\n\nnames(primitives)\n#>   [1] \"-\"                    \":\"                   \n#>   [3] \"::\"                   \":::\"                 \n#>   [5] \"!\"                    \"!=\"                  \n#>   [7] \"...elt\"               \"...length\"           \n#>   [9] \"...names\"             \".C\"                  \n#>  [11] \".cache_class\"         \".Call\"               \n#>  [13] \".Call.graphics\"       \".class2\"             \n#>  [15] \".External\"            \".External.graphics\"  \n#>  [17] \".External2\"           \".Fortran\"            \n#>  [19] \".Internal\"            \".isMethodsDispatchOn\"\n#>  [21] \".Primitive\"           \".primTrace\"          \n#>  [23] \".primUntrace\"         \".subset\"             \n#>  [25] \".subset2\"             \"(\"                   \n#>  [27] \"[\"                    \"[[\"                  \n#>  [29] \"[[<-\"                 \"[<-\"                 \n#>  [31] \"{\"                    \"@\"                   \n#>  [33] \"@<-\"                  \"*\"                   \n#>  [35] \"/\"                    \"&\"                   \n#>  [37] \"&&\"                   \"%*%\"                 \n#>  [39] \"%/%\"                  \"%%\"                  \n#>  [41] \"^\"                    \"+\"                   \n#>  [43] \"<\"                    \"<-\"                  \n#>  [45] \"<<-\"                  \"<=\"                  \n#>  [47] \"=\"                    \"==\"                  \n#>  [49] \">\"                    \">=\"                  \n#>  [51] \"|\"                    \"||\"                  \n#>  [53] \"~\"                    \"$\"                   \n#>  [55] \"$<-\"                  \"abs\"                 \n#>  [57] \"acos\"                 \"acosh\"               \n#>  [59] \"all\"                  \"any\"                 \n#>  [61] \"anyNA\"                \"Arg\"                 \n#>  [63] \"as.call\"              \"as.character\"        \n#>  [65] \"as.complex\"           \"as.double\"           \n#>  [67] \"as.environment\"       \"as.integer\"          \n#>  [69] \"as.logical\"           \"as.numeric\"          \n#>  [71] \"as.raw\"               \"asin\"                \n#>  [73] \"asinh\"                \"atan\"                \n#>  [75] \"atanh\"                \"attr\"                \n#>  [77] \"attr<-\"               \"attributes\"          \n#>  [79] \"attributes<-\"         \"baseenv\"             \n#>  [81] \"break\"                \"browser\"             \n#>  [83] \"c\"                    \"call\"                \n#>  [85] \"ceiling\"              \"class\"               \n#>  [87] \"class<-\"              \"Conj\"                \n#>  [89] \"cos\"                  \"cosh\"                \n#>  [91] \"cospi\"                \"crossprod\"           \n#>  [93] \"cummax\"               \"cummin\"              \n#>  [95] \"cumprod\"              \"cumsum\"              \n#>  [97] \"declare\"              \"digamma\"             \n#>  [99] \"dim\"                  \"dim<-\"               \n#> [101] \"dimnames\"             \"dimnames<-\"          \n#> [103] \"emptyenv\"             \"enc2native\"          \n#> [105] \"enc2utf8\"             \"environment<-\"       \n#> [107] \"Exec\"                 \"exp\"                 \n#> [109] \"expm1\"                \"expression\"          \n#> [111] \"floor\"                \"for\"                 \n#> [113] \"forceAndCall\"         \"function\"            \n#> [115] \"gamma\"                \"gc.time\"             \n#> [117] \"globalenv\"            \"if\"                  \n#> [119] \"Im\"                   \"interactive\"         \n#> [121] \"invisible\"            \"is.array\"            \n#> [123] \"is.atomic\"            \"is.call\"             \n#> [125] \"is.character\"         \"is.complex\"          \n#> [127] \"is.double\"            \"is.environment\"      \n#> [129] \"is.expression\"        \"is.finite\"           \n#> [131] \"is.function\"          \"is.infinite\"         \n#> [133] \"is.integer\"           \"is.language\"         \n#> [135] \"is.list\"              \"is.logical\"          \n#> [137] \"is.matrix\"            \"is.na\"               \n#> [139] \"is.name\"              \"is.nan\"              \n#> [141] \"is.null\"              \"is.numeric\"          \n#> [143] \"is.object\"            \"is.pairlist\"         \n#> [145] \"is.raw\"               \"is.recursive\"        \n#> [147] \"is.single\"            \"is.symbol\"           \n#> [149] \"isS4\"                 \"lazyLoadDBfetch\"     \n#> [151] \"length\"               \"length<-\"            \n#> [153] \"levels<-\"             \"lgamma\"              \n#> [155] \"list\"                 \"log\"                 \n#> [157] \"log10\"                \"log1p\"               \n#> [159] \"log2\"                 \"max\"                 \n#> [161] \"min\"                  \"missing\"             \n#> [163] \"Mod\"                  \"names\"               \n#> [165] \"names<-\"              \"nargs\"               \n#> [167] \"next\"                 \"nzchar\"              \n#> [169] \"oldClass\"             \"oldClass<-\"          \n#> [171] \"on.exit\"              \"pos.to.env\"          \n#> [173] \"proc.time\"            \"prod\"                \n#> [175] \"quote\"                \"range\"               \n#> [177] \"Re\"                   \"rep\"                 \n#> [179] \"repeat\"               \"retracemem\"          \n#> [181] \"return\"               \"round\"               \n#> [183] \"seq_along\"            \"seq_len\"             \n#> [185] \"seq.int\"              \"sign\"                \n#> [187] \"signif\"               \"sin\"                 \n#> [189] \"sinh\"                 \"sinpi\"               \n#> [191] \"sqrt\"                 \"standardGeneric\"     \n#> [193] \"storage.mode<-\"       \"substitute\"          \n#> [195] \"sum\"                  \"switch\"              \n#> [197] \"Tailcall\"             \"tan\"                 \n#> [199] \"tanh\"                 \"tanpi\"               \n#> [201] \"tcrossprod\"           \"tracemem\"            \n#> [203] \"trigamma\"             \"trunc\"               \n#> [205] \"unCfillPOSIXlt\"       \"unclass\"             \n#> [207] \"untracemem\"           \"UseMethod\"           \n#> [209] \"while\"                \"xtfrm\"\n# base\nmean\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x5594c2d28820>\n#> <environment: namespace:base>\n\n# other package function\npurrr::map\n#> function (.x, .f, ..., .progress = FALSE) \n#> {\n#>     map_(\"list\", .x, .f, ..., .progress = .progress)\n#> }\n#> <bytecode: 0x5594c6726a50>\n#> <environment: namespace:purrr>\nsum\n#> function (..., na.rm = FALSE)  .Primitive(\"sum\")\nf <- function(x) mean(x)\nf\n#> function (x) \n#> mean(x)"},{"path":"functions.html","id":"lexical-scoping-exercises-6.4.5","chapter":"6 Functions","heading":"6.2 Lexical scoping (Exercises 6.4.5)","text":"Q1. following code return? ? Describe three c’s interpreted.A1. c(c = c):first c interpreted function call c()second c name vector elementthird c variable value 10You can also see lexical analysis expression:Q2. four principles govern R looks values?A2. Principles govern R looks values:Name masking (names defined inside function mask names defined outside function)Name masking (names defined inside function mask names defined outside function)Functions vs. variables (rule also applies function names)Functions vs. variables (rule also applies function names)fresh start (every time function called, new environment created host execution)fresh start (every time function called, new environment created host execution)Dynamic look-(R looks values function run, function created)Dynamic look-(R looks values function run, function created)Q3. following function return? Make prediction running code .A3. Correctly predicted 😉Although multiple f() functions, order evaluation goes inside outside x^2 evaluated first f(x) * 2 evaluated last. results 202 (= ((10 ^ 2) + 1) * 2).","code":"\nc <- 10\nc(c = c)\nc <- 10\nc(c = c)\n#>  c \n#> 10\np_expr <- parse(text = \"c(c = c)\", keep.source = TRUE)\ngetParseData(p_expr) %>% select(token, text)\n#>                   token text\n#> 12                 expr     \n#> 1  SYMBOL_FUNCTION_CALL    c\n#> 3                  expr     \n#> 2                   '('    (\n#> 4            SYMBOL_SUB    c\n#> 5                EQ_SUB    =\n#> 6                SYMBOL    c\n#> 8                  expr     \n#> 7                   ')'    )\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\n\nf(10)\n#> [1] 202"},{"path":"functions.html","id":"lazy-evaluation-exercises-6.5.4","chapter":"6 Functions","heading":"6.3 Lazy evaluation (Exercises 6.5.4)","text":"Q1. important property && makes x_ok() work?different code? behaviour undesirable ?A1. && evaluates left right short-circuit evaluation, .e., first operand TRUE, R short-circuit even look second operand.Replacing && & undesirable performs element-wise logical comparisons returns vector values always useful decision (TRUE, FALSE, NA).Q2. function return? ? principle illustrate?A2. function returns 100 due lazy evaluation.function execution environment encounters x, evaluates argument x = z since name z already bound value 100 environment, x also bound value.can check looking memory addresses:Q3. function return? ? principle illustrate?A3. Let’s first look function returns:name masking. function call c(x, y), x accessed function environment, following promise evaluated function environment:, thus y gets assigned 1, x 2, since last value scope.Therefore, neither promise y = 0 global assignment y <- 10 ever consulted find value y.Q4. hist(), default value xlim range(breaks), default value breaks \"Sturges\", andExplain hist() works get correct xlim value.A4. xlim defines range histogram’s x-axis.default xlim = range(breaks) breaks = \"Sturges\" arguments reveal function uses Sturges’ algorithm compute number breaks.see implementation, run sloop::s3_get_method(\"hist.default\").hist() ensures chosen algorithm returns numeric vector containing least two unique elements xlim computed.Q5. Explain function works. confusing?A5. Let’s take step--step.function argument x missing function call. means stop(\"Error!\") evaluated function environment, global environment., due lazy evaluation, promise stop(\"Error!\") evaluated x accessed. happens print(x) called.print(x) leads x evaluated, evaluates stop function environment. , function environment, base::stop() masked locally defined stop() function, returns Sys.time() output.Q6. many arguments required calling library()?A6. Going solely signature,looks like following arguments required:, reality, one argument required: package. function internally checks arguments missing adjusts accordingly.better arguments NULL instead missing; avoid confusion.","code":"\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\nx_ok(1)\nx_ok(1:3)\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\nx_ok(1)\nx_ok(1:3)\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\n\nx_ok(1)\n#> [1] TRUE\n\nx_ok(1:3)\n#> [1] FALSE\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\n\nx_ok(1)\n#> [1] TRUE\n\nx_ok(1:3)\n#> [1] FALSE FALSE FALSE\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()\nf2 <- function(x = z) {\n  z <- 100\n  print(lobstr::obj_addrs(list(x, z)))\n  x\n}\n\nf2()\n#> [1] \"0x5594cb899ba8\" \"0x5594cb899ba8\"\n#> [1] 100\ny <- 10\nf1 <- function(x =\n                 {\n                   y <- 1\n                   2\n                 },\n               y = 0) {\n  c(x, y)\n}\nf1()\ny\ny <- 10\nf1 <- function(x =\n                 {\n                   y <- 1\n                   2\n                 },\n               y = 0) {\n  c(x, y)\n}\nf1()\n#> [1] 2 1\ny\n#> [1] 10\nx <- {\n  y <- 1\n  2\n}\nrange(\"Sturges\")\n#> [1] \"Sturges\" \"Sturges\"\nhist(mtcars$wt, xlim = c(1, 6))\nnclass.Sturges(mtcars$wt)\n#> [1] 6\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\n\nshow_time()\n#> [1] \"2024-10-01 21:35:05 UTC\"\nformals(library)\n#> $package\n#> \n#> \n#> $help\n#> \n#> \n#> $pos\n#> [1] 2\n#> \n#> $lib.loc\n#> NULL\n#> \n#> $character.only\n#> [1] FALSE\n#> \n#> $logical.return\n#> [1] FALSE\n#> \n#> $warn.conflicts\n#> \n#> \n#> $quietly\n#> [1] FALSE\n#> \n#> $verbose\n#> getOption(\"verbose\")\n#> \n#> $mask.ok\n#> \n#> \n#> $exclude\n#> \n#> \n#> $include.only\n#> \n#> \n#> $attach.required\n#> missing(include.only)\nformals(library) %>%\n  purrr::discard(is.null) %>%\n  purrr::map_lgl(~ .x == \"\") %>%\n  purrr::keep(~ isTRUE(.x)) %>%\n  names()\n#> [1] \"package\"        \"help\"           \"warn.conflicts\"\n#> [4] \"mask.ok\"        \"exclude\"        \"include.only\""},{"path":"functions.html","id":"dot-dot-dot-exercises-6.6.1","chapter":"6 Functions","heading":"6.4 ... (dot-dot-dot) (Exercises 6.6.1)","text":"Q1. Explain following results:A1. Let’s look arguments functions:can seen, sum() function doesn’t na.omit argument. , input na.omit = TRUE treated 1 (logical implicitly coerced numeric), thus results. , expression evaluates sum(1, 2, 3, 1).mean() function, one parameter (x) ’s matched first argument (1). , expression evaluates mean(1).Q2. Explain find documentation named arguments following function call:A2. Typing ?plot console, see documentation, also shows signature:Since ... passed par(), can look ?par docs:.docs parameters interest reside .Q3. plot(1:10, col = \"red\") colour points, axes labels? Read source code plot.default() find .A3. Source code can found .plot.default() passes ... localTitle(), passes title().title() four parts: main, sub, xlab, ylab.single argument col work ambiguous element apply argument .","code":"\nsum(1, 2, 3)\n#> [1] 6\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1\nstr(sum)\n#> function (..., na.rm = FALSE)\nstr(mean)\n#> function (x, ...)\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")#> function (x, y, ...)#> function (..., no.readonly = FALSE)\nlocalTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)\n\ntitle <- function(main = NULL, sub = NULL, xlab = NULL, ylab = NULL,\n                  line = NA, outer = FALSE, ...) {\n  main <- as.graphicsAnnot(main)\n  sub <- as.graphicsAnnot(sub)\n  xlab <- as.graphicsAnnot(xlab)\n  ylab <- as.graphicsAnnot(ylab)\n  .External.graphics(C_title, main, sub, xlab, ylab, line, outer, ...)\n  invisible()\n}"},{"path":"functions.html","id":"exiting-a-function-exercises-6.7.5","chapter":"6 Functions","heading":"6.5 Exiting a function (Exercises 6.7.5)","text":"Q1. load() return? don’t normally see values?A1. load() function reloads datasets saved using save() function:normally don’t see value function loads datasets invisibly.can change setting verbose = TRUE:Q2. write.table() return? useful?A2. write.table() writes data frame file returns NULL invisibly.helpful function invisibly returned actual object written file, used.Q3. chdir parameter source() compare with_dir()? might prefer one ?A3. chdir parameter source() described :TRUE file pathname, R working directory temporarily changed directory containing file evaluatingThat , chdir allows changing working directory temporarily directory containing file sourced:withr::with_dir() temporarily changes current working directory:importantly, parameters dir allows temporarily changing working directory directory.Q4. Write function opens graphics device, runs supplied code, closes graphics device (always, regardless whether plotting code works).A4. function opens graphics device, runs supplied code, closes graphics device:Q5. can use .exit() implement simple version capture.output().Compare capture.output() capture.output2(). functions differ? features removed make key ideas easier see? rewritten key ideas ’re easier understand?A5. capture.output() significantly complex, can seen definition:key differences:capture.output() uses print() function print console:capture.output() can capture messages well:capture.output() takes account visibility expression:","code":"\nsave(iris, file = \"my_iris.rda\")\nload(\"my_iris.rda\")\nload(\"my_iris.rda\", verbose = TRUE)\n#> Loading objects:\n#>   iris\n\n# cleanup\nunlink(\"my_iris.rda\")\nwrite.table(BOD, file = \"BOD.csv\")\n# cleanup\nunlink(\"BOD.csv\")\nwithr::with_dir\n#> function (new, code) \n#> {\n#>     old <- setwd(dir = new)\n#>     on.exit(setwd(old))\n#>     force(code)\n#> }\n#> <bytecode: 0x5594c7a56378>\n#> <environment: namespace:withr>\nwith_png_device <- function(filename, code, ...) {\n  grDevices::png(filename = filename, ...)\n  on.exit(grDevices::dev.off(), add = TRUE)\n\n  force(code)\n}\ncapture.output2 <- function(code) {\n  temp <- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n\n  force(code)\n  readLines(temp)\n}\n\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n#> [1] \"a\" \"b\" \"c\"\ncapture.output\n#> function (..., file = NULL, append = FALSE, type = c(\"output\", \n#>     \"message\"), split = FALSE) \n#> {\n#>     type <- match.arg(type)\n#>     rval <- NULL\n#>     closeit <- TRUE\n#>     if (is.null(file)) \n#>         file <- textConnection(\"rval\", \"w\", local = TRUE)\n#>     else if (is.character(file)) \n#>         file <- file(file, if (append) \n#>             \"a\"\n#>         else \"w\")\n#>     else if (inherits(file, \"connection\")) {\n#>         if (!isOpen(file)) \n#>             open(file, if (append) \n#>                 \"a\"\n#>             else \"w\")\n#>         else closeit <- FALSE\n#>     }\n#>     else stop(\"'file' must be NULL, a character string or a connection\")\n#>     sink(file, type = type, split = split)\n#>     on.exit({\n#>         sink(type = type, split = split)\n#>         if (closeit) close(file)\n#>     })\n#>     for (i in seq_len(...length())) {\n#>         out <- withVisible(...elt(i))\n#>         if (out$visible) \n#>             print(out$value)\n#>     }\n#>     on.exit()\n#>     sink(type = type, split = split)\n#>     if (closeit) \n#>         close(file)\n#>     rval %||% invisible(NULL)\n#> }\n#> <bytecode: 0x5594c6255bf0>\n#> <environment: namespace:utils>\ncapture.output(1)\n#> [1] \"[1] 1\"\n\ncapture.output2(1)\n#> character(0)\ncapture.output(message(\"Hi there!\"), \"a\", type = \"message\")\n#> Hi there!\n#> [1] \"a\"\n#> character(0)\ncapture.output(1, invisible(2), 3)\n#> [1] \"[1] 1\" \"[1] 3\""},{"path":"functions.html","id":"function-forms-exercises-6.8.6","chapter":"6 Functions","heading":"6.6 Function forms (Exercises 6.8.6)","text":"Q1. Rewrite following code snippets prefix form:A1. Prefix forms code snippets:Q2. Clarify following list odd function calls:A2. functions don’t dots (...) parameters, argument matching takes place following steps:exact matching named argumentspartial matchingposition-basedQ3. Explain following code fails:A3. provided book, replacement function defined :Let’s re-write provided code prefix format understand doesn’t work:Although works:following doesn’t code evaluates :get<- function R.Q4. Create replacement function modifies random location vector.A4. replacement function modifies random location vector:Let’s try :Q5. Write version + pastes inputs together character vectors behaves usual otherwise. words, make code work:A5. Infix operator re-create desired output:Q6. Create list replacement functions found base package. ones primitive functions? (Hint: use apropos().)A6. Replacement functions always <- end names., using apropos(), can find replacement functions search paths filter ones don’t belong {base} package:primitive replacement functions can listed using .primitive():Q7. valid names user-created infix functions?A7. mentioned respective section book:names infix functions flexible regular R functions: can contain sequence characters except %.Q8. Create infix xor() operator.A8. Exclusive logical operation TRUE arguments differ (one TRUE, FALSE).can create infix operator exclusive like :function vectorized inputs underlying logical operators vectorized.Q9. Create infix versions set functions intersect(), union(), setdiff(). might call %n%, %u%, %/% match conventions mathematics.A9. required infix operators can created following:can check outputs agree underlying functions:","code":"\n1 + 2 + 3\n\n1 + (2 + 3)\n\nif (length(x) <= 5) x[[5]] else x[[n]]\n# The binary `+`  operator has left to right associative property.\n`+`(`+`(1, 2), 3)\n\n`+`(1, `(`(`+`(2, 3)))\n\n`if`(cond = `<=`(length(x), 5), cons.expr = `[[`(x, 5), alt.expr = `[[`(x, n))\nx <- sample(replace = TRUE, 20, x = c(1:10, NA))\ny <- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\nmodify(get(\"x\"), 1) <- 10\n#> Error: target of assignment expands to non-language object\n`modify<-` <- function(x, position, value) {\n  x[position] <- value\n  x\n}\nget(\"x\") <- `modify<-`(x = get(\"x\"), position = 1, value = 10)\nx <- 5\n`modify<-`(x = get(\"x\"), position = 1, value = 10)\n#> [1] 10\n`get<-`(\"x\", 10)\n#> Error in `get<-`(\"x\", 10): could not find function \"get<-\"\n`random_modify<-` <- function(x, value) {\n  random_index <- sample(seq_along(x), size = 1)\n  x[random_index] <- value\n  return(x)\n}\nx1 <- rep(\"a\", 10)\nrandom_modify(x1) <- \"X\"\nx1\n#>  [1] \"a\" \"a\" \"a\" \"a\" \"X\" \"a\" \"a\" \"a\" \"a\" \"a\"\n\nx2 <- rep(\"a\", 10)\nrandom_modify(x2) <- \"Y\"\nx2\n#>  [1] \"a\" \"a\" \"a\" \"a\" \"a\" \"Y\" \"a\" \"a\" \"a\" \"a\"\n\nx3 <- rep(0, 15)\nrandom_modify(x3) <- -4\nx3\n#>  [1]  0  0  0  0 -4  0  0  0  0  0  0  0  0  0  0\n\nx4 <- rep(0, 15)\nrandom_modify(x4) <- -1\nx4\n#>  [1]  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0\n1 + 2\n#> [1] 3\n\n\"a\" + \"b\"\n#> [1] \"ab\"\n`+` <- function(x, y) {\n  if (is.character(x) || is.character(y)) {\n    paste0(x, y)\n  } else {\n    base::`+`(x, y)\n  }\n}\n\n1 + 2\n#> [1] 3\n\n\"a\" + \"b\"\n#> [1] \"ab\"\n\nrm(\"+\", envir = .GlobalEnv)\nls_replacement <- apropos(\"<-\", where = TRUE, mode = \"function\")\n\nbase_index <- which(grepl(\"base\", searchpaths()))\n\nls_replacement <- ls_replacement[which(names(ls_replacement) == as.character(base_index))]\n\nunname(ls_replacement)\n#>  [1] \".rowNamesDF<-\"           \"[[<-\"                   \n#>  [3] \"[[<-.data.frame\"         \"[[<-.factor\"            \n#>  [5] \"[[<-.numeric_version\"    \"[[<-.POSIXlt\"           \n#>  [7] \"[<-\"                     \"[<-.data.frame\"         \n#>  [9] \"[<-.Date\"                \"[<-.difftime\"           \n#> [11] \"[<-.factor\"              \"[<-.numeric_version\"    \n#> [13] \"[<-.POSIXct\"             \"[<-.POSIXlt\"            \n#> [15] \"@<-\"                     \"<-\"                     \n#> [17] \"<<-\"                     \"$<-\"                    \n#> [19] \"$<-.data.frame\"          \"$<-.POSIXlt\"            \n#> [21] \"attr<-\"                  \"attributes<-\"           \n#> [23] \"body<-\"                  \"class<-\"                \n#> [25] \"colnames<-\"              \"comment<-\"              \n#> [27] \"diag<-\"                  \"dim<-\"                  \n#> [29] \"dimnames<-\"              \"dimnames<-.data.frame\"  \n#> [31] \"Encoding<-\"              \"environment<-\"          \n#> [33] \"formals<-\"               \"is.na<-\"                \n#> [35] \"is.na<-.default\"         \"is.na<-.factor\"         \n#> [37] \"is.na<-.numeric_version\" \"length<-\"               \n#> [39] \"length<-.Date\"           \"length<-.difftime\"      \n#> [41] \"length<-.factor\"         \"length<-.POSIXct\"       \n#> [43] \"length<-.POSIXlt\"        \"levels<-\"               \n#> [45] \"levels<-.factor\"         \"mode<-\"                 \n#> [47] \"mostattributes<-\"        \"names<-\"                \n#> [49] \"names<-.POSIXlt\"         \"oldClass<-\"             \n#> [51] \"parent.env<-\"            \"regmatches<-\"           \n#> [53] \"row.names<-\"             \"row.names<-.data.frame\" \n#> [55] \"row.names<-.default\"     \"rownames<-\"             \n#> [57] \"split<-\"                 \"split<-.data.frame\"     \n#> [59] \"split<-.default\"         \"storage.mode<-\"         \n#> [61] \"substr<-\"                \"substring<-\"            \n#> [63] \"units<-\"                 \"units<-.difftime\"\nmget(ls_replacement, envir = baseenv()) %>%\n  purrr::keep(is.primitive) %>%\n  names()\n#>  [1] \"[[<-\"           \"[<-\"            \"@<-\"           \n#>  [4] \"<-\"             \"<<-\"            \"$<-\"           \n#>  [7] \"attr<-\"         \"attributes<-\"   \"class<-\"       \n#> [10] \"dim<-\"          \"dimnames<-\"     \"environment<-\" \n#> [13] \"length<-\"       \"levels<-\"       \"names<-\"       \n#> [16] \"oldClass<-\"     \"storage.mode<-\"\nlv1 <- c(TRUE, FALSE, TRUE, FALSE)\nlv2 <- c(TRUE, TRUE, FALSE, FALSE)\n\nxor(lv1, lv2)\n#> [1] FALSE  TRUE  TRUE FALSE\n`%xor%` <- function(x, y) {\n  !((x & y) | !(x | y))\n}\n\nlv1 %xor% lv2\n#> [1] FALSE  TRUE  TRUE FALSE\n\nTRUE %xor% TRUE\n#> [1] FALSE\n`%n%` <- function(x, y) {\n  intersect(x, y)\n}\n\n`%u%` <- function(x, y) {\n  union(x, y)\n}\n\n`%/%` <- function(x, y) {\n  setdiff(x, y)\n}\n(x <- c(sort(sample(1:20, 9)), NA))\n#>  [1]  4  7  8  9 11 13 15 16 20 NA\n(y <- c(sort(sample(3:23, 7)), NA))\n#> [1]  9 10 13 15 17 19 20 NA\n\nidentical(intersect(x, y), x %n% y)\n#> [1] TRUE\nidentical(union(x, y), x %u% y)\n#> [1] TRUE\nidentical(setdiff(x, y), x %/% y)\n#> [1] TRUE"},{"path":"functions.html","id":"session-information-4","chapter":"6 Functions","heading":"6.7 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  colorspace    2.1-1   2024-07-26 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr       * 1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  forcats     * 1.0.0   2023-01-29 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  ggplot2     * 3.5.1   2024-04-23 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  grid          4.4.1   2024-08-22 [3] local\n#>  gtable        0.3.5   2024-04-22 [1] RSPM\n#>  highr         0.11    2024-05-26 [1] RSPM\n#>  hms           1.1.3   2023-03-21 [1] RSPM\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  lobstr        1.1.2   2022-06-22 [1] RSPM\n#>  lubridate   * 1.9.3   2023-09-27 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  munsell       0.5.1   2024-04-01 [1] RSPM\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  purrr       * 1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  readr       * 2.1.5   2024-01-10 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  scales        1.3.0   2023-11-28 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  stringi       1.8.4   2024-05-06 [1] RSPM\n#>  stringr     * 1.5.1   2023-11-14 [1] RSPM\n#>  tibble      * 3.2.1   2023-03-20 [1] RSPM\n#>  tidyr       * 1.3.1   2024-01-24 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tidyverse   * 2.0.0   2023-02-22 [1] RSPM\n#>  timechange    0.3.0   2024-01-18 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  tzdb          0.4.0   2023-05-12 [1] RSPM\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"environments.html","id":"environments","chapter":"7 Environments","heading":"7 Environments","text":"Loading needed libraries:","code":"\nlibrary(rlang, warn.conflicts = FALSE)"},{"path":"environments.html","id":"environment-basics-exercises-7.2.7","chapter":"7 Environments","heading":"7.1 Environment basics (Exercises 7.2.7)","text":"Q1. List three ways environment differs list.A1. mentioned book, ways environments differ lists:Q2. Create environment illustrated picture.A2. Creating environment illustrated picture:binding loop memory address environment e:Q3. Create pair environments illustrated picture.A3. Creating specified environment:Q4. Explain e[[1]] e[c(\"\", \"b\")] don’t make sense e environment.A4. environment non-linear data structure, concept ordered elements. Therefore, indexing (e.g. e[[1]]) doesn’t make sense.Subsetting list vector returns subset underlying data structure. example, subsetting vector returns another vector. ’s unclear subsetting environment (e.g. e[c(\"\", \"b\")]) return data structure contain returns. can’t another environment since environments reference semantics.Q5. Create version env_poke() bind new names, never re-bind old names. programming languages , known single assignment languages.A5. Create version env_poke() doesn’t allow re-binding old names:Making sure behaves expected:Contrast behavior following:Q6. function ? differ <<- might prefer ?A6. downside <<- create new binding doesn’t exist given environment, something may wish:rebind() function let us know binding doesn’t exist, much safer:","code":"\nlibrary(rlang)\n\ne <- env()\ne$loop <- e\nenv_print(e)\n#> <environment: 0x55d2e4519c00>\n#> Parent: <environment: global>\n#> Bindings:\n#> • loop: <env>\nlobstr::ref(e$loop)\n#> █ [1:0x55d2e4519c00] <env> \n#> └─loop = [1:0x55d2e4519c00]\ne1 <- env()\ne2 <- env()\n\ne1$loop <- e2\ne2$deloop <- e1\n\n# following should be the same\nlobstr::obj_addrs(list(e1, e2$deloop))\n#> [1] \"0x55d2e5d92c68\" \"0x55d2e5d92c68\"\nlobstr::obj_addrs(list(e2, e1$loop))\n#> [1] \"0x55d2e5d71420\" \"0x55d2e5d71420\"\nenv_poke2 <- function(env, nm, value) {\n  if (env_has(env, nm)) {\n    abort(\"Can't re-bind existing names.\")\n  }\n\n  env_poke(env, nm, value)\n}\ne <- env(a = 1, b = 2, c = 3)\n\n# re-binding old names not allowed\nenv_poke2(e, \"b\", 4)\n#> Error in `env_poke2()`:\n#> ! Can't re-bind existing names.\n\n# binding new names allowed\nenv_poke2(e, \"d\", 8)\ne$d\n#> [1] 8\ne <- env(a = 1, b = 2, c = 3)\n\ne$b\n#> [1] 2\n\n# re-binding old names allowed\nenv_poke(e, \"b\", 4)\ne$b\n#> [1] 4\nrebind <- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"a\", 10)\n#> Error: Can't find `a`\na <- 5\nrebind(\"a\", 10)\na\n#> [1] 10\n# `x` doesn't exist\nexists(\"x\")\n#> [1] FALSE\n\n# so `<<-` will create one for us\n{\n  x <<- 5\n}\n\n# in the global environment\nenv_has(global_env(), \"x\")\n#>    x \n#> TRUE\nx\n#> [1] 5\nrebind <- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\n\n# doesn't exist\nexists(\"abc\")\n#> [1] FALSE\n\n# so function will produce an error instead of creating it for us\nrebind(\"abc\", 10)\n#> Error: Can't find `abc`\n\n# but it will work as expected when the variable already exists\nabc <- 5\nrebind(\"abc\", 10)\nabc\n#> [1] 10"},{"path":"environments.html","id":"recursing-over-environments-exercises-7.3.1","chapter":"7 Environments","heading":"7.2 Recursing over environments (Exercises 7.3.1)","text":"Q1. Modify () return environments contain binding name. Carefully think type object function need return.A1. modified version () returns environments contain binding name.Since anticipate one environment, dynamically update list time environment specified binding found. important initialize empty list since signifies given binding found environments.Let’s try :Q2. Write function called fget() finds function objects. two arguments, name env, obey regular scoping rules functions: ’s object matching name ’s function, look parent. added challenge, also add inherits argument controls whether function recurses parents looks one environment.A2. function recursively looks function objects:Let’s try :","code":"\nwhere <- function(name, env = caller_env()) {\n  env_list <- list()\n\n  while (!identical(env, empty_env())) {\n    if (env_has(env, name)) {\n      env_list <- append(env_list, env)\n    }\n\n    env <- env_parent(env)\n  }\n\n  return(env_list)\n}\nwhere(\"yyy\")\n#> list()\n\nx <- 5\nwhere(\"x\")\n#> [[1]]\n#> <environment: R_GlobalEnv>\n\nwhere(\"mean\")\n#> [[1]]\n#> <environment: base>\n\nlibrary(dplyr, warn.conflicts = FALSE)\nwhere(\"filter\")\n#> [[1]]\n#> <environment: package:dplyr>\n#> attr(,\"name\")\n#> [1] \"package:dplyr\"\n#> attr(,\"path\")\n#> [1] \"/home/runner/work/_temp/Library/dplyr\"\n#> \n#> [[2]]\n#> <environment: package:stats>\n#> attr(,\"name\")\n#> [1] \"package:stats\"\n#> attr(,\"path\")\n#> [1] \"/opt/R/4.4.1/lib/R/library/stats\"\ndetach(\"package:dplyr\")\nfget <- function(name, env = caller_env(), inherits = FALSE) {\n  # we need only function objects\n  f_value <- mget(name,\n    envir = env,\n    mode = \"function\",\n    inherits = FALSE, # since we have our custom argument\n    ifnotfound = list(NULL)\n  )\n\n  if (!is.null(f_value[[1]])) {\n    # success case\n    f_value[[1]]\n  } else {\n    if (inherits && !identical(env, empty_env())) {\n      # recursive case\n      env <- env_parent(env)\n      fget(name, env, inherits = TRUE)\n    } else {\n      # base case\n      stop(\"No function objects with matching name was found.\", call. = FALSE)\n    }\n  }\n}\nfget(\"mean\", inherits = FALSE)\n#> Error: No function objects with matching name was found.\n\nfget(\"mean\", inherits = TRUE)\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x55d2e20fa820>\n#> <environment: namespace:base>\n\nmean <- 5\nfget(\"mean\", inherits = FALSE)\n#> Error: No function objects with matching name was found.\n\nmean <- function() NULL\nfget(\"mean\", inherits = FALSE)\n#> function () \n#> NULL\nrm(\"mean\")"},{"path":"environments.html","id":"special-environments-exercises-7.4.5","chapter":"7 Environments","heading":"7.3 Special environments (Exercises 7.4.5)","text":"Q1. search_envs() different env_parents(global_env())?A1. search_envs() lists chain environments currently attached search path contains exported functions packages. search path always ends {base} package environment. search path also includes global environment.env_parents() lists parent environments empty environment. course, global environment included list.Q2. Draw diagram shows enclosing environments function:A2. don’t access graphics software used create diagrams book, linking diagram official solutions manual, also find detailed description figure:Q3. Write enhanced version str() provides information functions. Show function found environment defined .A3. write required function, can first re-purpose fget() function wrote return environment found enclosing environment:Let’s try :can now write new version str() wrapper around function. need foresee users might enter function name either symbol string.Let’s first try base::mean():variant present global environment:","code":"\nsearch_envs()\n#>  [[1]] $ <env: global>\n#>  [[2]] $ <env: package:rlang>\n#>  [[3]] $ <env: package:magrittr>\n#>  [[4]] $ <env: package:stats>\n#>  [[5]] $ <env: package:graphics>\n#>  [[6]] $ <env: package:grDevices>\n#>  [[7]] $ <env: package:utils>\n#>  [[8]] $ <env: package:datasets>\n#>  [[9]] $ <env: package:methods>\n#> [[10]] $ <env: Autoloads>\n#> [[11]] $ <env: package:base>\nenv_parents(global_env())\n#>  [[1]] $ <env: package:rlang>\n#>  [[2]] $ <env: package:magrittr>\n#>  [[3]] $ <env: package:stats>\n#>  [[4]] $ <env: package:graphics>\n#>  [[5]] $ <env: package:grDevices>\n#>  [[6]] $ <env: package:utils>\n#>  [[7]] $ <env: package:datasets>\n#>  [[8]] $ <env: package:methods>\n#>  [[9]] $ <env: Autoloads>\n#> [[10]] $ <env: package:base>\n#> [[11]] $ <env: empty>\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)\nfget2 <- function(name, env = caller_env()) {\n  # we need only function objects\n  f_value <- mget(name,\n    envir = env,\n    mode = \"function\",\n    inherits = FALSE,\n    ifnotfound = list(NULL)\n  )\n\n  if (!is.null(f_value[[1]])) {\n    # success case\n    list(\n      \"where\" = env,\n      \"enclosing\" = fn_env(f_value[[1]])\n    )\n  } else {\n    if (!identical(env, empty_env())) {\n      # recursive case\n      env <- env_parent(env)\n      fget2(name, env)\n    } else {\n      # base case\n      stop(\"No function objects with matching name was found.\", call. = FALSE)\n    }\n  }\n}\nfget2(\"mean\")\n#> $where\n#> <environment: base>\n#> \n#> $enclosing\n#> <environment: namespace:base>\n\nmean <- function() NULL\nfget2(\"mean\")\n#> $where\n#> <environment: R_GlobalEnv>\n#> \n#> $enclosing\n#> <environment: R_GlobalEnv>\nrm(\"mean\")\nstr_function <- function(.f) {\n  fget2(as_string(ensym(.f)))\n}\nstr_function(mean)\n#> $where\n#> <environment: base>\n#> \n#> $enclosing\n#> <environment: namespace:base>\n\nstr_function(\"mean\")\n#> $where\n#> <environment: base>\n#> \n#> $enclosing\n#> <environment: namespace:base>\nmean <- function() NULL\n\nstr_function(mean)\n#> $where\n#> <environment: R_GlobalEnv>\n#> \n#> $enclosing\n#> <environment: R_GlobalEnv>\n\nstr_function(\"mean\")\n#> $where\n#> <environment: R_GlobalEnv>\n#> \n#> $enclosing\n#> <environment: R_GlobalEnv>\n\nrm(\"mean\")"},{"path":"environments.html","id":"call-stacks-exercises-7.5.5","chapter":"7 Environments","heading":"7.4 Call stacks (Exercises 7.5.5)","text":"Q1. Write function lists variables defined environment called. return results ls().A1. function lists variables defined environment called:workhorse rlang::caller_env(), let’s also look definition:Let’s try :global environment:function environment:","code":"\n# let's first remove everything that exists in the global environment right now\n# to test with only newly defined objects\nrm(list = ls())\nrm(.Random.seed, envir = globalenv())\n\nls_env <- function(env = rlang::caller_env()) {\n  sort(rlang::env_names(env))\n}\nrlang::caller_env\n#> function (n = 1) \n#> {\n#>     parent.frame(n + 1)\n#> }\n#> <bytecode: 0x55d2e3bbf918>\n#> <environment: namespace:rlang>\nx <- \"a\"\ny <- 1\n\nls_env()\n#> [1] \"ls_env\" \"x\"      \"y\"\n\nls()\n#> [1] \"ls_env\" \"x\"      \"y\"\nfoo <- function() {\n  a <- \"x\"\n  b <- 2\n\n  print(ls_env())\n\n  print(ls())\n}\n\nfoo()\n#> [1] \"a\" \"b\"\n#> [1] \"a\" \"b\""},{"path":"environments.html","id":"session-information-5","chapter":"7 Environments","heading":"7.5 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  crayon        1.5.3   2024-06-20 [1] RSPM\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr         1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  highr         0.11    2024-05-26 [1] RSPM\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  lobstr        1.1.2   2022-06-22 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  png           0.1-8   2022-11-29 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang       * 1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tibble        3.2.1   2023-03-20 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"conditions.html","id":"conditions","chapter":"8 Conditions","heading":"8 Conditions","text":"Attaching needed libraries:","code":"\nlibrary(rlang, warn.conflicts = FALSE)\nlibrary(testthat, warn.conflicts = FALSE)"},{"path":"conditions.html","id":"signalling-conditions-exercises-8.2.4","chapter":"8 Conditions","heading":"8.1 Signalling conditions (Exercises 8.2.4)","text":"Q1. Write wrapper around file.remove() throws error file deleted exist.A1. Let’s first create wrapper function around file.remove() throws error file deleted exist.Let’s first create file can delete immediately.function fail files provided don’t exist:work expected file exists:Q2. appendLF argument message() ? related cat()?A2. mentioned docs message(), appendLF argument decides:messages given character string newline appended?TRUE (default value), final newline regarded part message:FALSE, messages concatenated:hand, cat() converts arguments character vectors concatenates single character vector default:order get message()-like default behavior outputs, can set sep = \"\\n\":","code":"\nfileRemove <- function(...) {\n  existing_files <- fs::file_exists(...)\n\n  if (!all(existing_files)) {\n    stop(\n      cat(\n        \"The following files to be deleted don't exist:\",\n        names(existing_files[!existing_files]),\n        sep = \"\\n\"\n      ),\n      call. = FALSE\n    )\n  }\n\n  file.remove(...)\n}\nfs::file_create(\"random.R\")\nfileRemove(c(\"random.R\", \"XYZ.csv\"))\n#> The following files to be deleted don't exist:\n#> XYZ.csv\n#> Error:\nfileRemove(\"random.R\")\n#> [1] TRUE\nfoo <- function(appendLF) {\n  message(\"Beetle\", appendLF = appendLF)\n  message(\"Juice\", appendLF = appendLF)\n}\n\nfoo(appendLF = TRUE)\n#> Beetle\n#> Juice\nfoo <- function(appendLF) {\n  message(\"Beetle\", appendLF = appendLF)\n  message(\"Juice\", appendLF = appendLF)\n}\n\nfoo(appendLF = FALSE)\n#> BeetleJuice\nfoo <- function() {\n  cat(\"Beetle\")\n  cat(\"Juice\")\n}\n\nfoo()\n#> BeetleJuice\nfoo <- function() {\n  cat(\"Beetle\", sep = \"\\n\")\n  cat(\"Juice\", sep = \"\\n\")\n}\n\nfoo()\n#> Beetle\n#> Juice"},{"path":"conditions.html","id":"handling-conditions-exercises-8.4.5","chapter":"8 Conditions","heading":"8.2 Handling conditions (Exercises 8.4.5)","text":"Q1. extra information condition generated abort() contain compared condition generated stop() .e. ’s difference two objects? Read help ?abort learn .A1. Compared base::stop(), rlang::abort() contains two additional pieces information:trace: traceback capturing sequence calls lead current functionparent: Information another condition used parent create chained condition.Q2. Predict results evaluating following codeA2. Correctly predicted 😉first three pieces code straightforward:last piece code challenging one illustrates tryCatch() works. docs:several handlers supplied single tryCatch first one considered recent second.Q3. Explain results running code:A3. surprising part output b last c.happens inner calling handler doesn’t handle message, bubbles outer calling handler.Q4. Read source code catch_cnd() explain works.A4. Let’s look source code catch_cnd():mentioned function docs:small wrapper around tryCatch() captures condition signalled evaluating argument.classes argument allows character vector condition classes catch, complex tidy evaluation generates necessary condition (; otherwise NULL).Q5. rewrite show_condition() use single handler?A5. source code rlang::catch_cond() gives us clue can .Conditions also class attribute, can use determine handler match condition.Let’s try new version examples used original version:","code":"\ncatch_cnd(stop(\"An error\"))\ncatch_cnd(abort(\"An error\"))\nlibrary(rlang)\n\nstopInfo <- catch_cnd(stop(\"An error\"))\nabortInfo <- catch_cnd(abort(\"An error\"))\n\nstr(stopInfo)\n#> List of 2\n#>  $ message: chr \"An error\"\n#>  $ call   : language force(expr)\n#>  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nstr(abortInfo)\n#> List of 5\n#>  $ message: chr \"An error\"\n#>  $ trace  :Classes 'rlang_trace', 'rlib_trace', 'tbl' and 'data.frame':  8 obs. of  6 variables:\n#>   ..$ call       :List of 8\n#>   .. ..$ : language catch_cnd(abort(\"An error\"))\n#>   .. ..$ : language eval_bare(rlang::expr(tryCatch(!!!handlers, {     force(expr) ...\n#>   .. ..$ : language tryCatch(condition = `<fn>`, {     force(expr) ...\n#>   .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)\n#>   .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#>   .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)\n#>   .. ..$ : language force(expr)\n#>   .. ..$ : language abort(\"An error\")\n#>   ..$ parent     : int [1:8] 0 1 1 3 4 5 1 0\n#>   ..$ visible    : logi [1:8] FALSE FALSE FALSE FALSE FALSE FALSE ...\n#>   ..$ namespace  : chr [1:8] \"rlang\" \"rlang\" \"base\" \"base\" ...\n#>   ..$ scope      : chr [1:8] \"::\" \"::\" \"::\" \"local\" ...\n#>   ..$ error_frame: logi [1:8] FALSE FALSE FALSE FALSE FALSE FALSE ...\n#>   ..- attr(*, \"version\")= int 2\n#>  $ parent : NULL\n#>  $ rlang  :List of 1\n#>   ..$ inherit: logi TRUE\n#>  $ call   : NULL\n#>  - attr(*, \"class\")= chr [1:3] \"rlang_error\" \"error\" \"condition\"\nshow_condition <- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\"))\nshow_condition(10)\nshow_condition(warning(\"?!\"))\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\nshow_condition <- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\"))\n#> [1] \"error\"\nshow_condition(10)\n#> NULL\nshow_condition(warning(\"?!\"))\n#> [1] \"warning\"\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n#> [1] \"message\"\nwithCallingHandlers(\n  message = function(cnd) message(\"b\"),\n  withCallingHandlers(\n    message = function(cnd) message(\"a\"),\n    message(\"c\")\n  )\n)\n#> b\n#> a\n#> b\n#> c\nrlang::catch_cnd\n#> function (expr, classes = \"condition\") \n#> {\n#>     stopifnot(is_character(classes))\n#>     handlers <- rep_named(classes, list(identity))\n#>     eval_bare(rlang::expr(tryCatch(!!!handlers, {\n#>         force(expr)\n#>         return(NULL)\n#>     })))\n#> }\n#> <bytecode: 0x5616a31f6a90>\n#> <environment: namespace:rlang>\ncatch_cnd(10)\n#> NULL\n\ncatch_cnd(abort(message = \"an error\", class = \"class1\"))\n#> <error/class1>\n#> Error:\n#> ! an error\n#> ---\n#> Backtrace:\n#> ▆\nshow_condition2 <- function(code) {\n  tryCatch(\n    condition = function(cnd) {\n      if (inherits(cnd, \"error\")) {\n        return(\"error\")\n      }\n      if (inherits(cnd, \"warning\")) {\n        return(\"warning\")\n      }\n      if (inherits(cnd, \"message\")) {\n        return(\"message\")\n      }\n    },\n    {\n      code\n      NULL\n    }\n  )\n}\nshow_condition2(stop(\"!\"))\n#> [1] \"error\"\nshow_condition2(10)\n#> NULL\nshow_condition2(warning(\"?!\"))\n#> [1] \"warning\"\nshow_condition2({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n#> [1] \"message\""},{"path":"conditions.html","id":"custom-conditions-exercises-8.5.4","chapter":"8 Conditions","heading":"8.3 Custom conditions (Exercises 8.5.4)","text":"Q1. Inside package, ’s occasionally useful check package installed using . Write function checks package installed (requireNamespace(\"pkg\", quietly = FALSE)) , throws custom condition includes package name metadata.A1. desired function:reference, also see source code following functions:rlang::is_installed()insight::check_if_installed()Q2. Inside package often need stop error something right. packages depend package might tempted check errors unit tests. help packages avoid relying error message part user interface rather API might change without notice?A2. example, let’s say another package developer wanted use check_if_pkg_installed() function just wrote.developer using package can write unit test like :dissuade developers rely error messages check errors, can instead provide custom condition, can used unit testing instead:unit test :test wouldn’t fail even decided change exact message.","code":"\nabort_missing_package <- function(pkg) {\n  msg <- glue::glue(\"Problem loading `{pkg}` package, which is missing and must be installed.\")\n\n  abort(\"error_missing_package\",\n    message = msg,\n    pkg = pkg\n  )\n}\n\ncheck_if_pkg_installed <- function(pkg) {\n  if (!requireNamespace(pkg, quietly = TRUE)) {\n    abort_missing_package(pkg)\n  }\n\n  TRUE\n}\n\ncheck_if_pkg_installed(\"xyz123\")\n#> Error in `abort_missing_package()`:\n#> ! Problem loading `xyz123` package, which is missing and must be installed.\ncheck_if_pkg_installed(\"dplyr\")\n#> [1] TRUE\nexpect_error(\n  check_if_pkg_installed(\"xyz123\"),\n  \"Problem loading `xyz123` package, which is missing and must be installed.\"\n)\ne <- catch_cnd(check_if_pkg_installed(\"xyz123\"))\n\ninherits(e, \"error_missing_package\")\n#> [1] TRUE\nexpect_s3_class(e, \"error_missing_package\")"},{"path":"conditions.html","id":"applications-exercises-8.6.6","chapter":"8 Conditions","heading":"8.4 Applications (Exercises 8.6.6)","text":"Q1. Create suppressConditions() works like suppressMessages() suppressWarnings() suppresses everything. Think carefully handle errors.A1. create desired suppressConditions(), just need create equivalent suppressWarnings() suppressMessages() errors. suppress error message, can handle errors within tryCatch() return error object invisibly:Let’s try see works expected:condition messages now suppressed, note assign error object variable, can still extract useful information debugging:Q2. Compare following two implementations message2error(). main advantage withCallingHandlers() scenario? (Hint: look carefully traceback.)A2. withCallingHandlers(), condition handler called signaling function , , therefore, provides detailed call stack.tryCatch(), signalling function terminates condition raised, doesn’t provide detailed call stack.Q3. modify catch_cnds() definition wanted recreate original intermingling warnings messages?A3. Actually, won’t modify anything function defined chapter, since supports box.nothing additional here5! 😅Q4. catching interrupts dangerous? Run code find .A4. function catches interrupt way stop bottles_of_beer(), way usually stop using interrupt!RStudio IDE, can snap loop terminating R session.shows catching interrupt dangerous can result poor user experience.","code":"\nsuppressErrors <- function(expr) {\n  tryCatch(\n    error = function(cnd) invisible(cnd),\n    expr\n  )\n}\n\nsuppressConditions <- function(expr) {\n  suppressErrors(suppressWarnings(suppressMessages(expr)))\n}\nsuppressConditions(1)\n#> [1] 1\n\nsuppressConditions({\n  message(\"I'm messaging you\")\n  warning(\"I'm warning you\")\n})\n\nsuppressConditions({\n  stop(\"I'm stopping this\")\n})\ne <- suppressConditions({\n  stop(\"I'm stopping this\")\n})\n\ne\n#> <simpleError in withCallingHandlers(expr, message = function(c) if (inherits(c,     classes)) tryInvokeRestart(\"muffleMessage\")): I'm stopping this>\nmessage2error <- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\nmessage2error <- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\nmessage2error1 <- function(code) {\n  withCallingHandlers(code, message = function(e) stop(\"error\"))\n}\n\nmessage2error1({\n  1\n  message(\"hidden error\")\n  NULL\n})\n#> Error in (function (e) : error\n\ntraceback()\n#> 9: stop(\"error\") at #2\n#> 8: (function (e)\n#>    stop(\"error\"))(list(message = \"hidden error\\n\",\n#>      call = message(\"hidden error\")))\n#> 7: signalCondition(cond)\n#> 6: doWithOneRestart(return(expr), restart)\n#> 5: withOneRestart(expr, restarts[[1L]])\n#> 4: withRestarts({\n#>        signalCondition(cond)\n#>        defaultHandler(cond)\n#>    }, muffleMessage = function() NULL)\n#> 3: message(\"hidden error\") at #1\n#> 2: withCallingHandlers(code,\n#>      message = function(e) stop(\"error\")) at #2\n#> 1: message2error1({\n#>        1\n#>        message(\"hidden error\")\n#>        NULL\n#>    })\nmessage2error2 <- function(code) {\n  tryCatch(code, message = function(e) (stop(\"error\")))\n}\n\nmessage2error2({\n  1\n  stop(\"hidden error\")\n  NULL\n})\n#> Error in value[[3L]](cond) : error\n\ntraceback()\n#> 6: stop(\"error\") at #2\n#> 5: value[[3L]](cond)\n#> 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#> 3: tryCatchList(expr, classes, parentenv, handlers)\n#> 2: tryCatch(code, message = function(e) (stop(\"error\"))) at #2\n#> 1: message2error2({\n#>        1\n#>        message(\"hidden error\")\n#>        NULL\n#>    })\ncatch_cnds <- function(expr) {\n  conds <- list()\n  add_cond <- function(cnd) {\n    conds <<- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n\n  withCallingHandlers(\n    message = add_cond,\n    warning = add_cond,\n    expr\n  )\n\n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  inform(\"c\")\n})\n#> [[1]]\n#> <message/rlang_message>\n#> Message:\n#> a\n#> \n#> [[2]]\n#> <warning/rlang_warning>\n#> Warning:\n#> b\n#> \n#> [[3]]\n#> <message/rlang_message>\n#> Message:\n#> c\nbottles_of_beer <- function(i = 99) {\n  message(\n    \"There are \", i, \" bottles of beer on the wall, \",\n    i, \" bottles of beer.\"\n  )\n  while (i > 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i <<- i - 1\n        if (i > 0) {\n          message(\n            \"Take one down, pass it around, \", i,\n            \" bottle\", if (i > 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \",\n    \"no more bottles of beer.\"\n  )\n}\nbottles_of_beer()\n#> There are 99 bottles of beer on the wall, 99 bottles of beer.\n#> Take one down, pass it around, 98 bottles of beer on the wall.\n#> Take one down, pass it around, 97 bottles of beer on the wall.\n#> Take one down, pass it around, 96 bottles of beer on the wall.\n#> Take one down, pass it around, 95 bottles of beer on the wall.\n#> Take one down, pass it around, 94 bottles of beer on the wall.\n#> Take one down, pass it around, 93 bottles of beer on the wall.\n#> Take one down, pass it around, 92 bottles of beer on the wall.\n#> Take one down, pass it around, 91 bottles of beer on the wall.\n#> ..."},{"path":"conditions.html","id":"session-information-6","chapter":"8 Conditions","heading":"8.5 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  brio          1.1.5   2024-04-24 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  desc          1.4.3   2023-12-10 [1] RSPM\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr         1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  pkgload       1.4.0   2024-06-28 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang       * 1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  rprojroot     2.0.4   2023-11-05 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  testthat    * 3.2.1.1 2024-04-14 [1] RSPM\n#>  tibble        3.2.1   2023-03-20 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"functionals.html","id":"functionals","chapter":"9 Functionals","heading":"9 Functionals","text":"Attaching needed libraries:","code":"\nlibrary(purrr, warn.conflicts = FALSE)"},{"path":"functionals.html","id":"my-first-functional-map-exercises-9.2.6","chapter":"9 Functionals","heading":"9.1 My first functional: map() (Exercises 9.2.6)","text":"Q1. Use as_mapper() explore purrr generates anonymous functions integer, character, list helpers. helper allows extract attributes? Read documentation find .A1. Let’s handle two parts question separately.as_mapper() purrr-generated anonymous functions:Looking experimentation map() as_mapper(), can see , depending type input, as_mapper() creates extractor function using pluck().can extract attributes using purrr::attr_getter():Q2. map(1:3, ~ runif(2)) useful pattern generating random numbers, map(1:3, runif(2)) . ? Can explain returns result ?A2. shown as_mapper() outputs , second call appropriate generating random numbers translates pluck() function indices plucking taken randomly generated numbers, valid accessors get NULLs return.Q3. Use appropriate map() function :A3. Using appropriate map() function :Compute standard deviation every column numeric data frame:Compute standard deviation every numeric column mixed data frame:Compute number levels every factor data frame:Q4. following code simulates performance t-test non-normal data. Extract p-value test, visualise.A4.Extract p-value test:Visualise extracted p-values:Q5. following code uses map nested inside another map apply function every element nested list. fail, need make work?A5. function fails call effectively evaluates following:triple() one parameter (x), execution fails.fixed version:Q6. Use map() fit linear models mtcars dataset using formulas stored list:A6. Fitting linear models mtcars dataset using provided formulas:Q7. Fit model mpg ~ disp bootstrap replicates mtcars list , extract \\(R^2\\) model fit (Hint: can compute \\(R^2\\) summary().)A7. can done using map_dbl():","code":"\n# mapping by position -----------------------\n\nx <- list(1, list(2, 3, list(1, 2)))\n\nmap(x, 1)\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\nas_mapper(1)\n#> function (x, ...) \n#> pluck_raw(x, list(1), .default = NULL)\n#> <environment: 0x55f153bbfec8>\n\nmap(x, list(2, 1))\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> [1] 3\nas_mapper(list(2, 1))\n#> function (x, ...) \n#> pluck_raw(x, list(2, 1), .default = NULL)\n#> <environment: 0x55f153c8c2c0>\n\n# mapping by name -----------------------\n\ny <- list(\n  list(m = \"a\", list(1, m = \"mo\")),\n  list(n = \"b\", list(2, n = \"no\"))\n)\n\nmap(y, \"m\")\n#> [[1]]\n#> [1] \"a\"\n#> \n#> [[2]]\n#> NULL\nas_mapper(\"m\")\n#> function (x, ...) \n#> pluck_raw(x, list(\"m\"), .default = NULL)\n#> <environment: 0x55f153dd0fa0>\n\n# mixing position and name\nmap(y, list(2, \"m\"))\n#> [[1]]\n#> [1] \"mo\"\n#> \n#> [[2]]\n#> NULL\nas_mapper(list(2, \"m\"))\n#> function (x, ...) \n#> pluck_raw(x, list(2, \"m\"), .default = NULL)\n#> <environment: 0x55f153ea5a00>\n\n# compact functions ----------------------------\n\nmap(y, ~ length(.x))\n#> [[1]]\n#> [1] 2\n#> \n#> [[2]]\n#> [1] 2\nas_mapper(~ length(.x))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> length(.x)\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\npluck(Titanic, attr_getter(\"class\"))\n#> [1] \"table\"\nmap(1:3, ~ runif(2))\n#> [[1]]\n#> [1] 0.2180892 0.9876342\n#> \n#> [[2]]\n#> [1] 0.3484619 0.3810470\n#> \n#> [[3]]\n#> [1] 0.02098596 0.74972687\nas_mapper(~ runif(2))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> runif(2)\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\n\nmap(1:3, runif(2))\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n#> \n#> [[3]]\n#> [1] 3\nas_mapper(runif(2))\n#> function (x, ...) \n#> pluck_raw(x, list(0.597890264587477, 0.587997315218672), .default = NULL)\n#> <environment: 0x55f154f0e4b0>a) Compute the standard deviation of every column in a numeric data frame.\n\na) Compute the standard deviation of every numeric column in a mixed data frame. (Hint: you'll need to do it in two steps.)\n\na) Compute the number of levels for every factor in a data frame.\nmap_dbl(mtcars, sd)\n#>         mpg         cyl        disp          hp        drat \n#>   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787 \n#>          wt        qsec          vs          am        gear \n#>   0.9784574   1.7869432   0.5040161   0.4989909   0.7378041 \n#>        carb \n#>   1.6152000\nkeep(iris, is.numeric) %>%\n  map_dbl(sd)\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#>    0.8280661    0.4358663    1.7652982    0.7622377\nmodify_if(dplyr::starwars, is.character, as.factor) %>%\n  keep(is.factor) %>%\n  map_int(~ length(levels(.)))\n#>       name hair_color skin_color  eye_color        sex \n#>         87         11         31         15          4 \n#>     gender  homeworld    species \n#>          2         48         37\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\n\n(p <- map_dbl(trials, \"p.value\"))\n#>   [1] 0.81695628 0.53177360 0.94750819 0.41026769 0.34655294\n#>   [6] 0.05300287 0.56479901 0.85936864 0.77517391 0.64321161\n#>  [11] 0.84462914 0.54144946 0.63070476 0.20325827 0.39824435\n#>  [16] 0.67052432 0.39932663 0.44437632 0.51645941 0.96578745\n#>  [21] 0.70219557 0.69931716 0.23946786 0.55100566 0.76028958\n#>  [26] 0.38105366 0.64544126 0.15379307 0.86945196 0.09965658\n#>  [31] 0.96425489 0.54239108 0.38985789 0.59019282 0.96247907\n#>  [36] 0.54997487 0.66111391 0.30961551 0.10897334 0.55049635\n#>  [41] 0.93882405 0.14836866 0.44307287 0.61583610 0.37284284\n#>  [46] 0.38559622 0.42935767 0.26059293 0.07831619 0.93768396\n#>  [51] 0.48459268 0.73571291 0.30288560 0.68521609 0.06374636\n#>  [56] 0.11007808 0.98758443 0.17831882 0.94471538 0.19711729\n#>  [61] 0.02094185 0.12370745 0.23247837 0.93842382 0.19160550\n#>  [66] 0.49005550 0.98146240 0.09034183 0.94912080 0.55857523\n#>  [71] 0.24692070 0.63658206 0.14290966 0.10309770 0.89516449\n#>  [76] 0.25660092 0.16943034 0.41199780 0.82721280 0.74017418\n#>  [81] 0.43724631 0.55944024 0.93615100 0.68788872 0.01416627\n#>  [86] 0.60120497 0.54125910 0.91581929 0.78949327 0.57887371\n#>  [91] 0.83217542 0.90108906 0.97474727 0.99129282 0.54436155\n#>  [96] 0.74159859 0.06534957 0.10834529 0.19737786 0.93750342\nplot(p)\n\nhist(p)\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error in `map()`:\n#> ℹ In index: 1.\n#> Caused by error in `.f()`:\n#> ! unused argument (function (.x, .f, ..., .progress = FALSE) \n#> {\n#>     map_(\"list\", .x, .f, ..., .progress = .progress)\n#> })\nmap(.x = x, .f = ~ triple(x = .x, map))\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, .f = ~ map(.x, ~ triple(.x)))\n#> [[1]]\n#> [[1]][[1]]\n#> [1] 3\n#> \n#> [[1]][[2]]\n#> [1]  9 27\n#> \n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1]  9 18\n#> \n#> [[2]][[2]]\n#> [1] 21\n#> \n#> [[2]][[3]]\n#> [1] 12 21 18\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\n\nmap(formulas, ~ lm(formula = ., data = mtcars))\n#> [[1]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)         disp  \n#>    29.59985     -0.04122  \n#> \n#> \n#> [[2]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)    I(1/disp)  \n#>       10.75      1557.67  \n#> \n#> \n#> [[3]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)         disp           wt  \n#>    34.96055     -0.01772     -3.35083  \n#> \n#> \n#> [[4]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)    I(1/disp)           wt  \n#>      19.024     1142.560       -1.798\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))\n\nbootstraps %>%\n  map(~ lm(mpg ~ disp, data = .x)) %>%\n  map(summary) %>%\n  map_dbl(\"r.squared\")\n#>  [1] 0.7864562 0.8110818 0.7956331 0.7632399 0.7967824\n#>  [6] 0.7364226 0.7203027 0.6653252 0.7732780 0.6753329"},{"path":"functionals.html","id":"map-variants-exercises-9.4.6","chapter":"9 Functionals","heading":"9.2 Map variants (Exercises 9.4.6)","text":"Q1. Explain results modify(mtcars, 1).A1. modify() returns object type input. Since input data frame certain dimensions .f = 1 translates plucking first element column, returns data frame dimensions plucked element recycled across rows.Q2. Rewrite following code use iwalk() instead walk2(). advantages disadvantages?A2. Let’s first rewrite provided code using iwalk():advantage using iwalk() need now deal single variable (cyls) instead two (cyls paths).disadvantage code difficult reason :\nwalk2(), ’s explicit .x (= cyls) .y (= paths) correspond , iwalk() (.e., .x = cyls .y = names(cyls)) .y argument “invisible”.Q3. Explain following code transforms data frame using functions stored list.Compare contrast map2() approach map() approach:A3. map2() supplies functions stored trans anonymous functions via placeholder f, names columns specified mtcars[nm] supplied var argument anonymous function. Note function iterating indices vectors transformations column names.map() approach, function iterating indices vectors column names.latter approach can’t afford passing arguments placeholders anonymous function.Q4. write.csv() return, .e. happens use map2() instead walk2()?A4. use map2(), work, print NULLs console every list element.","code":"\nhead(modify(mtcars, 1))\n#>   mpg cyl disp  hp drat   wt  qsec vs am gear carb\n#> 1  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 2  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 3  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 5  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 6  21   6  160 110  3.9 2.62 16.46  0  1    4    4\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\ncyls <- split(mtcars, mtcars$cyl)\nnames(cyls) <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\niwalk(cyls, ~ write.csv(.x, .y))\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))\nwithr::with_tempdir(\n  code = {\n    ls <- split(mtcars, mtcars$cyl)\n    nm <- names(ls)\n    map2(ls, nm, write.csv)\n  }\n)\n#> $`4`\n#> NULL\n#> \n#> $`6`\n#> NULL\n#> \n#> $`8`\n#> NULL"},{"path":"functionals.html","id":"predicate-functionals-exercises-9.6.3","chapter":"9 Functionals","heading":"9.3 Predicate functionals (Exercises 9.6.3)","text":"Q1. isn’t .na() predicate function? base R function closest predicate version .na()?A1. mentioned docs:predicate function returns single TRUE FALSE..na() function return logical scalar, instead returns vector thus isn’t predicate function.closest equivalent predicate function base-R anyNA() function.Q2. simple_reduce() problem x length 0 length 1. Describe source problem might go fixing .A2. supplied function struggles inputs length 0 1 function tries subscript --bound values.problem can solved adding init argument, supplies default initial value:Let’s try :Depending function, can provide different init argument:Q3. Implement span() function Haskell: given list x predicate function f, span(x, f) returns location longest sequential run elements predicate true. (Hint: might find rle() helpful.)A3. Implementation span():Testing :Testing twice:Q4. Implement arg_max(). take function vector inputs, return elements input function returns highest value. example, arg_max(-10:5, function(x) x ^ 2) return -10. arg_max(-5:5, function(x) x ^ 2) return c(-5, 5). Also implement matching arg_min() function.A4. implementations specified functions:Implementing arg_max()Implementing arg_min()Q5. function scales vector falls range [0, 1]. apply every column data frame? apply every numeric column data frame?A5. use purrr package apply function. Key thing keep mind data frame list atomic vectors equal length.Applying function every column data frame: use anscombe example since numeric columns.Applying function every numeric column data frame: use iris example since columns numeric type.","code":"\n# contrast the following behavior of predicate functions\nis.character(c(\"x\", 2))\n#> [1] TRUE\nis.null(c(3, NULL))\n#> [1] FALSE\n\n# with this behavior\nis.na(c(NA, 1))\n#> [1]  TRUE FALSE\nanyNA(c(NA, 1))\n#> [1] TRUE\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nsimple_reduce(numeric(), sum)\n#> Error in x[[1]]: subscript out of bounds\nsimple_reduce(1, sum)\n#> Error in x[[i]]: subscript out of bounds\nsimple_reduce(1:3, sum)\n#> [1] 6\nsimple_reduce2 <- function(x, f, init = 0) {\n  # initializer will become the first value\n  if (length(x) == 0L) {\n    return(init)\n  }\n\n  if (length(x) == 1L) {\n    return(x[[1L]])\n  }\n\n  out <- x[[1]]\n\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n\n  out\n}\nsimple_reduce2(numeric(), sum)\n#> [1] 0\nsimple_reduce2(1, sum)\n#> [1] 1\nsimple_reduce2(1:3, sum)\n#> [1] 6\nsimple_reduce2(numeric(), `*`, init = 1)\n#> [1] 1\nsimple_reduce2(1, `*`, init = 1)\n#> [1] 1\nsimple_reduce2(1:3, `*`, init = 1)\n#> [1] 6\nspan <- function(x, f) {\n  running_lengths <- purrr::map_lgl(x, ~ f(.x)) %>% rle()\n\n  df <- dplyr::tibble(\n    \"lengths\" = running_lengths$lengths,\n    \"values\" = running_lengths$values\n  ) %>%\n    dplyr::mutate(rowid = dplyr::row_number()) %>%\n    dplyr::filter(values)\n\n  # no sequence where condition is `TRUE`\n  if (nrow(df) == 0L) {\n    return(integer())\n  }\n\n  # only single sequence where condition is `TRUE`\n  if (nrow(df) == 1L) {\n    return((df$rowid):(df$lengths - 1 + df$rowid))\n  }\n\n  # multiple sequences where condition is `TRUE`; select max one\n  if (nrow(df) > 1L) {\n    df <- dplyr::filter(df, lengths == max(lengths))\n    return((df$rowid):(df$lengths - 1 + df$rowid))\n  }\n}\nspan(c(0, 0, 0, 0, 0), is.na)\n#> integer(0)\nspan(c(NA, 0, NA, NA, NA), is.na)\n#> [1] 3 4 5\nspan(c(NA, 0, 0, 0, 0), is.na)\n#> [1] 1\nspan(c(NA, NA, 0, 0, 0), is.na)\n#> [1] 1 2\nspan(c(3, 1, 2, 4, 5, 6), function(x) x > 3)\n#> [1] 2 3 4\nspan(c(3, 1, 2, 4, 5, 6), function(x) x > 9)\n#> integer(0)\nspan(c(3, 1, 2, 4, 5, 6), function(x) x == 3)\n#> [1] 1\nspan(c(3, 1, 2, 4, 5, 6), function(x) x %in% c(2, 4))\n#> [1] 2 3\narg_max <- function(.x, .f) {\n  df <- dplyr::tibble(\n    original = .x,\n    transformed = purrr::map_dbl(.x, .f)\n  )\n\n  dplyr::filter(df, transformed == max(transformed))[[\"original\"]]\n}\n\narg_max(-10:5, function(x) x^2)\n#> [1] -10\narg_max(-5:5, function(x) x^2)\n#> [1] -5  5\narg_min <- function(.x, .f) {\n  df <- dplyr::tibble(\n    original = .x,\n    transformed = purrr::map_dbl(.x, .f)\n  )\n\n  dplyr::filter(df, transformed == min(transformed))[[\"original\"]]\n}\n\narg_min(-10:5, function(x) x^2)\n#> [1] 0\narg_min(-5:5, function(x) x^2)\n#> [1] 0\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\npurrr::map_df(head(anscombe), .f = scale01)\n#> # A tibble: 6 × 8\n#>      x1    x2    x3    x4    y1     y2     y3    y4\n#>   <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>  <dbl> <dbl>\n#> 1 0.333 0.333 0.333   NaN 0.362 0.897  0.116  0.266\n#> 2 0     0     0       NaN 0     0.0345 0      0    \n#> 3 0.833 0.833 0.833   NaN 0.209 0.552  1      0.633\n#> 4 0.167 0.167 0.167   NaN 0.618 0.578  0.0570 1    \n#> 5 0.5   0.5   0.5     NaN 0.458 1      0.174  0.880\n#> 6 1     1     1       NaN 1     0      0.347  0.416\npurrr::modify_if(head(iris), .p = is.numeric, .f = scale01)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1        0.625   0.5555556         0.25           0  setosa\n#> 2        0.375   0.0000000         0.25           0  setosa\n#> 3        0.125   0.2222222         0.00           0  setosa\n#> 4        0.000   0.1111111         0.50           0  setosa\n#> 5        0.500   0.6666667         0.25           0  setosa\n#> 6        1.000   1.0000000         1.00           1  setosa"},{"path":"functionals.html","id":"base-functionals-exercises-9.7.3","chapter":"9 Functionals","heading":"9.4 Base functionals (Exercises 9.7.3)","text":"Q1. apply() arrange output? Read documentation perform experiments.A1. Let’s prepare array apply function different margins:can seen, apply() returns outputs organised first margins operated , results.Q2. eapply() rapply() ? purrr equivalents?A2. Let’s consider one--one.eapply()mentioned documentation:eapply() applies FUN named values environment returns results list.example:purrr doesn’t function iterate environments.rapply()rapply() recursive version lapply flexibility result structured (= “..”).example:purrr something similar modify_tree().Q3. Challenge: read fixed point algorithm. Complete exercises using R.A3. mentioned suggested reading material:number \\(x\\) called fixed point function \\(f\\) \\(x\\) satisfies equation \\(f(x) = x\\). functions \\(f\\) can locate fixed point beginning initial guess applying \\(f\\) repeatedly, \\(f(x), f(f(x)), f(f(f(x))), ...\\) value change much. Using idea, can devise procedure fixed-point takes inputs function initial guess produces approximation fixed point function.Let’s first implement fixed-point algorithm:Let’s check works expected:solve one exercise reading material. Rest beyond scope solution manual.Show golden ratio \\(\\phi\\) fixed point transformation \\(x \\mapsto 1 + 1/x\\), use fact compute \\(\\phi\\) means fixed-point procedure.","code":"\n(m <- as.array(table(mtcars$cyl, mtcars$am, mtcars$vs)))\n#> , ,  = 0\n#> \n#>    \n#>     auto manual\n#>   4    0      1\n#>   6    0      3\n#>   8   12      2\n#> \n#> , ,  = 1\n#> \n#>    \n#>     auto manual\n#>   4    3      7\n#>   6    4      0\n#>   8    0      0\n\n# rows\napply(m, 1, function(x) x^2)\n#>       \n#>         4  6   8\n#>   [1,]  0  0 144\n#>   [2,]  1  9   4\n#>   [3,]  9 16   0\n#>   [4,] 49  0   0\n\n# columns\napply(m, 2, function(x) x^2)\n#>       \n#>        auto manual\n#>   [1,]    0      1\n#>   [2,]    0      9\n#>   [3,]  144      4\n#>   [4,]    9     49\n#>   [5,]   16      0\n#>   [6,]    0      0\n\n# rows and columns\napply(m, c(1, 2), function(x) x^2)\n#> , ,  = auto\n#> \n#>    \n#>     4  6   8\n#>   0 0  0 144\n#>   1 9 16   0\n#> \n#> , ,  = manual\n#> \n#>    \n#>      4 6 8\n#>   0  1 9 4\n#>   1 49 0 0\nlibrary(rlang)\n#> \n#> Attaching package: 'rlang'\n#> The following objects are masked from 'package:purrr':\n#> \n#>     %@%, flatten, flatten_chr, flatten_dbl,\n#>     flatten_int, flatten_lgl, flatten_raw, invoke,\n#>     splice\n#> The following object is masked from 'package:magrittr':\n#> \n#>     set_names\n\ne <- env(\"x\" = 1, \"y\" = 2)\nrlang::env_print(e)\n#> <environment: 0x55f15497c0f0>\n#> Parent: <environment: global>\n#> Bindings:\n#> • x: <dbl>\n#> • y: <dbl>\n\neapply(e, as.character)\n#> $x\n#> [1] \"1\"\n#> \n#> $y\n#> [1] \"2\"\nX <- list(list(a = TRUE, b = list(c = c(4L, 3.2))), d = 9.0)\n\nrapply(X, as.character, classes = \"numeric\", how = \"replace\")\n#> [[1]]\n#> [[1]]$a\n#> [1] TRUE\n#> \n#> [[1]]$b\n#> [[1]]$b$c\n#> [1] \"4\"   \"3.2\"\n#> \n#> \n#> \n#> $d\n#> [1] \"9\"\nX <- list(list(a = TRUE, b = list(c = c(4L, 3.2))), d = 9.0)\n\npurrr::modify_tree(X, leaf = length)\n#> [[1]]\n#> [[1]]$a\n#> [1] 1\n#> \n#> [[1]]$b\n#> [[1]]$b$c\n#> [1] 2\n#> \n#> \n#> \n#> $d\n#> [1] 1\nclose_enough <- function(x1, x2, tolerance = 0.001) {\n  if (abs(x1 - x2) < tolerance) {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n\nfind_fixed_point <- function(.f, .guess, tolerance = 0.001) {\n  .next <- .f(.guess)\n  is_close_enough <- close_enough(.next, .guess, tol = tolerance)\n\n  if (is_close_enough) {\n    return(.next)\n  } else {\n    find_fixed_point(.f, .next, tolerance)\n  }\n}\nfind_fixed_point(cos, 1.0)\n#> [1] 0.7387603\n\n# cos(x) = x\ncos(find_fixed_point(cos, 1.0))\n#> [1] 0.7393039\ngolden_ratio_f <- function(x) 1 + (1 / x)\n\nfind_fixed_point(golden_ratio_f, 1.0)\n#> [1] 1.618182"},{"path":"functionals.html","id":"session-information-7","chapter":"9 Functionals","heading":"9.5 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr         1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  highr         0.11    2024-05-26 [1] RSPM\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  purrr       * 1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang       * 1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tibble        3.2.1   2023-03-20 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"function-factories.html","id":"function-factories","chapter":"10 Function factories","heading":"10 Function factories","text":"Attaching needed libraries:","code":"\nlibrary(rlang, warn.conflicts = FALSE)\nlibrary(ggplot2, warn.conflicts = FALSE)"},{"path":"function-factories.html","id":"factory-fundamentals-exercises-10.2.6","chapter":"10 Function factories","heading":"10.1 Factory fundamentals (Exercises 10.2.6)","text":"Q1. definition force() simple:better force(x) instead just x?A1. Due lazy evaluation, argument function won’t evaluated value needed. sometimes may want eager evaluation, using force() makes intent clearer.Q2. Base R contains two function factories, approxfun() ecdf(). Read documentation experiment figure functions return.A2. two function factories-approxfun()function factory returns function performing linear (constant) interpolation.ecdf()function factory computes empirical cumulative distribution function.Q3. Create function pick() takes index, , argument returns function argument x subsets x .A3. write desired function, just need make sure argument eagerly evaluated.Testing specified test cases:Q4. Create function creates functions compute ithcentral moment numeric vector. can test running following code:A4. following function satisfied specified requirements:Testing specified test cases:Q5. happens don’t use closure? Make predictions, verify code .A5. case closures used context, counts stored global variable, can modified processes even deleted.Q6. happens use <- instead <<-? Make predictions, verify code .A6. case, function always return 1.","code":"\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x55e140016e10>\n#> <environment: namespace:base>\nx <- 1:10\ny <- rnorm(10)\nf <- approxfun(x, y)\nf\n#> function (v) \n#> .approxfun(x, y, v, method, yleft, yright, f, na.rm)\n#> <bytecode: 0x55e144bfdde0>\n#> <environment: 0x55e144c012e0>\nf(x)\n#>  [1] -0.7786629 -0.3894764 -2.0337983 -0.9823731  0.2478901\n#>  [6] -2.1038646 -0.3814180  2.0749198  1.0271384  0.4730142\ncurve(f(x), 0, 11)\nx <- rnorm(12)\nf <- ecdf(x)\nf\n#> Empirical CDF \n#> Call: ecdf(x)\n#>  x[1:12] = -1.8793, -1.3221, -1.2392,  ..., 1.1604, 1.7956\nf(seq(-2, 2, by = 0.1))\n#>  [1] 0.00000000 0.00000000 0.08333333 0.08333333 0.08333333\n#>  [6] 0.08333333 0.08333333 0.16666667 0.25000000 0.25000000\n#> [11] 0.33333333 0.33333333 0.33333333 0.41666667 0.41666667\n#> [16] 0.41666667 0.41666667 0.50000000 0.58333333 0.58333333\n#> [21] 0.66666667 0.75000000 0.75000000 0.75000000 0.75000000\n#> [26] 0.75000000 0.75000000 0.75000000 0.75000000 0.83333333\n#> [31] 0.83333333 0.83333333 0.91666667 0.91666667 0.91666667\n#> [36] 0.91666667 0.91666667 0.91666667 1.00000000 1.00000000\n#> [41] 1.00000000\npick(1)(x)\n# should be equivalent to\nx[[1]]\n\nlapply(mtcars, pick(5))\n# should be equivalent to\nlapply(mtcars, function(x) x[[5]])\npick <- function(i) {\n  force(i)\n  function(x) x[[i]]\n}\nx <- list(\"a\", \"b\", \"c\")\nidentical(x[[1]], pick(1)(x))\n#> [1] TRUE\n\nidentical(\n  lapply(mtcars, pick(5)),\n  lapply(mtcars, function(x) x[[5]])\n)\n#> [1] TRUE\nm1 <- moment(1)\nm2 <- moment(2)\nx <- runif(100)\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\nmoment <- function(k) {\n  force(k)\n\n  function(x) (sum((x - mean(x))^k)) / length(x)\n}\nm1 <- moment(1)\nm2 <- moment(2)\nx <- runif(100)\n\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\ni <- 0\nnew_counter2 <- function() {\n  i <<- i + 1\n  i\n}\nnew_counter2()\n#> [1] 1\n\nnew_counter2()\n#> [1] 2\n\nnew_counter2()\n#> [1] 3\n\ni <- 20\nnew_counter2()\n#> [1] 21\nnew_counter3 <- function() {\n  i <- 0\n  function() {\n    i <- i + 1\n    i\n  }\n}\nnew_counter3()\n#> function () \n#> {\n#>     i <- i + 1\n#>     i\n#> }\n#> <environment: 0x55e144a77158>\n\nnew_counter3()\n#> function () \n#> {\n#>     i <- i + 1\n#>     i\n#> }\n#> <bytecode: 0x55e144bcfa50>\n#> <environment: 0x55e144ab5de0>"},{"path":"function-factories.html","id":"graphical-factories-exercises-10.3.4","chapter":"10 Function factories","heading":"10.2 Graphical factories (Exercises 10.3.4)","text":"Q1. Compare contrast ggplot2::label_bquote() scales::number_format().A1. compare contrast, let’s first look source code functions:ggplot2::label_bquote()scales::number_format()functions return formatting functions used style facets labels labels desired format ggplot2 plots.example, using plotmath expression facet label:display axes labels desired format:ggplot2::label_bquote() adds additional class returned function.scales::number_format() function simple pass-method forces evaluation parameters passes underlying scales::number() function.","code":"\nggplot2::label_bquote\n#> function (rows = NULL, cols = NULL, default) \n#> {\n#>     cols_quoted <- substitute(cols)\n#>     rows_quoted <- substitute(rows)\n#>     call_env <- env_parent()\n#>     fun <- function(labels) {\n#>         quoted <- resolve_labeller(rows_quoted, cols_quoted, \n#>             labels)\n#>         if (is.null(quoted)) {\n#>             return(label_value(labels))\n#>         }\n#>         evaluate <- function(...) {\n#>             params <- list(...)\n#>             params <- as_environment(params, call_env)\n#>             eval(substitute(bquote(expr, params), list(expr = quoted)))\n#>         }\n#>         list(inject(mapply(evaluate, !!!labels, SIMPLIFY = FALSE)))\n#>     }\n#>     structure(fun, class = \"labeller\")\n#> }\n#> <bytecode: 0x55e144e95298>\n#> <environment: namespace:ggplot2>\nscales::number_format\n#> function (accuracy = NULL, scale = 1, prefix = \"\", suffix = \"\", \n#>     big.mark = \" \", decimal.mark = \".\", style_positive = c(\"none\", \n#>         \"plus\", \"space\"), style_negative = c(\"hyphen\", \"minus\", \n#>         \"parens\"), scale_cut = NULL, trim = TRUE, ...) \n#> {\n#>     force_all(accuracy, scale, prefix, suffix, big.mark, decimal.mark, \n#>         style_positive, style_negative, scale_cut, trim, ...)\n#>     function(x) {\n#>         number(x, accuracy = accuracy, scale = scale, prefix = prefix, \n#>             suffix = suffix, big.mark = big.mark, decimal.mark = decimal.mark, \n#>             style_positive = style_positive, style_negative = style_negative, \n#>             scale_cut = scale_cut, trim = trim, ...)\n#>     }\n#> }\n#> <bytecode: 0x55e1453da518>\n#> <environment: namespace:scales>\nlibrary(ggplot2)\n\np <- ggplot(mtcars, aes(wt, mpg)) +\n  geom_point()\np + facet_grid(. ~ vs, labeller = label_bquote(cols = alpha^.(vs)))\nlibrary(scales)\n\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  scale_y_continuous(labels = number_format(accuracy = 0.01, decimal.mark = \",\"))"},{"path":"function-factories.html","id":"statistical-factories-exercises-10.4.4","chapter":"10 Function factories","heading":"10.3 Statistical factories (Exercises 10.4.4)","text":"Q1. boot_model(), don’t need force evaluation df model?A1. don’t need force evaluation df model arguments automatically evaluated lm():Q2. might formulate Box-Cox transformation like ?A2. see formulate transformation like , can compare one mentioned book:Let’s look one example :can seen:boxcox2(), can vary x value lambda, whilein boxcox3(), can vary lambda vector.Thus, boxcox3() can handy exploring different transformations across inputs.Q3. don’t need worry boot_permute() stores copy data inside function generates?A3. look source code generated function factory, notice exact data frame (mtcars) referenced:don’t need worry copy made df function environment points memory address data frame. can confirm comparing memory addresses:can also check values bindings entered function factory:Q4. much time ll_poisson2() save compared ll_poisson1()? Use bench::mark() see much faster optimisation occurs. changing length x change results?A4. Let’s first compare performance functions example book:can seen, second version much faster first version.can also vary length vector confirm across wide range vector lengths, performance advantage observed.","code":"\nboot_model <- function(df, formula) {\n  mod <- lm(formula, data = df)\n  fitted <- unname(fitted(mod))\n  resid <- unname(resid(mod))\n  rm(mod)\n\n  function() {\n    fitted + sample(resid)\n  }\n}\nboxcox3 <- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x^lambda - 1) / lambda\n    }\n  }\n}\nboxcox2 <- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x^lambda - 1) / lambda\n  }\n}\nboxcox2(1)\n#> function (x) \n#> (x^lambda - 1)/lambda\n#> <environment: 0x55e1430dd818>\n\nboxcox3(mtcars$wt)\n#> function (lambda) \n#> {\n#>     if (lambda == 0) {\n#>         log(x)\n#>     }\n#>     else {\n#>         (x^lambda - 1)/lambda\n#>     }\n#> }\n#> <environment: 0x55e142ecd598>\nboot_permute <- function(df, var) {\n  n <- nrow(df)\n  force(var)\n\n  function() {\n    col <- df[[var]]\n    col[sample(n, replace = TRUE)]\n  }\n}\n\nboot_permute(mtcars, \"mpg\")\n#> function () \n#> {\n#>     col <- df[[var]]\n#>     col[sample(n, replace = TRUE)]\n#> }\n#> <environment: 0x55e143f18b90>\nboot_permute_env <- rlang::fn_env(boot_permute(mtcars, \"mpg\"))\nrlang::env_print(boot_permute_env)\n#> <environment: 0x55e1433b7118>\n#> Parent: <environment: global>\n#> Bindings:\n#> • n: <int>\n#> • df: <df[,11]>\n#> • var: <chr>\n\nidentical(\n  lobstr::obj_addr(boot_permute_env$df),\n  lobstr::obj_addr(mtcars)\n)\n#> [1] TRUE\nidentical(boot_permute_env$df, mtcars)\n#> [1] TRUE\nidentical(boot_permute_env$var, \"mpg\")\n#> [1] TRUE\nll_poisson1 <- function(x) {\n  n <- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\n\nll_poisson2 <- function(x) {\n  n <- length(x)\n  sum_x <- sum(x)\n  c <- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\n\nx1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\n\nbench::mark(\n  \"LL1\" = optimise(ll_poisson1(x1), c(0, 100), maximum = TRUE),\n  \"LL2\" = optimise(ll_poisson2(x1), c(0, 100), maximum = TRUE)\n)\n#> # A tibble: 2 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 LL1          28.7µs   31.4µs    30499.    12.8KB     36.6\n#> 2 LL2          15.7µs     17µs    54596.        0B     32.8\ngenerate_ll_benches <- function(n) {\n  x_vec <- sample.int(n, n)\n\n  bench::mark(\n    \"LL1\" = optimise(ll_poisson1(x_vec), c(0, 100), maximum = TRUE),\n    \"LL2\" = optimise(ll_poisson2(x_vec), c(0, 100), maximum = TRUE)\n  )[1:4] %>%\n    dplyr::mutate(length = n, .before = expression)\n}\n\n(df_bench <- purrr::map_dfr(\n  .x = c(10, 20, 50, 100, 1000),\n  .f = ~ generate_ll_benches(n = .x)\n))\n#> # A tibble: 10 × 5\n#>    length expression      min   median `itr/sec`\n#>     <dbl> <bch:expr> <bch:tm> <bch:tm>     <dbl>\n#>  1     10 LL1          40.8µs   44.4µs    21524.\n#>  2     10 LL2          18.6µs   20.1µs    46965.\n#>  3     20 LL1          43.6µs   46.5µs    20086.\n#>  4     20 LL2            18µs   18.9µs    51313.\n#>  5     50 LL1          47.8µs   50.5µs    19405.\n#>  6     50 LL2          17.3µs   18.2µs    53429.\n#>  7    100 LL1          63.4µs   65.8µs    14783.\n#>  8    100 LL2          18.7µs   19.5µs    50062.\n#>  9   1000 LL1         862.3µs    981µs     1063.\n#> 10   1000 LL2            57µs   58.7µs    16583.\n\nggplot(\n  df_bench,\n  aes(\n    x = as.numeric(length),\n    y = median,\n    group = as.character(expression),\n    color = as.character(expression)\n  )\n) +\n  geom_point() +\n  geom_line() +\n  labs(\n    x = \"Vector length\",\n    y = \"Median Execution Time\",\n    colour = \"Function used\"\n  )"},{"path":"function-factories.html","id":"function-factories-functionals-exercises-10.5.1","chapter":"10 Function factories","heading":"10.4 Function factories + functionals (Exercises 10.5.1)","text":"Q1. following commands equivalent (x, f(z))?A1. depends whether () used data frame list.Q2. Compare contrast effects env_bind() vs. attach() following code.A2. Let’s compare contrast effects env_bind() vs. attach().attach() adds funs search path. Since functions names functions {base} package, attached names mask ones {base} package.env_bind() adds functions funs global environment, instead masking names {base} package.Note \"funs\" output.","code":"(a) `x$f(x$z)`.\n(b) `f(x$z)`.\n(c) `x$f(z)`.\n(d) `f(z)`.\n(e) It depends.\nf <- mean\nz <- 1\nx <- list(f = mean, z = 1)\n\nidentical(with(x, f(z)), x$f(x$z))\n#> [1] TRUE\n\nidentical(with(x, f(z)), f(x$z))\n#> [1] TRUE\n\nidentical(with(x, f(z)), x$f(z))\n#> [1] TRUE\n\nidentical(with(x, f(z)), f(z))\n#> [1] TRUE\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> The following objects are masked from package:base:\n#> \n#>     mean, sum\n\nmean\n#> function (x) \n#> mean(x, na.rm = TRUE)\nhead(search())\n#> [1] \".GlobalEnv\"       \"funs\"             \"package:scales\"  \n#> [4] \"package:ggplot2\"  \"package:rlang\"    \"package:magrittr\"\n\nmean <- function(x) stop(\"Hi!\")\nmean\n#> function (x) \n#> stop(\"Hi!\")\nhead(search())\n#> [1] \".GlobalEnv\"       \"funs\"             \"package:scales\"  \n#> [4] \"package:ggplot2\"  \"package:rlang\"    \"package:magrittr\"\n\ndetach(funs)\nenv_bind(globalenv(), !!!funs)\nmean\n#> function (x) \n#> mean(x, na.rm = TRUE)\n\nmean <- function(x) stop(\"Hi!\")\nmean\n#> function (x) \n#> stop(\"Hi!\")\nenv_unbind(globalenv(), names(funs))"},{"path":"function-factories.html","id":"session-information-8","chapter":"10 Function factories","heading":"10.5 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bench         1.1.3   2023-05-04 [1] RSPM\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  colorspace    2.1-1   2024-07-26 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr         1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  farver        2.1.2   2024-05-13 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  ggplot2     * 3.5.1   2024-04-23 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  grid          4.4.1   2024-08-22 [3] local\n#>  gtable        0.3.5   2024-04-22 [1] RSPM\n#>  highr         0.11    2024-05-26 [1] RSPM\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  labeling      0.4.3   2023-08-29 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  lobstr        1.1.2   2022-06-22 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  munsell       0.5.1   2024-04-01 [1] RSPM\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  profmem       0.6.0   2020-12-13 [1] RSPM\n#>  purrr         1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang       * 1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  scales      * 1.3.0   2023-11-28 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tibble        3.2.1   2023-03-20 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"function-operators.html","id":"function-operators","chapter":"11 Function operators","heading":"11 Function operators","text":"Attaching needed libraries:","code":"\nlibrary(purrr, warn.conflicts = FALSE)"},{"path":"function-operators.html","id":"existing-function-operators-exercises-11.2.3","chapter":"11 Function operators","heading":"11.1 Existing function operators (Exercises 11.2.3)","text":"Q1. Base R provides function operator form Vectorize(). ? might use ?A1. Vectorize() function creates function vectorizes action provided function specified arguments (.e., acts element vector). see utility solving problem otherwise difficult solve.problem find indices matching numeric values given threshold creating hybrid following functions:%% (doesn’t provide way provide tolerance comparing numeric values),dplyr::near() (vectorized element-wise thus expects two vectors equal length)Let’s use :Note needed create new function neither existing functions want.solved complex task using Vectorize() function!Q2. Read source code possibly(). work?A2. Let’s look source code function:Looking code, can see possibly():uses tryCatch() error handlinghas parameter otherwise specify default value case error occurshas parameter quiet suppress error message (needed)Q3. Read source code safely(). work?A3. Let’s look source code function:Looking code, can see safely():uses list save results (function executes successfully) error (fails)uses tryCatch() error handlinghas parameter otherwise specify default value case error occurshas parameter quiet suppress error message (needed)","code":"\nwhich_near <- function(x, y, tolerance) {\n  # Vectorize `dplyr::near()` function only over the `y` argument.\n  # `Vectorize()` is a function operator and will return a function.\n  customNear <- Vectorize(dplyr::near, vectorize.args = c(\"y\"), SIMPLIFY = FALSE)\n\n  # Apply the vectorized function to vector arguments and then check where the\n  # comparisons are equal (i.e. `TRUE`) using `which()`.\n  #\n  # Use `compact()` to remove empty elements from the resulting list.\n  index_list <- purrr::compact(purrr::map(customNear(x, y, tol = tolerance), which))\n\n  # If there are any matches, return the indices as an atomic vector of integers.\n  if (length(index_list) > 0L) {\n    index_vector <- purrr::simplify(index_list, \"integer\")\n    return(index_vector)\n  }\n\n  # If there are no matches\n  return(integer(0L))\n}\nx1 <- c(2.1, 3.3, 8.45, 8, 6)\nx2 <- c(6, 8.40, 3)\n\nwhich_near(x1, x2, tolerance = 0.1)\n#> [1] 5 3\nwhich(x1 %in% x2)\n#> [1] 5\n\nwhich(dplyr::near(x1, x2, tol = 0.1))\n#> Warning in x - y: longer object length is not a multiple of\n#> shorter object length\n#> integer(0)\npossibly\n#> function (.f, otherwise = NULL, quiet = TRUE) \n#> {\n#>     .f <- as_mapper(.f)\n#>     force(otherwise)\n#>     check_bool(quiet)\n#>     function(...) {\n#>         tryCatch(.f(...), error = function(e) {\n#>             if (!quiet) \n#>                 message(\"Error: \", conditionMessage(e))\n#>             otherwise\n#>         })\n#>     }\n#> }\n#> <bytecode: 0x556e27b0fd88>\n#> <environment: namespace:purrr>\nsafely\n#> function (.f, otherwise = NULL, quiet = TRUE) \n#> {\n#>     .f <- as_mapper(.f)\n#>     force(otherwise)\n#>     check_bool(quiet)\n#>     function(...) capture_error(.f(...), otherwise, quiet)\n#> }\n#> <bytecode: 0x556e27ce45c0>\n#> <environment: namespace:purrr>\n\npurrr:::capture_error\n#> function (code, otherwise = NULL, quiet = TRUE) \n#> {\n#>     tryCatch(list(result = code, error = NULL), error = function(e) {\n#>         if (!quiet) \n#>             message(\"Error: \", conditionMessage(e))\n#>         list(result = otherwise, error = e)\n#>     })\n#> }\n#> <bytecode: 0x556e27d1cf10>\n#> <environment: namespace:purrr>"},{"path":"function-operators.html","id":"case-study-creating-your-own-function-operators-exercises-11.3.1","chapter":"11 Function operators","heading":"11.2 Case study: Creating your own function operators (Exercises 11.3.1)","text":"Q1. Weigh pros cons download.file %>% dot_every(10) %>% delay_by(0.1) versus download.file %>% delay_by(0.1) %>% dot_every(10).A1. Although chains piped operations produce number dots need amount time, subtle difference .download.file %>% dot_every(10) %>% delay_by(0.1), printing dot also delayed, first dot printed 10th URL download starts.download.file %>% delay_by(0.1) %>% dot_every(10), first dot printed 9th download finished, 10th download starts short delay.Q2. memoise download.file()? ?A2. Since download.file() meant download files Internet, memoising recommended following reasons:Memoization helpful giving input function returns output. necessarily case webpages since constantly change, may continue “download” outdated version webpage.Memoization helpful giving input function returns output. necessarily case webpages since constantly change, may continue “download” outdated version webpage.Memoization works caching results, can take significant amount memory.Memoization works caching results, can take significant amount memory.Q3. Create function operator reports whenever file created deleted working directory, using dir() setdiff(). global function effects might want track?A3. First, let’s create helper functions compare print added removed filenames:can write function operator use create functions necessary tracking:Let’s try :global function effects might want track:working directoryenvironment variablesconnectionslibrary pathsgraphics devicesetc.Q4. Write function operator logs timestamp message file every time function run.A4. following function operator logs timestamp message file every time function run:Q5. Modify delay_by() instead delaying fixed amount time, ensures certain amount time elapsed since function last called. , called g <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn’t extra delay.A5. Modified version function meeting specified requirements:","code":"\nprint_multiple_entries <- function(header, entries) {\n  message(paste0(header, \":\\n\"), paste0(entries, collapse = \"\\n\"))\n}\n\nfile_comparator <- function(old, new) {\n  if (setequal(old, new)) {\n    return()\n  }\n\n  removed <- setdiff(old, new)\n  added <- setdiff(new, old)\n\n  if (length(removed) > 0L) print_multiple_entries(\"- File removed\", removed)\n  if (length(added) > 0L) print_multiple_entries(\"- File added\", added)\n}\ndir_tracker <- function(f) {\n  force(f)\n  function(...) {\n    old_files <- dir()\n    on.exit(file_comparator(old_files, dir()), add = TRUE)\n\n    f(...)\n  }\n}\n\nfile_creation_tracker <- dir_tracker(file.create)\nfile_deletion_tracker <- dir_tracker(file.remove)\nfile_creation_tracker(c(\"a.txt\", \"b.txt\"))\n#> - File added:\n#> a.txt\n#> b.txt\n#> [1] TRUE TRUE\n\nfile_deletion_tracker(c(\"a.txt\", \"b.txt\"))\n#> - File removed:\n#> a.txt\n#> b.txt\n#> [1] TRUE TRUE\n# helper function to write to a file connection\nwrite_line <- function(filepath, ...) {\n  cat(..., \"\\n\", sep = \"\", file = filepath, append = TRUE)\n}\n\n# function operator\nlogger <- function(f, filepath) {\n  force(f)\n  force(filepath)\n\n  write_line(filepath, \"Function created at: \", as.character(Sys.time()))\n\n  function(...) {\n    write_line(filepath, \"Function called at:  \", as.character(Sys.time()))\n    f(...)\n  }\n}\n\n# check that the function works as expected with a tempfile\nwithr::with_tempfile(\"logfile\", code = {\n  logged_runif <- logger(runif, logfile)\n\n  Sys.sleep(sample.int(10, 1))\n  logged_runif(1)\n\n  Sys.sleep(sample.int(10, 1))\n  logged_runif(2)\n\n  Sys.sleep(sample.int(10, 1))\n  logged_runif(3)\n\n  cat(readLines(logfile), sep = \"\\n\")\n})\n#> Function created at: 2024-10-01 21:35:19.360914\n#> Function called at:  2024-10-01 21:35:24.367915\n#> Function called at:  2024-10-01 21:35:29.37334\n#> Function called at:  2024-10-01 21:35:37.381786\ndelay_by_atleast <- function(f, amount) {\n  force(f)\n  force(amount)\n\n  # the last time the function was run\n  last_time <- NULL\n\n  function(...) {\n    if (!is.null(last_time)) {\n      wait <- (last_time - Sys.time()) + amount\n      if (wait > 0) Sys.sleep(wait)\n    }\n\n    # update the time in the parent frame for the next run when the function finishes\n    on.exit(last_time <<- Sys.time())\n\n    f(...)\n  }\n}"},{"path":"function-operators.html","id":"session-information-9","chapter":"11 Function operators","heading":"11.3 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr         1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  purrr       * 1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tibble        3.2.1   2023-03-20 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"base-types.html","id":"base-types","chapter":"12 Base Types","heading":"12 Base Types","text":"exercises.","code":""},{"path":"s3.html","id":"s3","chapter":"13 S3","heading":"13 S3","text":"Attaching needed libraries:","code":"\nlibrary(sloop, warn.conflicts = FALSE)\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(purrr, warn.conflicts = FALSE)"},{"path":"s3.html","id":"basics-exercises-13.2.1","chapter":"13 S3","heading":"13.1 Basics (Exercises 13.2.1)","text":"Q1. Describe difference t.test() t.data.frame(). function called?A1. difference t.test() t.data.frame() following:t.test() generic function perform t-test.t.test() generic function perform t-test.t.data.frame() method generic t() (matrix transform function) dispatched data.frame objects.t.data.frame() method generic t() (matrix transform function) dispatched data.frame objects.can also confirm function types using ftype():Q2. Make list commonly used base R functions contain . name S3 methods.A2. common R functions . S3 methods:.equal().* functions (like .data.frame(), .numeric(), etc.)install.packages().exit()\netc.example,Q3. .data.frame.data.frame() method ? confusing? avoid confusion code?A3. ’s S3 method generic .data.frame().can seen methods supported generic:Given number .s name, quite confusing figure name generic name class.Q4. Describe difference behaviour two calls.A4. difference behaviour specified calls.unclassing, mean generic dispatches .Date method:unclassing, mean generic dispatches .numeric method:Q5. class object following code return? base type built ? attributes use?A5. object based base type closure6, type function.class ecdf, superclasses.Apart class, following attributes:Q6. class object following code return? base type built ? attributes use?A6. object based base type integer.class table.Apart class, following attributes:","code":"\nftype(t.test)\n#> [1] \"S3\"      \"generic\"\nftype(t.data.frame)\n#> [1] \"S3\"     \"method\"\nftype(as.data.frame)\n#> [1] \"S3\"      \"generic\"\nftype(on.exit)\n#> [1] \"primitive\"\nftype(as.data.frame.data.frame)\n#> [1] \"S3\"     \"method\"\ns3_methods_generic(\"as.data.frame\") %>%\n  dplyr::filter(class == \"data.frame\")\n#> # A tibble: 1 × 4\n#>   generic       class      visible source\n#>   <chr>         <chr>      <lgl>   <chr> \n#> 1 as.data.frame data.frame TRUE    base\nset.seed(1014)\nsome_days <- as.Date(\"2017-01-31\") + sample(10, 5)\nmean(some_days)\n#> [1] \"2017-02-06\"\nmean(unclass(some_days))\n#> [1] 17203.4\nsome_days <- as.Date(\"2017-01-31\") + sample(10, 5)\n\nsome_days\n#> [1] \"2017-02-06\" \"2017-02-09\" \"2017-02-05\" \"2017-02-08\"\n#> [5] \"2017-02-07\"\n\ns3_dispatch(mean(some_days))\n#> => mean.Date\n#>  * mean.default\n\nmean(some_days)\n#> [1] \"2017-02-07\"\nunclass(some_days)\n#> [1] 17203 17206 17202 17205 17204\n\nmean(unclass(some_days))\n#> [1] 17204\n\ns3_dispatch(mean(unclass(some_days)))\n#>    mean.double\n#>    mean.numeric\n#> => mean.default\nx <- ecdf(rpois(100, 10))\nx\nx <- ecdf(rpois(100, 10))\nx\n#> Empirical CDF \n#> Call: ecdf(rpois(100, 10))\n#>  x[1:18] =      2,      3,      4,  ...,     18,     19\n\notype(x)\n#> [1] \"S3\"\ntypeof(x)\n#> [1] \"closure\"\ns3_class(x)\n#> [1] \"ecdf\"     \"stepfun\"  \"function\"\nattributes(x)\n#> $class\n#> [1] \"ecdf\"     \"stepfun\"  \"function\"\n#> \n#> $call\n#> ecdf(rpois(100, 10))\nx <- table(rpois(100, 5))\nx\nx <- table(rpois(100, 5))\nx\n#> \n#>  1  2  3  4  5  6  7  8  9 10 \n#>  7  7 18 13 14 14 16  4  4  3\n\notype(x)\n#> [1] \"S3\"\ntypeof(x)\n#> [1] \"integer\"\ns3_class(x)\n#> [1] \"table\"\nattributes(x)\n#> $dim\n#> [1] 10\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n#> \n#> \n#> $class\n#> [1] \"table\""},{"path":"s3.html","id":"classes-exercises-13.3.4","chapter":"13 S3","heading":"13.2 Classes (Exercises 13.3.4)","text":"Q1. Write constructor data.frame objects. base type data frame built ? attributes use? restrictions placed individual elements? names?A1. data frame built top named list atomic vectors attributes row names:restriction imposed individual elements need length. Additionally, names need syntactically valid unique.Let’s try :Q2. Enhance factor() helper better behaviour one values found levels. base::factor() situation?A2. one values found levels, values converted NA base::factor():new constructor, can throw error inform user:Let’s try :Q3. Carefully read source code factor(). constructor ?A3. source code factor() can read .number ways base version flexible.allows labeling values:checks levels duplicated.levels argument can NULL.Q4. Factors optional “contrasts” attribute. Read help C(), briefly describe purpose attribute. type ? Rewrite new_factor() constructor include attribute.A4. Categorical variables typically encoded dummy variables regression models default level compared first factor level. Contrats provide flexible way comparisons.can set \"contrasts\" attribute factor using stats::C().Alternatively, can set \"contrasts\" attribute using matrix (?contrasts):[Contrasts] can matrix one row level factor suitable function like contr.poly character string giving name functionThe constructor provided book:can updated also support contrasts:Q5. Read documentation utils::.roman(). write constructor class? need validator? might helper ?A5. utils::.roman() converts Indo-Arabic numerals Roman numerals. Removing class also reveals implemented using base type integer:Therefore, can create simple constructor create new instance class:docs mention following:numbers 1 3899 unique representation roman numbers, hence others result .roman(NA).Therefore, can warn user return NA validator function:helper function can coerce entered input integer type convenience:Let’s try :","code":"\nunclass(data.frame())\n#> named list()\n#> attr(,\"row.names\")\n#> integer(0)\nnew_data_frame <- function(x = list(), row.names = character()) {\n  # row names should be character\n  if (!all(is.character(row.names))) {\n    stop(\"Row name should be of `chracter` type.\", call. = FALSE)\n  }\n\n  # all elements should have the same length\n  unique_element_lengths <- unique(purrr::map_int(x, length))\n  if (length(unique_element_lengths) > 1L) {\n    stop(\"All list elements in `x` should have same length.\", call. = FALSE)\n  }\n\n  # if not provided, generate row names\n  # this is necessary if there is at least one element in the list\n  if (length(x) > 0L && length(row.names) == 0L) {\n    row.names <- .set_row_names(unique_element_lengths)\n  }\n\n  structure(x, class = \"data.frame\", row.names = row.names)\n}\nnew_data_frame(list(\"x\" = 1, \"y\" = c(2, 3)))\n#> Error: All list elements in `x` should have same length.\n\nnew_data_frame(list(\"x\" = 1, \"y\" = c(2)), row.names = 1L)\n#> Error: Row name should be of `chracter` type.\n\nnew_data_frame(list())\n#> data frame with 0 columns and 0 rows\n\nnew_data_frame(list(\"x\" = 1, \"y\" = 2))\n#>   x y\n#> 1 1 2\n\nnew_data_frame(list(\"x\" = 1, \"y\" = 2), row.names = \"row-1\")\n#>       x y\n#> row-1 1 2\nbase::factor(c(\"a\", \"b\", \"c\"), levels = c(\"a\", \"c\"))\n#> [1] a    <NA> c   \n#> Levels: a c\nnew_factor <- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nvalidate_factor <- function(x) {\n  values <- unclass(x)\n  levels <- attr(x, \"levels\")\n\n  if (!all(!is.na(values) & values > 0)) {\n    stop(\n      \"All `x` values must be non-missing and greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) < max(values)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\ncreate_factor <- function(x = character(), levels = unique(x)) {\n  ind <- match(x, levels)\n\n  if (any(is.na(ind))) {\n    missing_values <- x[which(is.na(match(x, levels)))]\n\n    stop(\n      paste0(\n        \"Following values from `x` are not present in `levels`:\\n\",\n        paste0(missing_values, collapse = \"\\n\")\n      ),\n      call. = FALSE\n    )\n  }\n\n  validate_factor(new_factor(ind, levels))\n}\ncreate_factor(c(\"a\", \"b\", \"c\"), levels = c(\"a\", \"c\"))\n#> Error: Following values from `x` are not present in `levels`:\n#> b\n\ncreate_factor(c(\"a\", \"b\", \"c\"), levels = c(\"a\", \"b\", \"c\"))\n#> [1] a b c\n#> Levels: a b c\nx <- c(\"a\", \"b\", \"b\")\nlevels <- c(\"a\", \"b\", \"c\")\nlabels <- c(\"one\", \"two\", \"three\")\n\nfactor(x, levels = levels, labels = labels)\n#> [1] one two two\n#> Levels: one two three\nx <- c(\"a\", \"b\", \"b\")\nlevels <- c(\"a\", \"b\", \"b\")\n\nfactor(x, levels = levels)\n#> Error in `levels<-`(`*tmp*`, value = as.character(levels)): factor level [3] is duplicated\n\ncreate_factor(x, levels = levels)\n#> [1] a b b\n#> Levels: a b b\n#> Warning in print.factor(x): duplicated level [3] in factor\nx <- c(\"a\", \"b\", \"b\")\n\nfactor(x, levels = NULL)\n#> [1] <NA> <NA> <NA>\n#> Levels:\n\ncreate_factor(x, levels = NULL)\n#> Error: Following values from `x` are not present in `levels`:\n#> a\n#> b\n#> b\nnew_factor <- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\nnew_factor <- function(x = integer(),\n                       levels = character(),\n                       contrasts = NULL) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  if (!is.null(contrasts)) {\n    stopifnot(is.matrix(contrasts) && is.numeric(contrasts))\n  }\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contrasts\n  )\n}\nas.roman(1)\n#> [1] I\n\ntypeof(unclass(as.roman(1)))\n#> [1] \"integer\"\nnew_roman <- function(x = integer()) {\n  stopifnot(is.integer(x))\n\n  structure(x, class = \"roman\")\n}\nas.roman(10000)\n#> [1] <NA>\nvalidate_new_roman <- function(x) {\n  int_values <- unclass(x)\n\n  if (any(int_values < 1L | int_values > 3899L)) {\n    warning(\n      \"Integer should be between 1 and 3899. Returning `NA` otherwise.\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\nroman <- function(x = integer()) {\n  x <- as.integer(x)\n\n  validate_new_roman(new_roman(x))\n}\nroman(1)\n#> [1] I\n\nroman(c(5, 20, 100, 150, 100000))\n#> Warning: Integer should be between 1 and 3899. Returning\n#> `NA` otherwise.\n#> [1] V    XX   C    CL   <NA>"},{"path":"s3.html","id":"generics-and-methods-exercises-13.4.4","chapter":"13 S3","heading":"13.3 Generics and methods (Exercises 13.4.4)","text":"Q1. Read source code t() t.test() confirm t.test() S3 generic S3 method. happens create object class test call t() ? ?A1. Looking source code functions, can see generic, can confirm using sloop:Looking S3 dispatch, can see since R can’t find S3 method test class generic function t(), dispatches default method, converts structure matrix:behaviour can observed vector:Q2. generics table class methods ?A2. table class methods following generics:Q3. generics ecdf class methods ?A3. ecdf class methods following generics:Q4. base generic greatest number defined methods?A4. answer question, first, let’s list functions base retain generics.Now ’s simple matter counting number methods per generic ordering data frame descending order count:reveals base generic function methods print().Q5. Carefully read documentation UseMethod() explain following code returns results . two usual rules function evaluation UseMethod() violate?A5. called directly, g.default() method takes x value argument y global environment:, g() function called, takes x argument, comes function environment:docs ?UseMethod() clarify case:local variables defined call UseMethod retainedThat , UseMethod() calls g.default(), variables defined inside generic also available g.default() method. arguments supplied function passed , however, affected code inside generic.Two rules function evaluation violated UseMethod():Name maskingA fresh startQ6. arguments [? hard question answer?A6. difficult say many formal arguments subsetting [ operator generic function methods vectors, matrices, arrays, lists, etc., different methods different number arguments:can sample see wide variation number formal arguments:","code":"\nx <- structure(1:10, class = \"test\")\nt(x)\nt\n#> function (x) \n#> UseMethod(\"t\")\n#> <bytecode: 0x55d3cc6b94e8>\n#> <environment: namespace:base>\nsloop::is_s3_generic(\"t\")\n#> [1] TRUE\n\nt.test\n#> function (x, ...) \n#> UseMethod(\"t.test\")\n#> <bytecode: 0x55d3ca890610>\n#> <environment: namespace:stats>\nsloop::is_s3_generic(\"t.test\")\n#> [1] TRUE\nx <- structure(1:10, class = \"test\")\nt(x)\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    2    3    4    5    6    7    8    9    10\n#> attr(,\"class\")\n#> [1] \"test\"\ns3_dispatch(t(x))\n#>    t.test\n#> => t.default\nt(1:10)\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    2    3    4    5    6    7    8    9    10\ns3_methods_class(\"table\")\n#> # A tibble: 11 × 4\n#>    generic       class visible source             \n#>    <chr>         <chr> <lgl>   <chr>              \n#>  1 [             table TRUE    base               \n#>  2 aperm         table TRUE    base               \n#>  3 as_tibble     table FALSE   registered S3method\n#>  4 as.data.frame table TRUE    base               \n#>  5 Axis          table FALSE   registered S3method\n#>  6 lines         table FALSE   registered S3method\n#>  7 plot          table FALSE   registered S3method\n#>  8 points        table FALSE   registered S3method\n#>  9 print         table TRUE    base               \n#> 10 summary       table TRUE    base               \n#> 11 tail          table FALSE   registered S3method\ns3_methods_class(\"ecdf\")\n#> # A tibble: 4 × 4\n#>   generic  class visible source             \n#>   <chr>    <chr> <lgl>   <chr>              \n#> 1 plot     ecdf  TRUE    stats              \n#> 2 print    ecdf  FALSE   registered S3method\n#> 3 quantile ecdf  FALSE   registered S3method\n#> 4 summary  ecdf  FALSE   registered S3method\n# getting all functions names\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\n\n# extracting only generics\ngenFuns <- names(funs) %>%\n  purrr::keep(~ sloop::is_s3_generic(.x))\npurrr::map_dfr(\n  genFuns,\n  ~ s3_methods_generic(.)\n) %>%\n  dplyr::group_by(generic) %>%\n  dplyr::tally() %>%\n  dplyr::arrange(desc(n))\n#> # A tibble: 123 × 2\n#>    generic           n\n#>    <chr>         <int>\n#>  1 print           292\n#>  2 format          132\n#>  3 [                54\n#>  4 summary          39\n#>  5 as.character     38\n#>  6 as.data.frame    32\n#>  7 plot             31\n#>  8 [[               26\n#>  9 [<-              17\n#> 10 $                15\n#> # ℹ 113 more rows\ng <- function(x) {\n  x <- 10\n  y <- 10\n  UseMethod(\"g\")\n}\ng.default <- function(x) c(x = x, y = y)\nx <- 1\ny <- 1\ng(x)\n#> x y \n#> 1 1\ng.default(x)\n#> x y \n#> 1 1\ng(x)\n#> x y \n#> 1 1\ns3_methods_generic(\"[\") %>%\n  dplyr::filter(source == \"base\")\n#> # A tibble: 17 × 4\n#>    generic class           visible source\n#>    <chr>   <chr>           <lgl>   <chr> \n#>  1 [       AsIs            TRUE    base  \n#>  2 [       data.frame      TRUE    base  \n#>  3 [       Date            TRUE    base  \n#>  4 [       difftime        TRUE    base  \n#>  5 [       Dlist           TRUE    base  \n#>  6 [       DLLInfoList     TRUE    base  \n#>  7 [       factor          TRUE    base  \n#>  8 [       hexmode         TRUE    base  \n#>  9 [       listof          TRUE    base  \n#> 10 [       noquote         TRUE    base  \n#> 11 [       numeric_version TRUE    base  \n#> 12 [       octmode         TRUE    base  \n#> 13 [       POSIXct         TRUE    base  \n#> 14 [       POSIXlt         TRUE    base  \n#> 15 [       simple.list     TRUE    base  \n#> 16 [       table           TRUE    base  \n#> 17 [       warnings        TRUE    base\n# table\nnames(formals(`[.table`))\n#> [1] \"x\"    \"i\"    \"j\"    \"...\"  \"drop\"\n\n# Date\nnames(formals(`[.Date`))\n#> [1] \"x\"    \"...\"  \"drop\"\n\n# data frame\nnames(formals(`[.data.frame`))\n#> [1] \"x\"    \"i\"    \"j\"    \"drop\"\n\n# etc."},{"path":"s3.html","id":"object-styles-exercises-13.5.1","chapter":"13 S3","heading":"13.4 Object styles (Exercises 13.5.1)","text":"Q1. Categorise objects returned lm(), factor(), table(), .Date(), .POSIXct() ecdf(), ordered(), () styles described .A1. Objects returned functions can categorized follows:Vector style objects (length represents . observations)factor()table().Date().POSIXct()ordered()Record style objects (equi-length vectors represent object components)None.Dataframe style objects (Record style two-dimensions)None.Scalar objects (list represent single thing)lm() (represent one regression model)ecdf() (represents one distribution)() special:\njust adds new class object indicate treated .Therefore, object style superclass’ object style.Q2. constructor function lm objects, new_lm(), look like? Use ?lm experimentation figure required fields types.A2. lm object scalar object, .e. object contains named list atomic vectors varying lengths types represent single thing (regression model).Based information, can write new constructor object:","code":"\nfactor_obj <- factor(c(\"a\", \"b\"))\nlength(factor_obj)\n#> [1] 2\nlength(unclass(factor_obj))\n#> [1] 2\ntab_object <- table(mtcars$am)\nlength(tab_object)\n#> [1] 2\nlength(unlist(tab_object))\n#> [1] 2\ndate_obj <- as.Date(\"02/27/92\", \"%m/%d/%y\")\nlength(date_obj)\n#> [1] 1\nlength(unclass(date_obj))\n#> [1] 1\nposix_obj <- as.POSIXct(1472562988, origin = \"1960-01-01\")\nlength(posix_obj)\n#> [1] 1\nlength(unclass(posix_obj))\n#> [1] 1\nordered_obj <- ordered(factor(c(\"a\", \"b\")))\nlength(ordered_obj)\n#> [1] 2\nlength(unclass(ordered_obj))\n#> [1] 2\nlm_obj <- lm(wt ~ mpg, mtcars)\nlength(lm_obj)\n#> [1] 12\nlength(unclass(lm_obj))\n#> [1] 12\necdf_obj <- ecdf(rnorm(12))\nlength(ecdf_obj)\n#> [1] 1\nlength(unclass(ecdf_obj))\n#> [1] 1\nx <- ecdf(rnorm(12))\nclass(x)\n#> [1] \"ecdf\"     \"stepfun\"  \"function\"\nclass(I(x))\n#> [1] \"AsIs\"     \"ecdf\"     \"stepfun\"  \"function\"\nmod <- lm(wt ~ mpg, mtcars)\n\ntypeof(mod)\n#> [1] \"list\"\n\nattributes(mod)\n#> $names\n#>  [1] \"coefficients\"  \"residuals\"     \"effects\"      \n#>  [4] \"rank\"          \"fitted.values\" \"assign\"       \n#>  [7] \"qr\"            \"df.residual\"   \"xlevels\"      \n#> [10] \"call\"          \"terms\"         \"model\"        \n#> \n#> $class\n#> [1] \"lm\"\n\npurrr::map_chr(unclass(mod), typeof)\n#>  coefficients     residuals       effects          rank \n#>      \"double\"      \"double\"      \"double\"     \"integer\" \n#> fitted.values        assign            qr   df.residual \n#>      \"double\"     \"integer\"        \"list\"     \"integer\" \n#>       xlevels          call         terms         model \n#>        \"list\"    \"language\"    \"language\"        \"list\"\n\npurrr::map_int(unclass(mod), length)\n#>  coefficients     residuals       effects          rank \n#>             2            32            32             1 \n#> fitted.values        assign            qr   df.residual \n#>            32             2             5             1 \n#>       xlevels          call         terms         model \n#>             0             3             3             2\nnew_lm <- function(coefficients,\n                   residuals,\n                   effects,\n                   rank,\n                   fitted.values,\n                   assign,\n                   qr,\n                   df.residual,\n                   xlevels,\n                   call,\n                   terms,\n                   model) {\n  stopifnot(\n    is.double(coefficients),\n    is.double(residuals),\n    is.double(effects),\n    is.integer(rank),\n    is.double(fitted.values),\n    is.integer(assign),\n    is.list(qr),\n    is.integer(df.residual),\n    is.list(xlevels),\n    is.language(call),\n    is.language(terms),\n    is.list(model)\n  )\n\n  structure(\n    list(\n      coefficients  = coefficients,\n      residuals     = residuals,\n      effects       = effects,\n      rank          = rank,\n      fitted.values = fitted.values,\n      assign        = assign,\n      qr            = qr,\n      df.residual   = df.residual,\n      xlevels       = xlevels,\n      call          = call,\n      terms         = terms,\n      model         = model\n    ),\n    class = \"lm\"\n  )\n}"},{"path":"s3.html","id":"inheritance-exercises-13.6.3","chapter":"13 S3","heading":"13.5 Inheritance (Exercises 13.6.3)","text":"Q1. [.Date support subclasses? fail support subclasses?A1. [.Date method defined follows:.Date function looks like :, oldClass class().Therefore, reading code, can surmise :[.Date supports subclasses preserving class input.[.Date fails support subclasses preserving attributes input.example,Q2. R two classes representing date time data, POSIXct POSIXlt, inherit POSIXt. generics different behaviours two classes? generics share behaviour?A2. First, let’s demonstrate POSIXct POSIXlt indeed subclasses POSIXt superclass.Remember way S3 method dispatch works, generic method superclass, method also inherited subclass.can extract vector generics supported sub- super-classes:Methods specific subclasses:Let’s see example:Methods inherited subclasses superclass:Let’s see one example generic:Q3. expect code return? actually return? ?A3. Naively, expect code return \"a1\", actually returns \"a2\":S3 dispatch explains :mentioned book, UseMethod() functiontracks list potential next methods special variable, means modifying object ’s dispatched upon impact method gets called next.special variable .Class:.Class character vector classes used find next method. NextMethod adds attribute “previous” .Class giving .Class last used dispatch, shifts .Class along used dispatch., can print .Class confirm adding new class x indeed doesn’t change .Class, therefore dispatch occurs \"a2\" class:","code":"\nsloop::s3_get_method(\"[.Date\")\n#> function (x, ..., drop = TRUE) \n#> {\n#>     .Date(NextMethod(\"[\"), oldClass(x))\n#> }\n#> <bytecode: 0x55d3cd42b688>\n#> <environment: namespace:base>\n.Date\n#> function (xx, cl = \"Date\") \n#> `class<-`(xx, cl)\n#> <bytecode: 0x55d3cd5f1140>\n#> <environment: namespace:base>\nx <- structure(Sys.Date(), name = \"myName\", class = c(\"subDate\", \"Date\"))\n\n# `$name` is gone\nattributes(x[1])\n#> $class\n#> [1] \"subDate\" \"Date\"\n\nx[1]\n#> [1] \"2024-10-01\"\ndt_lt <- as.POSIXlt(Sys.time(), \"GMT\")\nclass(dt_lt)\n#> [1] \"POSIXlt\" \"POSIXt\"\n\ndt_ct <- as.POSIXct(Sys.time(), \"GMT\")\nclass(dt_ct)\n#> [1] \"POSIXct\" \"POSIXt\"\n\ndt_t <- structure(dt_ct, class = \"POSIXt\")\nclass(dt_t)\n#> [1] \"POSIXt\"\n(t_generics <- s3_methods_class(\"POSIXt\")$generic)\n#>  [1] \"-\"            \"+\"            \"all.equal\"   \n#>  [4] \"as.character\" \"Axis\"         \"cut\"         \n#>  [7] \"diff\"         \"hist\"         \"is.numeric\"  \n#> [10] \"julian\"       \"Math\"         \"months\"      \n#> [13] \"Ops\"          \"pretty\"       \"quantile\"    \n#> [16] \"quarters\"     \"round\"        \"seq\"         \n#> [19] \"str\"          \"trunc\"        \"weekdays\"\n\n(lt_generics <- s3_methods_class(\"POSIXlt\")$generic)\n#>  [1] \"[\"             \"[[\"            \"[[<-\"         \n#>  [4] \"[<-\"           \"$<-\"           \"anyNA\"        \n#>  [7] \"as.data.frame\" \"as.Date\"       \"as.double\"    \n#> [10] \"as.list\"       \"as.matrix\"     \"as.POSIXct\"   \n#> [13] \"as.vector\"     \"c\"             \"duplicated\"   \n#> [16] \"format\"        \"is.finite\"     \"is.infinite\"  \n#> [19] \"is.na\"         \"is.nan\"        \"length\"       \n#> [22] \"length<-\"      \"mean\"          \"mtfrm\"        \n#> [25] \"names\"         \"names<-\"       \"print\"        \n#> [28] \"rep\"           \"sort\"          \"summary\"      \n#> [31] \"Summary\"       \"unique\"        \"weighted.mean\"\n#> [34] \"xtfrm\"\n\n(ct_generics <- s3_methods_class(\"POSIXct\")$generic)\n#>  [1] \"[\"             \"[[\"            \"[<-\"          \n#>  [4] \"as.data.frame\" \"as.Date\"       \"as.list\"      \n#>  [7] \"as.POSIXlt\"    \"c\"             \"format\"       \n#> [10] \"length<-\"      \"mean\"          \"mtfrm\"        \n#> [13] \"print\"         \"range\"         \"rep\"          \n#> [16] \"split\"         \"summary\"       \"Summary\"      \n#> [19] \"weighted.mean\" \"xtfrm\"\nunion(lt_generics, ct_generics)\n#>  [1] \"[\"             \"[[\"            \"[[<-\"         \n#>  [4] \"[<-\"           \"$<-\"           \"anyNA\"        \n#>  [7] \"as.data.frame\" \"as.Date\"       \"as.double\"    \n#> [10] \"as.list\"       \"as.matrix\"     \"as.POSIXct\"   \n#> [13] \"as.vector\"     \"c\"             \"duplicated\"   \n#> [16] \"format\"        \"is.finite\"     \"is.infinite\"  \n#> [19] \"is.na\"         \"is.nan\"        \"length\"       \n#> [22] \"length<-\"      \"mean\"          \"mtfrm\"        \n#> [25] \"names\"         \"names<-\"       \"print\"        \n#> [28] \"rep\"           \"sort\"          \"summary\"      \n#> [31] \"Summary\"       \"unique\"        \"weighted.mean\"\n#> [34] \"xtfrm\"         \"as.POSIXlt\"    \"range\"        \n#> [37] \"split\"\ns3_dispatch(is.na(dt_lt))\n#> => is.na.POSIXlt\n#>    is.na.POSIXt\n#>    is.na.default\n#>  * is.na (internal)\n\ns3_dispatch(is.na(dt_ct))\n#>    is.na.POSIXct\n#>    is.na.POSIXt\n#>    is.na.default\n#> => is.na (internal)\n\ns3_dispatch(is.na(dt_t))\n#>    is.na.POSIXt\n#>    is.na.default\n#> => is.na (internal)\nsetdiff(t_generics, union(lt_generics, ct_generics))\n#>  [1] \"-\"            \"+\"            \"all.equal\"   \n#>  [4] \"as.character\" \"Axis\"         \"cut\"         \n#>  [7] \"diff\"         \"hist\"         \"is.numeric\"  \n#> [10] \"julian\"       \"Math\"         \"months\"      \n#> [13] \"Ops\"          \"pretty\"       \"quantile\"    \n#> [16] \"quarters\"     \"round\"        \"seq\"         \n#> [19] \"str\"          \"trunc\"        \"weekdays\"\ns3_dispatch(is.numeric(dt_lt))\n#>    is.numeric.POSIXlt\n#> => is.numeric.POSIXt\n#>    is.numeric.default\n#>  * is.numeric (internal)\n\ns3_dispatch(is.numeric(dt_ct))\n#>    is.numeric.POSIXct\n#> => is.numeric.POSIXt\n#>    is.numeric.default\n#>  * is.numeric (internal)\n\ns3_dispatch(is.numeric(dt_t))\n#> => is.numeric.POSIXt\n#>    is.numeric.default\n#>  * is.numeric (internal)\ngeneric2 <- function(x) UseMethod(\"generic2\")\ngeneric2.a1 <- function(x) \"a1\"\ngeneric2.a2 <- function(x) \"a2\"\ngeneric2.b <- function(x) {\n  class(x) <- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\ngeneric2 <- function(x) UseMethod(\"generic2\")\ngeneric2.a1 <- function(x) \"a1\"\ngeneric2.a2 <- function(x) \"a2\"\ngeneric2.b <- function(x) {\n  class(x) <- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n#> [1] \"a2\"\nsloop::s3_dispatch(generic2(structure(list(), class = c(\"b\", \"a2\"))))\n#> => generic2.b\n#> -> generic2.a2\n#>    generic2.default\ngeneric2.b <- function(x) {\n  message(paste0(\"before: \", paste0(.Class, collapse = \", \")))\n  class(x) <- \"a1\"\n  message(paste0(\"after: \", paste0(.Class, collapse = \", \")))\n\n  NextMethod()\n}\n\ninvisible(generic2(structure(list(), class = c(\"b\", \"a2\"))))\n#> before: b, a2\n#> after: b, a2"},{"path":"s3.html","id":"dispatch-details-exercises-13.7.5","chapter":"13 S3","heading":"13.6 Dispatch details (Exercises 13.7.5)","text":"Q1. Explain differences dispatch :A1. differences dispatch due classes arguments:x1 implicit class integer inherits numeric, x2 explicitly assigned class integer.Q2. classes method Math group generic base R? Read source code. methods work?A2. following classes method Math group generic base R:Reading source code methods:Math.factor() Math.Date() provide error message:Math.data.frame() defined follows (except first line code, deliberately added):can surmised code: method checks elements expected type., applies generic (tracked via environment variable .Generic) element list atomic vectors makes data frame:, produces error:Q3. Math.difftime() complicated described. ?A3. Math.difftime() source code looks like following:group generic bit complicated produces error generics, works others.","code":"\nlength.integer <- function(x) 10\n\nx1 <- 1:5\nclass(x1)\n#> [1] \"integer\"\ns3_dispatch(length(x1))\n#>  * length.integer\n#>    length.numeric\n#>    length.default\n#> => length (internal)\n\nx2 <- structure(x1, class = \"integer\")\nclass(x2)\n#> [1] \"integer\"\ns3_dispatch(length(x2))\n#> => length.integer\n#>    length.default\n#>  * length (internal)\ns3_class(x1)\n#> [1] \"integer\" \"numeric\"\n\ns3_class(x2)\n#> [1] \"integer\"\ns3_methods_generic(\"Math\") %>%\n  dplyr::filter(source == \"base\")\n#> # A tibble: 5 × 4\n#>   generic class      visible source\n#>   <chr>   <chr>      <lgl>   <chr> \n#> 1 Math    data.frame TRUE    base  \n#> 2 Math    Date       TRUE    base  \n#> 3 Math    difftime   TRUE    base  \n#> 4 Math    factor     TRUE    base  \n#> 5 Math    POSIXt     TRUE    base\nMath.factor <- function(x, ...) {\n  stop(gettextf(\"%s not meaningful for factors\", sQuote(.Generic)))\n}\n\nMath.Date <- function(x, ...) {\n  stop(gettextf(\"%s not defined for \\\"Date\\\" objects\", .Generic),\n    domain = NA\n  )\n}\nMath.data.frame <- function(x, ...) {\n  message(paste0(\"Environment variable `.Generic` set to: \", .Generic))\n\n  mode.ok <- vapply(x, function(x) {\n    is.numeric(x) || is.logical(x) || is.complex(x)\n  }, NA)\n\n  if (all(mode.ok)) {\n    x[] <- lapply(X = x, FUN = .Generic, ...)\n    return(x)\n  } else {\n    vnames <- names(x)\n    if (is.null(vnames)) vnames <- seq_along(x)\n    stop(\n      \"non-numeric-alike variable(s) in data frame: \",\n      paste(vnames[!mode.ok], collapse = \", \")\n    )\n  }\n}\ndf1 <- data.frame(x = 1:2, y = 3:4)\nsqrt(df1)\n#> Environment variable `.Generic` set to: sqrt\n#>          x        y\n#> 1 1.000000 1.732051\n#> 2 1.414214 2.000000\ndf2 <- data.frame(x = c(TRUE, FALSE), y = c(\"a\", \"b\"))\nabs(df2)\n#> Environment variable `.Generic` set to: abs\n#> Error in Math.data.frame(df2): non-numeric-alike variable(s) in data frame: y\nMath.difftime <- function(x, ...) {\n  switch(.Generic,\n    \"abs\" = ,\n    \"sign\" = ,\n    \"floor\" = ,\n    \"ceiling\" = ,\n    \"trunc\" = ,\n    \"round\" = ,\n    \"signif\" = {\n      units <- attr(x, \"units\")\n      .difftime(NextMethod(), units)\n    },\n    ### otherwise :\n    stop(gettextf(\"'%s' not defined for \\\"difftime\\\" objects\", .Generic),\n      domain = NA\n    )\n  )\n}"},{"path":"s3.html","id":"session-information-10","chapter":"13 S3","heading":"13.7 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  codetools     0.2-20  2024-03-31 [3] CRAN (R 4.4.1)\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  crayon        1.5.3   2024-06-20 [1] RSPM\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr       * 1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  purrr       * 1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  sloop       * 1.0.1   2019-02-17 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tibble        3.2.1   2023-03-20 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"r6.html","id":"r6","chapter":"14 R6","heading":"14 R6","text":"Loading needed libraries:","code":"\nlibrary(R6)"},{"path":"r6.html","id":"classes-and-methods-exercises-14.2.6","chapter":"14 R6","heading":"14.1 Classes and methods (Exercises 14.2.6)","text":"Q1. Create bank account R6 class stores balance allows deposit withdraw money. Create subclass throws error attempt go overdraft. Create another subclass allows go overdraft, charges fee. Create superclass make sure works expected.A1. First, let’s create bank account R6 class stores balance allows deposit withdraw money:Let’s try :Create subclass errors attempt overdraw:Let’s try :Now let’s create subclass charges fee account overdrawn:Let’s try :Q2. Create R6 class represents shuffled deck cards. able draw cards deck $draw(n), return cards deck reshuffle $reshuffle(). Use following code make vector cards.A2. Let’s create needed class represents shuffled deck cards:Let’s try :Q3. can’t model bank account deck cards S3 class?A3. can’t model bank account deck cards S3 class instances classes immutable.hand, R6 classes encapsulate data represent state, can change course object’s lifecycle. words, objects mutable well-suited model bank account.Q4. Create R6 class allows get set current time zone. can access current time zone Sys.timezone() set Sys.setenv(TZ = \"newtimezone\"). setting time zone, make sure new time zone list provided OlsonNames().A4. R6 class manages current time zone:Let’s try :Q5. Create R6 class manages current working directory. $get() $set() methods.A5. R6 class manages current working directory:Let’s create instance class check methods work expected:Q6. can’t model time zone current working directory S3 class?A6. answer Q3:Objects represent real-life entities need mutable S3 class instances mutable.Q7. base type R6 objects built top ? attributes ?A7. Let’s create example class create instance class:R6 objects built top environment:class attribute, character vector \"R6\" last element superclasses elements:","code":"\nlibrary(R6)\n\nbankAccount <- R6::R6Class(\n  \"bankAccount\",\n  public = list(\n    balance = 0,\n    initialize = function(balance) {\n      self$balance <- balance\n    },\n    deposit = function(amount) {\n      self$balance <- self$balance + amount\n      message(paste0(\"Current balance is: \", self$balance))\n      invisible(self)\n    },\n    withdraw = function(amount) {\n      self$balance <- self$balance - amount\n      message(paste0(\"Current balance is: \", self$balance))\n      invisible(self)\n    }\n  )\n)\nindra <- bankAccount$new(balance = 100)\n\nindra$deposit(20)\n#> Current balance is: 120\n\nindra$withdraw(10)\n#> Current balance is: 110\nbankAccountStrict <- R6::R6Class(\n  \"bankAccountStrict\",\n  inherit = bankAccount,\n  public = list(\n    withdraw = function(amount) {\n      if (self$balance - amount < 0) {\n        stop(\n          paste0(\"Can't withdraw more than your current balance: \", self$balance),\n          call. = FALSE\n        )\n      }\n\n      super$withdraw(amount)\n    }\n  )\n)\nPritesh <- bankAccountStrict$new(balance = 100)\n\nPritesh$deposit(20)\n#> Current balance is: 120\n\nPritesh$withdraw(150)\n#> Error: Can't withdraw more than your current balance: 120\nbankAccountFee <- R6::R6Class(\n  \"bankAccountFee\",\n  inherit = bankAccount,\n  public = list(\n    withdraw = function(amount) {\n      super$withdraw(amount)\n\n      if (self$balance) {\n        self$balance <- self$balance - 10\n        message(\"You're withdrawing more than your current balance. You will be charged a fee of 10 euros.\")\n      }\n    }\n  )\n)\nMangesh <- bankAccountFee$new(balance = 100)\n\nMangesh$deposit(20)\n#> Current balance is: 120\n\nMangesh$withdraw(150)\n#> Current balance is: -30\n#> You're withdrawing more than your current balance. You will be charged a fee of 10 euros.\nsuit <- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue <- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste0(rep(value, 4), suit)\nsuit <- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue <- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste(rep(value, 4), suit)\n\nDeck <- R6::R6Class(\n  \"Deck\",\n  public = list(\n    initialize = function(deck) {\n      private$cards <- sample(deck)\n    },\n    draw = function(n) {\n      if (n > length(private$cards)) {\n        stop(\n          paste0(\"Can't draw more than remaining number of cards: \", length(private$cards)),\n          call. = FALSE\n        )\n      }\n\n      drawn_cards <- sample(private$cards, n)\n      private$cards <- private$cards[-which(private$cards %in% drawn_cards)]\n      message(paste0(\"Remaining number of cards: \", length(private$cards)))\n\n      return(drawn_cards)\n    },\n    reshuffle = function() {\n      private$cards <- sample(private$cards)\n      invisible(self)\n    }\n  ),\n  private = list(\n    cards = NULL\n  )\n)\nmyDeck <- Deck$new(cards)\n\nmyDeck$draw(4)\n#> Remaining number of cards: 48\n#> [1] \"2 ♠\"  \"10 ♦\" \"9 ♦\"  \"3 ♦\"\n\nmyDeck$reshuffle()$draw(5)\n#> Remaining number of cards: 43\n#> [1] \"6 ♦\"  \"10 ♥\" \"2 ♥\"  \"A ♥\"  \"8 ♥\"\n\nmyDeck$draw(50)\n#> Error: Can't draw more than remaining number of cards: 43\nCurrentTimeZone <- R6::R6Class(\"CurrentTimeZone\",\n  public = list(\n    setTimeZone = function(tz) {\n      stopifnot(tz %in% OlsonNames())\n      Sys.setenv(TZ = tz)\n    },\n    getTimeZone = function() {\n      Sys.timezone()\n    }\n  )\n)\nmyCurrentTimeZone <- CurrentTimeZone$new()\n\nmyCurrentTimeZone$getTimeZone()\n#> [1] \"UTC\"\n\nmyCurrentTimeZone$setTimeZone(\"Asia/Kolkata\")\nmyCurrentTimeZone$getTimeZone()\n#> [1] \"Asia/Kolkata\"\n\nmyCurrentTimeZone$setTimeZone(\"Europe/Berlin\")\nManageDirectory <- R6::R6Class(\"ManageDirectory\",\n  public = list(\n    setWorkingDirectory = function(dir) {\n      setwd(dir)\n    },\n    getWorkingDirectory = function() {\n      getwd()\n    }\n  )\n)\nmyDirManager <- ManageDirectory$new()\n\n# current working directory\nmyDirManager$getWorkingDirectory()\n\n# change and check if that worked\nmyDirManager$setWorkingDirectory(\"..\")\nmyDirManager$getWorkingDirectory()\n\n# revert this change\nmyDirManager$setWorkingDirectory(\"/Advanced-R-exercises\")\nExample <- R6::R6Class(\"Example\")\nmyExample <- Example$new()\ntypeof(myExample)\n#> [1] \"environment\"\n\nrlang::env_print(myExample)\n#> <environment: 0x55ff34ffedf0> [L]\n#> Parent: <environment: empty>\n#> Class: Example, R6\n#> Bindings:\n#> • .__enclos_env__: <env>\n#> • clone: <fn> [L]\nattributes(myExample)\n#> $class\n#> [1] \"Example\" \"R6\""},{"path":"r6.html","id":"controlling-access-exercises-14.3.3","chapter":"14 R6","heading":"14.2 Controlling access (Exercises 14.3.3)","text":"Q1. Create bank account class prevents directly setting account balance, can still withdraw deposit . Throw error attempt go overdraft.A1. bank account class satisfies specified requirements:Let’s check works expected:Q2. Create class write-$password field. $check_password(password) method returns TRUE FALSE, way view complete password.A2. implementation class needed properties:, course, everything possible:Q3. Extend Rando class another active binding allows access previous random value. Ensure active binding way access value.A3. modified version Rando class meet specified requirements:Let’s try :Q4. Can subclasses access private fields/methods parent? Perform experiment find .A4. Unlike common OOP languages (e.g. C++), R6 subclasses (derived classes) also access private methods superclass (base class).instance, following example, Duck class private method $quack(), subclass Mallard can access using super$quack().","code":"\nSafeBankAccount <- R6::R6Class(\n  classname = \"SafeBankAccount\",\n  public = list(\n    deposit = function(deposit_amount) {\n      private$.balance <- private$.balance + deposit_amount\n      print(paste(\"Current balance:\", private$.balance))\n\n      invisible(self)\n    },\n    withdraw = function(withdrawal_amount) {\n      if (withdrawal_amount > private$.balance) {\n        stop(\"You can't withdraw more than your current balance.\", call. = FALSE)\n      }\n\n      private$.balance <- private$.balance - withdrawal_amount\n      print(paste(\"Current balance:\", private$.balance))\n\n      invisible(self)\n    }\n  ),\n  private = list(\n    .balance = 0\n  )\n)\nmySafeBankAccount <- SafeBankAccount$new()\n\nmySafeBankAccount$deposit(100)\n#> [1] \"Current balance: 100\"\n\nmySafeBankAccount$withdraw(50)\n#> [1] \"Current balance: 50\"\n\nmySafeBankAccount$withdraw(100)\n#> Error: You can't withdraw more than your current balance.\nlibrary(R6)\n\ncheckCredentials <- R6Class(\n  \"checkCredentials\",\n  public = list(\n    # setter\n    set_password = function(password) {\n      private$.password <- password\n    },\n\n    # checker\n    check_password = function(password) {\n      if (is.null(private$.password)) {\n        stop(\"No password set to check against.\")\n      }\n\n      identical(password, private$.password)\n    },\n\n    # the default print method prints the private fields as well\n    print = function() {\n      cat(\"Password: XXXX\")\n\n      # for method chaining\n      invisible(self)\n    }\n  ),\n  private = list(\n    .password = NULL\n  )\n)\n\nmyCheck <- checkCredentials$new()\n\nmyCheck$set_password(\"1234\")\nprint(myCheck)\n#> Password: XXXX\n\nmyCheck$check_password(\"abcd\")\n#> [1] FALSE\nmyCheck$check_password(\"1234\")\n#> [1] TRUE\nmyCheck$.__enclos_env__$private$.password\n#> [1] \"1234\"\nRando <- R6::R6Class(\"Rando\",\n  active = list(\n    random = function(value) {\n      if (missing(value)) {\n        newValue <- runif(1)\n        private$.previousRandom <- private$.currentRandom\n        private$.currentRandom <- newValue\n        return(private$.currentRandom)\n      } else {\n        stop(\"Can't set `$random`\", call. = FALSE)\n      }\n    },\n    previousRandom = function(value) {\n      if (missing(value)) {\n        if (is.null(private$.previousRandom)) {\n          message(\"No random value has been generated yet.\")\n        } else {\n          return(private$.previousRandom)\n        }\n      } else {\n        stop(\"Can't set `$previousRandom`\", call. = FALSE)\n      }\n    }\n  ),\n  private = list(\n    .currentRandom = NULL,\n    .previousRandom = NULL\n  )\n)\nmyRando <- Rando$new()\n\n# first time\nmyRando$random\n#> [1] 0.5549124\nmyRando$previousRandom\n#> No random value has been generated yet.\n#> NULL\n\n# second time\nmyRando$random\n#> [1] 0.3482785\nmyRando$previousRandom\n#> [1] 0.5549124\n\n# third time\nmyRando$random\n#> [1] 0.2187275\nmyRando$previousRandom\n#> [1] 0.3482785\nDuck <- R6Class(\"Duck\",\n  private = list(quack = function() print(\"Quack Quack\"))\n)\n\nMallard <- R6Class(\"Mallard\",\n  inherit = Duck,\n  public = list(quack = function() super$quack())\n)\n\nmyMallard <- Mallard$new()\nmyMallard$quack()\n#> [1] \"Quack Quack\""},{"path":"r6.html","id":"reference-semantics-exercises-14.4.4","chapter":"14 R6","heading":"14.3 Reference semantics (Exercises 14.4.4)","text":"Q1. Create class allows write line specified file. open connection file $initialize(), append line using cat() $append_line(), close connection $finalize().A1. class allows write line specified file:Let’s check works expected:","code":"\nfileEditor <- R6Class(\n  \"fileEditor\",\n  public = list(\n    initialize = function(filePath) {\n      private$.connection <- file(filePath, open = \"wt\")\n    },\n    append_line = function(text) {\n      cat(\n        text,\n        file = private$.connection,\n        sep = \"\\n\",\n        append = TRUE\n      )\n    }\n  ),\n  private = list(\n    .connection = NULL,\n    # according to R6 docs, the destructor method should be private\n    finalize = function() {\n      print(\"Closing the file connection!\")\n      close(private$.connection)\n    }\n  )\n)\ngreetMom <- function() {\n  f <- tempfile()\n  myfileEditor <- fileEditor$new(f)\n\n  readLines(f)\n\n  myfileEditor$append_line(\"Hi mom!\")\n  myfileEditor$append_line(\"It's a beautiful day!\")\n\n  readLines(f)\n}\n\ngreetMom()\n#> [1] \"Hi mom!\"               \"It's a beautiful day!\"\n\n# force garbage collection\ngc()\n#> [1] \"Closing the file connection!\"\n#>           used (Mb) gc trigger (Mb) max used (Mb)\n#> Ncells  760795 40.7    1422437   76  1422437 76.0\n#> Vcells 1393549 10.7    8388608   64  3041600 23.3"},{"path":"r6.html","id":"session-information-11","chapter":"14 R6","heading":"14.4 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       Europe/Berlin\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  R6          * 2.5.1   2021-08-19 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"s4.html","id":"s4","chapter":"15 S4","heading":"15 S4","text":"","code":""},{"path":"s4.html","id":"basics-exercises-15.2.1","chapter":"15 S4","heading":"15.1 Basics (Exercises 15.2.1)","text":"Q1. lubridate::period() returns S4 class. slots ? class slot? accessors provide?A1. Let’s first create instance Period class:following slots:Additionally, base type slot (numeric) can seen str() output:lubridate package provides accessors slots:Q2. ways can find help method? Read ?\"?\" summarise details.A2. \"?\" operator allows access documentation three ways. demonstrate different ways access documentation, let’s define new S4 class.Ways access documentation:general documentation generic can found ?topic:expression type?topic look overall documentation methods function f.","code":"\nlibrary(lubridate)\nx <- lubridate::period(c(2, 43, 6), c(\"hour\", \"second\", \"minute\"))\nx\n#> [1] \"2H 6M 43S\"\nslotNames(x)\n#> [1] \".Data\"  \"year\"   \"month\"  \"day\"    \"hour\"   \"minute\"\nstr(x)\n#> Formal class 'Period' [package \"lubridate\"] with 6 slots\n#>   ..@ .Data : num 43\n#>   ..@ year  : num 0\n#>   ..@ month : num 0\n#>   ..@ day   : num 0\n#>   ..@ hour  : num 2\n#>   ..@ minute: num 6\nyear(x)\n#> [1] 0\nmonth(x)\n#> [1] 0\nday(x)\n#> [1] 0\nhour(x)\n#> [1] 2\nminute(x)\n#> [1] 6\nsecond(x)\n#> [1] 43\npow <- function(x, exp) c(x, exp)\nsetGeneric(\"pow\")\n#> [1] \"pow\"\nsetMethod(\"pow\", c(\"numeric\", \"numeric\"), function(x, exp) x^exp)\n?pow\n?pow # produces the function documentation\n\nmethods?pow # looks for the overall methods documentation"},{"path":"s4.html","id":"classes-exercises-15.3.6","chapter":"15 S4","heading":"15.2 Classes (Exercises 15.3.6)","text":"Q1. Extend Person class fields match utils::person(). Think slots need, class slot , ’ll need check validity method.A1. code extends Person class described book match closely utils::person().Let’s make sure validation works expected:Q2. happens define new S4 class doesn’t slots? (Hint: read virtual classes ?setClass.)A2. define new S4 class doesn’t slots, create virtual classes:can’t create instance class:useful? mentioned ?setClass docs:Classes exist actual objects can created, virtual classes.common useful form virtual class class union, virtual class defined call setClassUnion() rather call setClass().virtual classes can still inherited:addition specifying slots, another way create virtual classes:Calls setClass() also create virtual class, either Class argument supplied (slots superclasses) contains= argument includes special class name \"VIRTUAL\".Q3. Imagine going reimplement factors, dates, data frames S4. Sketch setClass() calls use define classes. Think appropriate slots prototype.A3. reimplementation following classes S4 might definitions like following.factorFor simplicity, won’t provide options factor() provides. Note x pseudo-class accept objects type.DateJust like base-R version, integer values.data.frameThe tricky part supporting ... argument data.frame(). , can let users pass (named) list.","code":"\nsetClass(\"Person\",\n  slots = c(\n    age     = \"numeric\",\n    given   = \"character\",\n    family  = \"character\",\n    middle  = \"character\",\n    email   = \"character\",\n    role    = \"character\",\n    comment = \"character\"\n  ),\n  prototype = list(\n    age     = NA_real_,\n    given   = NA_character_,\n    family  = NA_character_,\n    middle  = NA_character_,\n    email   = NA_character_,\n    role    = NA_character_,\n    comment = NA_character_\n  )\n)\n\n# Helper function to create an instance of the `Person` class\nPerson <- function(given,\n                   family,\n                   middle = NA_character_,\n                   age = NA_real_,\n                   email = NA_character_,\n                   role = NA_character_,\n                   comment = NA_character_) {\n  age <- as.double(age)\n\n  new(\"Person\",\n    age     = age,\n    given   = given,\n    family  = family,\n    middle  = middle,\n    email   = email,\n    role    = role,\n    comment = comment\n  )\n}\n\n# Validator to ensure that each slot is of length one and that the specified\n# role is one of the possible roles\nsetValidity(\"Person\", function(object) {\n  invalid_length <- NULL\n  slot_lengths <- c(\n    length(object@age),\n    length(object@given),\n    length(object@middle),\n    length(object@family),\n    length(object@email),\n    length(object@comment)\n  )\n\n  if (any(slot_lengths > 1L)) {\n    invalid_length <- \"\\nFollowing slots must be of length 1:\\n @age, @given, @family, @middle, @email, @comment\"\n  }\n\n  possible_roles <- c(\n    NA_character_, \"aut\", \"com\", \"cph\", \"cre\", \"ctb\", \"ctr\", \"dtc\", \"fnd\", \"rev\", \"ths\", \"trl\"\n  )\n\n  if (any(!object@role %in% possible_roles)) {\n    invalid_length <- paste(\n      invalid_length,\n      \"\\nSlot @role(s) must be one of the following:\\n\",\n      paste(possible_roles, collapse = \", \")\n    )\n  }\n\n  if (!is.null(invalid_length)) {\n    return(invalid_length)\n  } else {\n    return(TRUE)\n  }\n})\n#> Class \"Person\" [in \".GlobalEnv\"]\n#> \n#> Slots:\n#>                                                         \n#> Name:        age     given    family    middle     email\n#> Class:   numeric character character character character\n#>                           \n#> Name:       role   comment\n#> Class: character character\n# length of first argument not 1\nPerson(c(\"Indrajeet\", \"Surendra\"), \"Patil\")\n#> Error in validObject(.Object): invalid class \"Person\" object: \n#> Following slots must be of length 1:\n#>  @age, @given, @family, @middle, @email, @comment\n\n# role not recognized\nPerson(\"Indrajeet\", \"Patil\", role = \"xyz\")\n#> Error in validObject(.Object): invalid class \"Person\" object:  \n#> Slot @role(s) must be one of the following:\n#>  NA, aut, com, cph, cre, ctb, ctr, dtc, fnd, rev, ths, trl\n\n# all okay\nPerson(\"Indrajeet\", \"Patil\", role = c(\"aut\", \"cph\"))\n#> An object of class \"Person\"\n#> Slot \"age\":\n#> [1] NA\n#> \n#> Slot \"given\":\n#> [1] \"Indrajeet\"\n#> \n#> Slot \"family\":\n#> [1] \"Patil\"\n#> \n#> Slot \"middle\":\n#> [1] NA\n#> \n#> Slot \"email\":\n#> [1] NA\n#> \n#> Slot \"role\":\n#> [1] \"aut\" \"cph\"\n#> \n#> Slot \"comment\":\n#> [1] NA\nsetClass(\"Empty\")\n\nisVirtualClass(\"Empty\")\n#> [1] TRUE\nnew(\"Empty\")\n#> Error in new(\"Empty\"): trying to generate an object from a virtual class (\"Empty\")\nsetClass(\"Nothing\", contains = \"Empty\")\nsetClass(\"Factor\",\n  slots = c(\n    x       = \"ANY\",\n    levels  = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = list(\n    x       = character(),\n    levels  = character(),\n    ordered = FALSE\n  )\n)\n\nnew(\"Factor\", x = letters[1:3], levels = LETTERS[1:3])\n#> An object of class \"Factor\"\n#> Slot \"x\":\n#> [1] \"a\" \"b\" \"c\"\n#> \n#> Slot \"levels\":\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> Slot \"ordered\":\n#> [1] FALSE\n\nnew(\"Factor\", x = 1:3, levels = letters[1:3])\n#> An object of class \"Factor\"\n#> Slot \"x\":\n#> [1] 1 2 3\n#> \n#> Slot \"levels\":\n#> [1] \"a\" \"b\" \"c\"\n#> \n#> Slot \"ordered\":\n#> [1] FALSE\n\nnew(\"Factor\", x = c(TRUE, FALSE, TRUE), levels = c(\"x\", \"y\", \"x\"))\n#> An object of class \"Factor\"\n#> Slot \"x\":\n#> [1]  TRUE FALSE  TRUE\n#> \n#> Slot \"levels\":\n#> [1] \"x\" \"y\" \"x\"\n#> \n#> Slot \"ordered\":\n#> [1] FALSE\nsetClass(\"Date2\",\n  slots = list(\n    data = \"integer\"\n  ),\n  prototype = list(\n    data = integer()\n  )\n)\n\nnew(\"Date2\", data = 1342L)\n#> An object of class \"Date2\"\n#> Slot \"data\":\n#> [1] 1342\nsetClass(\"DataFrame\",\n  slots = c(\n    data      = \"list\",\n    row.names = \"character\"\n  ),\n  prototype = list(\n    data      = list(),\n    row.names = character(0L)\n  )\n)\n\nnew(\"DataFrame\", data = list(x = c(\"a\", \"b\"), y = c(1L, 2L)))\n#> An object of class \"DataFrame\"\n#> Slot \"data\":\n#> $x\n#> [1] \"a\" \"b\"\n#> \n#> $y\n#> [1] 1 2\n#> \n#> \n#> Slot \"row.names\":\n#> character(0)"},{"path":"s4.html","id":"generics-and-methods-exercises-15.4.5","chapter":"15 S4","heading":"15.3 Generics and methods (Exercises 15.4.5)","text":"Q1. Add age() accessors Person class.A1. first define generic method class:Q2. definition generic, necessary repeat name generic twice?A2. Let’s look generic just defined; generic name \"age\" repeated twice.:\"age\" passed argument name provides name genericthe \"age\" passed argument def supplies method dispatchThis reminiscent defined S3 generic, also repeat name twice:Q3. show() method defined Section Show method use (object)[[1]]? (Hint: try printing employee subclass.)A3. wish define show() method specific class, need disregard super-/sub-classes.Always using first element ensures method defined class question:Q4. happens define method different argument names generic?A4. Let’s experiment method defined Q1. study behavior.original method worked expected since argument name generic method matched:case, either get warning get error depending many arguments specified:","code":"\nIndra <- Person(\"Indrajeet\", \"Patil\", role = c(\"aut\", \"cph\"), age = 34)\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\n#> [1] \"age\"\nsetMethod(\"age\", \"Person\", function(x) x@age)\n\nage(Indra)\n#> [1] 34\nsetGeneric(name = \"age\", def = function(x) standardGeneric(\"age\"))\nage <- function(x) {\n  UseMethod(\"age\")\n}\nAlice <- new(\"Employee\")\n\nis(Alice)\n#> [1] \"Employee\" \"Person\"\n\nis(Alice)[[1]]\n#> [1] \"Employee\"\nsetMethod(\"age\", \"Person\", function(x) x@age)\nsetMethod(\"age\", \"Person\", function(object) object@age)\n#> Warning: For function 'age', signature 'Person': argument\n#> in method definition changed from (object) to (x)\n\nsetMethod(\"age\", \"Person\", function(object, x) object@age)\n#> Error in rematchDefinition(definition, fdef, mnames, fnames, signature): methods can add arguments to the generic 'age' only if '...' is an argument to the generic\n\nsetMethod(\"age\", \"Person\", function(...) ...elt(1)@age)\n#> Warning: For function 'age', signature 'Person': argument\n#> in method definition changed from (...) to (x)\n\nsetMethod(\"age\", \"Person\", function(x, ...) x@age)\n#> Error in rematchDefinition(definition, fdef, mnames, fnames, signature): methods can add arguments to the generic 'age' only if '...' is an argument to the generic"},{"path":"s4.html","id":"method-dispatch-exercises-15.5.5","chapter":"15 S4","heading":"15.4 Method dispatch (Exercises 15.5.5)","text":"Q1. Draw method graph f(😅, 😽).A1. don’t prepare visual illustrations used book, linking illustration official solution manual:Q2. Draw method graph f(😃, 😉, 😙).A2. don’t prepare visual illustrations used book, linking illustration official solution manual:Q3. Take last example shows multiple dispatch two classes use multiple inheritance. happens define method terminal classes? method dispatch save us much work ?A3. one class distance 2 terminal nodes four distance 1 two terminal nodes , introduce ambiguity.Method dispatch save us much work resolve ambiguity define five methods (one per class combination).","code":""},{"path":"s4.html","id":"s4-and-s3-exercises-15.6.3","chapter":"15 S4","heading":"15.5 S4 and S3 (Exercises 15.6.3)","text":"Q1. full setOldClass() definition look like ordered factor (.e. add slots prototype definition )?A1. can register old-style/S3 ordered class formally defined class using setOldClass().Let’s use see works expected.Q2. Define length method Person class.A2. Person class can used create objects represent multiple people, let’s say length() method returns many persons object.can define S3 method class:Alternatively, can also write S4 method:","code":"\nsetClass(\"factor\",\n  contains = \"integer\",\n  slots = c(\n    levels = \"character\"\n  ),\n  prototype = structure(\n    integer(),\n    levels = character()\n  )\n)\nsetOldClass(\"factor\", S4Class = \"factor\")\n#> Warning in rm(list = what, pos = classWhere): object\n#> '.__C__factor' not found\n\nsetClass(\"Ordered\",\n  contains = \"factor\",\n  slots = c(\n    levels  = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = structure(\n    integer(),\n    levels  = character(),\n    ordered = logical()\n  )\n)\n\nsetOldClass(\"ordered\", S4Class = \"Ordered\")\nx <- new(\"Ordered\", 1L:4L, levels = letters[1:4], ordered = TRUE)\n\nx\n#> Object of class \"Ordered\"\n#> [1] a b c d\n#> Levels: a b c d\n#> Slot \"ordered\":\n#> [1] TRUE\n\nstr(x)\n#> Formal class 'Ordered' [package \".GlobalEnv\"] with 4 slots\n#>   ..@ .Data   : int [1:4] 1 2 3 4\n#>   ..@ levels  : chr [1:4] \"a\" \"b\" \"c\" \"d\"\n#>   ..@ ordered : logi TRUE\n#>   ..@ .S3Class: chr \"factor\"\n\nclass(x)\n#> [1] \"Ordered\"\n#> attr(,\"package\")\n#> [1] \".GlobalEnv\"\nFriends <- new(\"Person\", name = c(\"Vishu\", \"Aditi\"))\nlength.Person <- function(x) length(x@name)\n\nlength(Friends)\n#> [1] 2\nsetMethod(\"length\", \"Person\", function(x) length(x@name))\n\nlength(Friends)\n#> [1] 2"},{"path":"s4.html","id":"session-information-12","chapter":"15 S4","heading":"15.6 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version    date (UTC) lib source\n#>  assertthat    0.2.1      2019-03-21 [1] RSPM\n#>  base        * 4.4.1      2024-08-22 [3] local\n#>  bookdown      0.40       2024-07-02 [1] RSPM\n#>  bslib         0.8.0      2024-07-29 [1] RSPM\n#>  cachem        1.1.0      2024-05-16 [1] RSPM\n#>  cli           3.6.3      2024-06-21 [1] RSPM\n#>  compiler      4.4.1      2024-08-22 [3] local\n#>  crayon        1.5.3      2024-06-20 [1] RSPM\n#>  datasets    * 4.4.1      2024-08-22 [3] local\n#>  digest        0.6.37     2024-08-19 [1] RSPM\n#>  downlit       0.4.4      2024-06-10 [1] RSPM\n#>  emo           0.0.0.9000 2024-09-22 [1] Github (hadley/emo@3f03b11)\n#>  evaluate      1.0.0      2024-09-17 [1] RSPM\n#>  fastmap       1.2.0      2024-05-15 [1] RSPM\n#>  fs            1.6.4      2024-04-25 [1] RSPM\n#>  generics      0.1.3      2022-07-05 [1] RSPM\n#>  glue          1.8.0      2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1      2024-08-22 [3] local\n#>  grDevices   * 4.4.1      2024-08-22 [3] local\n#>  highr         0.11       2024-05-26 [1] RSPM\n#>  htmltools     0.5.8.1    2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4      2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9      2024-09-20 [1] RSPM\n#>  knitr         1.48       2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4      2023-11-07 [1] RSPM\n#>  lubridate   * 1.9.3      2023-09-27 [1] RSPM\n#>  magrittr    * 2.0.3      2022-03-30 [1] RSPM\n#>  memoise       2.0.1      2021-11-26 [1] RSPM\n#>  methods     * 4.4.1      2024-08-22 [3] local\n#>  purrr         1.0.2      2023-08-10 [1] RSPM\n#>  R6            2.5.1      2021-08-19 [1] RSPM\n#>  rlang         1.1.4      2024-06-04 [1] RSPM\n#>  rmarkdown     2.28       2024-08-17 [1] RSPM\n#>  sass          0.4.9      2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2      2021-12-06 [1] RSPM\n#>  stats       * 4.4.1      2024-08-22 [3] local\n#>  stringi       1.8.4      2024-05-06 [1] RSPM\n#>  stringr       1.5.1      2023-11-14 [1] RSPM\n#>  timechange    0.3.0      2024-01-18 [1] RSPM\n#>  tools         4.4.1      2024-08-22 [3] local\n#>  utils       * 4.4.1      2024-08-22 [3] local\n#>  vctrs         0.6.5      2023-12-01 [1] RSPM\n#>  withr         3.0.1      2024-07-31 [1] RSPM\n#>  xfun          0.47       2024-08-17 [1] RSPM\n#>  xml2          1.3.6      2023-12-04 [1] RSPM\n#>  yaml          2.3.10     2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"trade-offs.html","id":"trade-offs","chapter":"16 Trade-offs","heading":"16 Trade-offs","text":"exercises.","code":""},{"path":"big-picture.html","id":"big-picture","chapter":"17 Big Picture","heading":"17 Big Picture","text":"exercises.","code":""},{"path":"expressions.html","id":"expressions","chapter":"18 Expressions","heading":"18 Expressions","text":"Attaching needed libraries:","code":"\nlibrary(rlang, warn.conflicts = FALSE)\nlibrary(lobstr, warn.conflicts = FALSE)"},{"path":"expressions.html","id":"abstract-syntax-trees-exercises-18.2.4","chapter":"18 Expressions","heading":"18.1 Abstract syntax trees (Exercises 18.2.4)","text":"Q1. Reconstruct code represented trees :A1. reconstructed code.can confirm drawing ASTs :Q2. Draw following trees hand check answers ast().A2. Successfully drawn hand. Checking using ast():Q3. ’s happening ASTs ? (Hint: carefully read ?\"^\".)A3. str2expression() helps make sense ASTs.non-syntactic names parsed names. Thus, backticks removed AST.mentioned docs ^:** translated parser ^rightward assignment parsed leftward assignment:Q4. special AST ?A4. mentioned section:Like objects R, functions can also possess number additional attributes(). One attribute used base R srcref, short source reference. points source code used create function. srcref used printing , unlike body(), contains code comments formatting.Therefore, last leaf AST, although specified function call, represents source reference attribute.Q5. call tree statement multiple else conditions look like? ?A5. nothing special tree. just shows nested loop structure inherent code multiple else statements.","code":"#> █─f \n#> └─█─g \n#>   └─█─h\n#> █─`+` \n#> ├─█─`+` \n#> │ ├─1 \n#> │ └─2 \n#> └─3\n#> █─`*` \n#> ├─█─`(` \n#> │ └─█─`+` \n#> │   ├─x \n#> │   └─y \n#> └─z\nf(g(h()))\n1 + 2 + 3\n(x + y) * z\nast(f(g(h())))\n#> █─f \n#> └─█─g \n#>   └─█─h\n\nast(1 + 2 + 3)\n#> █─`+` \n#> ├─█─`+` \n#> │ ├─1 \n#> │ └─2 \n#> └─3\n\nast((x + y) * z)\n#> █─`*` \n#> ├─█─`(` \n#> │ └─█─`+` \n#> │   ├─x \n#> │   └─y \n#> └─z\nf(g(h(i(1, 2, 3))))\nf(1, g(2, h(3, i())))\nf(g(1, 2), h(3, i(4, 5)))\nast(f(g(h(i(1, 2, 3)))))\n#> █─f \n#> └─█─g \n#>   └─█─h \n#>     └─█─i \n#>       ├─1 \n#>       ├─2 \n#>       └─3\n\nast(f(1, g(2, h(3, i()))))\n#> █─f \n#> ├─1 \n#> └─█─g \n#>   ├─2 \n#>   └─█─h \n#>     ├─3 \n#>     └─█─i\n\nast(f(g(1, 2), h(3, i(4, 5))))\n#> █─f \n#> ├─█─g \n#> │ ├─1 \n#> │ └─2 \n#> └─█─h \n#>   ├─3 \n#>   └─█─i \n#>     ├─4 \n#>     └─5\nast(`x` + `y`)\n#> █─`+` \n#> ├─x \n#> └─y\nast(x**y)\n#> █─`^` \n#> ├─x \n#> └─y\nast(1 -> x)\n#> █─`<-` \n#> ├─x \n#> └─1\nstr2expression(\"`x` + `y`\")\n#> expression(x + y)\nstr2expression(\"x**y\")\n#> expression(x^y)\nstr2expression(\"1 -> x\")\n#> expression(x <- 1)\nast(function(x = 1, y = 2) {})\n#> █─`function` \n#> ├─█─x = 1 \n#> │ └─y = 2 \n#> ├─█─`{` \n#> └─NULL\nast(if (FALSE) 1 else if (FALSE) 2 else if (FALSE) 3 else 4)\n#> █─`if` \n#> ├─FALSE \n#> ├─1 \n#> └─█─`if` \n#>   ├─FALSE \n#>   ├─2 \n#>   └─█─`if` \n#>     ├─FALSE \n#>     ├─3 \n#>     └─4"},{"path":"expressions.html","id":"expressions-exercises-18.3.5","chapter":"18 Expressions","heading":"18.2 Expressions (Exercises 18.3.5)","text":"Q1. two six types atomic vector can’t appear expression? ? Similarly, can’t create expression contains atomic vector length greater one?A1. six types atomic vectors, two can’t appear expression : complex raw.Complex numbers created via function call (using +), can seen AST:Similarly, raw vectors (using raw()):Contrast atomic vectors:reason, can’t create expression contains atomic vector length greater one since function call uses c() function:Q2. happens subset call object remove first element? e.g. expr(read.csv(\"foo.csv\", header = TRUE))[-1]. ?A2. captured function call like following creates call object:mentioned respective section:first element call object function position.Therefore, first element call object removed, next one moves function position, get observed output:Q3. Describe differences following call objects.A4. differences constructed call objects due different type arguments supplied first two parameters call2() function.Types arguments supplied .fn:Types arguments supplied dynamic dots:following outputs can understood using following properties:.fn argument closure, function inlined constructed function callwhen x symbol, value passed function callImportantly, constructed call objects evaluate give result:Q4. call_standardise() doesn’t work well following calls. ? makes mean() special?A4. ellipsis mean() function signature:mentioned respective section:function uses ... ’s possible standardise arguments.mean() S3 generic dots passed underlying S3 methods., output can improved using specific method. example:Q5. code make sense?A5. doesn’t make sense first position call object reserved function (function position), assigning names element just ignored R:Q6. Construct expression (x > 1) \"\" else \"b\" using multiple calls call2(). code structure reflect structure AST?A6. Using multiple calls construct required expression:construction follows prefix form expression, revealed AST:","code":"\nx_complex <- expr(1 + 1i)\ntypeof(x_complex)\n#> [1] \"language\"\n\nast(1 + 1i)\n#> █─`+` \n#> ├─1 \n#> └─1i\nx_raw <- expr(raw(2))\ntypeof(x_raw)\n#> [1] \"language\"\n\nast(raw(2))\n#> █─raw \n#> └─2\nx_int <- expr(2L)\ntypeof(x_int)\n#> [1] \"integer\"\n\nast(2L)\n#> 2L\nx_vec <- expr(c(1, 2))\ntypeof(x_vec)\n#> [1] \"language\"\n\nast(c(1, 2))\n#> █─c \n#> ├─1 \n#> └─2\nexpr(read.csv(\"foo.csv\", header = TRUE))\n#> read.csv(\"foo.csv\", header = TRUE)\n\ntypeof(expr(read.csv(\"foo.csv\", header = TRUE)))\n#> [1] \"language\"\nexpr(read.csv(\"foo.csv\", header = TRUE))[-1]\n#> \"foo.csv\"(header = TRUE)\nx <- 1:10\ncall2(median, x, na.rm = TRUE)\ncall2(expr(median), x, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\ncall2(expr(median), expr(x), na.rm = TRUE)\ntypeof(median)\n#> [1] \"closure\"\ntypeof(expr(median))\n#> [1] \"symbol\"\nx <- 1:10\ntypeof(x)\n#> [1] \"integer\"\ntypeof(expr(x))\n#> [1] \"symbol\"\nx <- 1:10\n\ncall2(median, x, na.rm = TRUE)\n#> (function (x, na.rm = FALSE, ...) \n#> UseMethod(\"median\"))(1:10, na.rm = TRUE)\n\ncall2(expr(median), x, na.rm = TRUE)\n#> median(1:10, na.rm = TRUE)\n\ncall2(median, expr(x), na.rm = TRUE)\n#> (function (x, na.rm = FALSE, ...) \n#> UseMethod(\"median\"))(x, na.rm = TRUE)\n\ncall2(expr(median), expr(x), na.rm = TRUE)\n#> median(x, na.rm = TRUE)\nx <- 1:10\n\neval(call2(median, x, na.rm = TRUE))\n#> [1] 5.5\n\neval(call2(expr(median), x, na.rm = TRUE))\n#> [1] 5.5\n\neval(call2(median, expr(x), na.rm = TRUE))\n#> [1] 5.5\n\neval(call2(expr(median), expr(x), na.rm = TRUE))\n#> [1] 5.5\ncall_standardise(quote(mean(1:10, na.rm = TRUE)))\n#> Warning: `call_standardise()` is deprecated as of rlang 0.4.11\n#> This warning is displayed once every 8 hours.\n#> mean(x = 1:10, na.rm = TRUE)\ncall_standardise(quote(mean(n = T, 1:10)))\n#> mean(x = 1:10, n = T)\ncall_standardise(quote(mean(x = 1:10, , TRUE)))\n#> mean(x = 1:10, , TRUE)\nmean\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x55d78b417820>\n#> <environment: namespace:base>\ncall_standardise(quote(mean.default(n = T, 1:10)))\n#> mean.default(x = 1:10, na.rm = T)\nx <- expr(foo(x = 1))\nnames(x) <- c(\"x\", \"y\")\nx <- expr(foo(x = 1))\nx\n#> foo(x = 1)\n\nnames(x) <- c(\"x\", \"y\")\nx\n#> foo(y = 1)\nx <- 5\ncall_obj1 <- call2(\">\", expr(x), 1)\ncall_obj1\n#> x > 1\n\ncall_obj2 <- call2(\"if\", cond = call_obj1, cons.expr = \"a\", alt.expr = \"b\")\ncall_obj2\n#> if (x > 1) \"a\" else \"b\"\nast(if (x > 1) \"a\" else \"b\")\n#> █─`if` \n#> ├─█─`>` \n#> │ ├─x \n#> │ └─1 \n#> ├─\"a\" \n#> └─\"b\""},{"path":"expressions.html","id":"parsing-and-grammar-exercises-18.4.4","chapter":"18 Expressions","heading":"18.3 Parsing and grammar (Exercises 18.4.4)","text":"Q1. R uses parentheses two slightly different ways illustrated two calls:Compare contrast two uses referencing AST.A1. Let’s first look AST:, can see ( used two separate ways:function right \"`(`\"part prefix syntax (f()), AST f((1)), see one \"`(`\" (first use case), f(), part function syntax (second use case).Q2. = can also used two ways. Construct simple example shows uses.A2. simple example illustrating = can also used two ways:assignmentfor named arguments function callsWe can also look AST:Q3. -2^2 yield 4 -4? ?A3. expression -2^2 evaluates -4 operator ^ higher precedence unary - operator:can also seen AST:less confusing way write :Q4. !1 + !1 return? ?A3. expression !1 + !1 evaluates FALSE.! operator higher precedence unary + operator. Thus, !1 evaluates FALSE, added 1 + FALSE, evaluates 1, logically negated !1, FALSE.can easily seen AST:Q5. x1 <- x2 <- x3 <- 0 work? Describe two reasons.A5. two reasons following works expected:<- operator right associative.Therefore, order assignment :<- operator invisibly returns assigned value.easy surmise AST:Q6. Compare ASTs x + y %+% z x ^ y %+% z. learned precedence custom infix functions?A6. Looking ASTs expressions,can say custom infix operator %+% :higher precedence + operatorlower precedence ^ operatorQ7. happens call parse_expr() string generates multiple expressions? e.g. parse_expr(\"x + 1; y + 1\")A7. produced error:expected based docs:parse_expr() returns one expression. text contains one expression (separated semicolons new lines), error issued.instead need use parse_exprs():Q8. happens attempt parse invalid expression? e.g. \"+\" \"f())\".A8. invalid expression produces error:Since underlying parse() function produces error:Q9. deparse() produces vectors input long. example, following call produces vector length two:expr_text() instead?A9. difference deparse() expr_text() latter turns (possibly multi-line) expression single string.Q10. pairwise.t.test() assumes deparse() always returns length one character vector. Can construct input violates expectation? happens?A10 Since R 4.0, possible violate expectation since new implementation produces single string matter input:New function deparse1() produces one string, wrapping deparse(), used typically deparse1(substitute(*))","code":"\nf((1))\n`(`(1 + 1)\nast(f((1)))\n#> █─f \n#> └─█─`(` \n#>   └─1\nast(`(`(1 + 1))\n#> █─`(` \n#> └─█─`+` \n#>   ├─1 \n#>   └─1\nm <- mean(x = 1)\nast({\n  m <- mean(x = 1)\n})\n#> █─`{` \n#> └─█─`<-` \n#>   ├─m \n#>   └─█─mean \n#>     └─x = 1\n-2^2\n#> [1] -4\nast(-2^2)\n#> █─`-` \n#> └─█─`^` \n#>   ├─2 \n#>   └─2\n-(2^2)\n#> [1] -4\nast(!1 + !1)\n#> █─`!` \n#> └─█─`+` \n#>   ├─1 \n#>   └─█─`!` \n#>     └─1\nx1 <- x2 <- x3 <- 0\n(x3 <- 0)\n(x2 <- x3)\n(x1 <- x2)\n(x <- 1)\n#> [1] 1\nast(x1 <- x2 <- x3 <- 0)\n#> █─`<-` \n#> ├─x1 \n#> └─█─`<-` \n#>   ├─x2 \n#>   └─█─`<-` \n#>     ├─x3 \n#>     └─0\nast(x + y %+% z)\n#> █─`+` \n#> ├─x \n#> └─█─`%+%` \n#>   ├─y \n#>   └─z\n\nast(x^y %+% z)\n#> █─`%+%` \n#> ├─█─`^` \n#> │ ├─x \n#> │ └─y \n#> └─z\nparse_expr(\"x + 1; y + 1\")\n#> Error in `parse_expr()`:\n#> ! `x` must contain exactly 1 expression, not 2.\nparse_exprs(\"x + 1; y + 1\")\n#> [[1]]\n#> x + 1\n#> \n#> [[2]]\n#> y + 1\nparse_expr(\"a +\")\n#> Error in parse(text = x, keep.source = FALSE): <text>:2:0: unexpected end of input\n#> 1: a +\n#>    ^\n\nparse_expr(\"f())\")\n#> Error in parse(text = x, keep.source = FALSE): <text>:1:4: unexpected ')'\n#> 1: f())\n#>        ^\nparse(text = \"a +\")\n#> Error in parse(text = \"a +\"): <text>:2:0: unexpected end of input\n#> 1: a +\n#>    ^\n\nparse(text = \"f())\")\n#> Error in parse(text = \"f())\"): <text>:1:4: unexpected ')'\n#> 1: f())\n#>        ^\nexpr <- expr(g(a + b + c + d + e + f + g + h + i + j + k + l +\n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\ndeparse(expr)\nexpr <- expr(g(a + b + c + d + e + f + g + h + i + j + k + l +\n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\n\ndeparse(expr)\n#> [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + \"\n#> [2] \"    p + q + r + s + t + u + v + w + x + y + z)\"\n\nexpr_text(expr)\n#> [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + \\n    p + q + r + s + t + u + v + w + x + y + z)\""},{"path":"expressions.html","id":"walking-ast-with-recursive-functions-exercises-18.5.3","chapter":"18 Expressions","heading":"18.4 Walking AST with recursive functions (Exercises 18.5.3)","text":"Q1. logical_abbr() returns TRUE T(1, 2, 3). modify logical_abbr_rec() ignores function calls use T F?A1. avoid function calls use T F, just need ignore function position call objects:Let’s try :Q2. logical_abbr() works expressions. currently fails give function. ? modify logical_abbr() make work? components function need recurse ?A2. Surprisingly, logical_abbr() currently doesn’t fail closures:see , let’s see type object produced capture user provided closure:Given closures converted call objects, surprise function works:function fails can’t find negative case. example, instead returning FALSE, produces error reasons remain (yet) elusive :Q3. Modify find_assign also detect assignment using replacement functions, .e. names(x) <- y.A3. Although simple assignment (x <- y) assignment using replacement functions (names(x) <- y) <- operator call, latter case, names(x) call object symbol:’s can detect kind assignment checking second element expression symbol language type object.Let’s try :Q4. Write function extracts calls specified function.A4. function extracts calls specified function:","code":"\nlogical_abbr_rec(expr(T(1, 2, 3)))\n#> [1] FALSE\n\nlogical_abbr_rec(expr(F(1, 2, 3)))\n#> [1] FALSE\n\nlogical_abbr_rec(expr(T))\n#> [1] TRUE\n\nlogical_abbr_rec(expr(F))\n#> [1] TRUE\nlogical_abbr(function(x = TRUE) {\n  g(x + T)\n})\nprint_enexpr <- function(.f) {\n  print(typeof(enexpr(.f)))\n  print(is.call(enexpr(.f)))\n}\n\nprint_enexpr(function(x = TRUE) {\n  g(x + T)\n})\n#> [1] \"language\"\n#> [1] TRUE\nlogical_abbr(function(x = TRUE) {\n  g(x + T)\n})\n#> [1] TRUE\nlogical_abbr(function(x = TRUE) {\n  g(x + TRUE)\n})\n#> [1] FALSE\nexpr1 <- expr(names(x) <- y)\nas.list(expr1)\n#> [[1]]\n#> `<-`\n#> \n#> [[2]]\n#> names(x)\n#> \n#> [[3]]\n#> y\ntypeof(expr1[[2]])\n#> [1] \"language\"\n\nexpr2 <- expr(x <- y)\nas.list(expr2)\n#> [[1]]\n#> `<-`\n#> \n#> [[2]]\n#> x\n#> \n#> [[3]]\n#> y\ntypeof(expr2[[2]])\n#> [1] \"symbol\"\nexpr_type <- function(x) {\n  if (is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\nswitch_expr <- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}\n\nflat_map_chr <- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nextract_symbol <- function(x) {\n  if (is_symbol(x[[2]])) {\n    as_string(x[[2]])\n  } else {\n    extract_symbol(as.list(x[[2]]))\n  }\n}\n\nfind_assign_call <- function(x) {\n  if (is_call(x, \"<-\") && is_symbol(x[[2]])) {\n    lhs <- as_string(x[[2]])\n    children <- as.list(x)[-1]\n  } else if (is_call(x, \"<-\") && is_call(x[[2]])) {\n    lhs <- extract_symbol(as.list(x[[2]]))\n    children <- as.list(x)[-1]\n  } else {\n    lhs <- character()\n    children <- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec <- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign <- function(x) find_assign_rec(enexpr(x))\nfind_assign(names(x))\n#> character(0)\n\nfind_assign(names(x) <- y)\n#> [1] \"x\"\n\nfind_assign(names(f(x)) <- y)\n#> [1] \"x\"\n\nfind_assign(names(x) <- y <- z <- NULL)\n#> [1] \"x\" \"y\" \"z\"\n\nfind_assign(a <- b <- c <- 1)\n#> [1] \"a\" \"b\" \"c\"\n\nfind_assign(system.time(x <- print(y <- 5)))\n#> [1] \"x\" \"y\"\nfind_function_call <- function(x, .f) {\n  if (is_call(x)) {\n    if (is_call(x, .f)) {\n      list(x)\n    } else {\n      purrr::map(as.list(x), ~ find_function_call(.x, .f)) %>%\n        purrr::compact() %>%\n        unlist(use.names = FALSE)\n    }\n  }\n}\n\n# example-1: with infix operator `:`\nfind_function_call(expr(mean(1:2)), \":\")\n#> [[1]]\n#> 1:2\n\nfind_function_call(expr(sum(mean(1:2))), \":\")\n#> [[1]]\n#> 1:2\n\nfind_function_call(expr(list(1:5, 4:6, 3:9)), \":\")\n#> [[1]]\n#> 1:5\n#> \n#> [[2]]\n#> 4:6\n#> \n#> [[3]]\n#> 3:9\n\nfind_function_call(expr(list(1:5, sum(4:6), mean(3:9))), \":\")\n#> [[1]]\n#> 1:5\n#> \n#> [[2]]\n#> 4:6\n#> \n#> [[3]]\n#> 3:9\n\n# example-2: with assignment operator `<-`\nfind_function_call(expr(names(x)), \"<-\")\n#> NULL\n\nfind_function_call(expr(names(x) <- y), \"<-\")\n#> [[1]]\n#> names(x) <- y\n\nfind_function_call(expr(names(f(x)) <- y), \"<-\")\n#> [[1]]\n#> names(f(x)) <- y\n\nfind_function_call(expr(names(x) <- y <- z <- NULL), \"<-\")\n#> [[1]]\n#> names(x) <- y <- z <- NULL\n\nfind_function_call(expr(a <- b <- c <- 1), \"<-\")\n#> [[1]]\n#> a <- b <- c <- 1\n\nfind_function_call(expr(system.time(x <- print(y <- 5))), \"<-\")\n#> [[1]]\n#> x <- print(y <- 5)"},{"path":"expressions.html","id":"session-information-13","chapter":"18 Expressions","heading":"18.5 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  crayon        1.5.3   2024-06-20 [1] RSPM\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  lobstr      * 1.1.2   2022-06-22 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  purrr         1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang       * 1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"quasiquotation.html","id":"quasiquotation","chapter":"19 Quasiquotation","heading":"19 Quasiquotation","text":"Attaching needed libraries:","code":"\nlibrary(rlang)\nlibrary(purrr)\nlibrary(lobstr)\nlibrary(dplyr)\nlibrary(ggplot2)"},{"path":"quasiquotation.html","id":"motivation-exercises-19.2.2","chapter":"19 Quasiquotation","heading":"19.1 Motivation (Exercises 19.2.2)","text":"Q1. function following base R code, identify arguments quoted evaluated.A1. identify arguments quoted evaluated, can use trick mentioned book:’re ever unsure whether argument quoted evaluated, try executing code outside function. doesn’t work something different, argument quoted.library(MASS)package argument library() quoted:subset(mtcars, cyl == 4)argument x evaluated, argument subset quoted.(mtcars2, sum(vs))argument data evaluated, expr argument quoted.sum(mtcars2$)argument ... evaluated.rm(mtcars2)trick using far won’t work since trying print mtcars2 always fail rm() made pass .can instead look docs ...:… objects removed, names (unquoted) character strings (quoted).Thus, argument evaluated, rather quoted.Q2. function following tidyverse code, identify arguments quoted evaluated.A2. seen answer Q1., library() quotes first argument:following code:%>% (lazily) evaluates argumentgroup_by() summarise() quote argumentsIn following code:ggplot() evaluates data argumentaes() quotes arguments","code":"\nlibrary(MASS)\n\nmtcars2 <- subset(mtcars, cyl == 4)\n\nwith(mtcars2, sum(vs))\nsum(mtcars2$am)\n\nrm(mtcars2)\nlibrary(MASS)\n\nMASS\n#> Error: object 'MASS' not found\nmtcars2 <- subset(mtcars, cyl == 4)\n\ninvisible(mtcars)\n\ncyl == 4\n#> Error: object 'cyl' not found\nwith(mtcars2, sum(vs))\n#> [1] 10\n\ninvisible(mtcars2)\n\nsum(vs)\n#> Error: object 'vs' not found\nsum(mtcars2$am)\n#> [1] 8\n\nmtcars2$am\n#>  [1] 1 0 0 1 1 1 0 1 1 1 1\nrm(mtcars2)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_cyl <- mtcars %>%\n  group_by(cyl) %>%\n  summarise(mean = mean(mpg))\n\nggplot(by_cyl, aes(cyl, mean)) +\n  geom_point()\nlibrary(dplyr)\nlibrary(ggplot2)\nby_cyl <- mtcars %>%\n  group_by(cyl) %>%\n  summarise(mean = mean(mpg))\nggplot(by_cyl, aes(cyl, mean)) +\n  geom_point()"},{"path":"quasiquotation.html","id":"quoting-exercises-19.3.6","chapter":"19 Quasiquotation","heading":"19.2 Quoting (Exercises 19.3.6)","text":"Q1. expr() implemented? Look source code.A1. Looking source code, can see expr() simple wrapper around enexpr(), captures returns user-entered expressions:example:turn, enexpr() calls native code:Q2. Compare contrast following two functions. Can predict output running ?A2. exprs() captures returns expressions specified developer instead values:hand, enexprs() captures user-entered expressions returns values:Q3. happens try use enexpr() expression (.e. enexpr(x + y)? happens enexpr() passed missing argument?A3. try use enexpr() expression, fails works symbol.enexpr() passed missing argument, returns missing argument:Q4. exprs() exprs(= ) different? Think input output.A4. key difference exprs() exprs(= ) former return unnamed list, latter return named list. former interpreted unnamed argument, latter named argument.cases, treated symbol:, argument missing latter case, since name corresponding value provided:Q5. differences exprs() alist()? Read documentation named arguments exprs() find .A5. additional differences exprs() alist().Names: inputs named, exprs() provides way name automatically using .named argument.Ignoring empty arguments: .ignore_empty argument exprs() gives much finer control empty arguments, alist() doesn’t provide way ignore arguments.Names injection: Using .unquote_names argument exprs(), can inject name argument.Q6. documentation substitute() says:Substitution takes place examining component parse tree\nfollows:bound symbol env, unchanged.promise object (.e., formal argument function)\nexpression slot promise replaces symbol.ordinary variable, value substituted, unless\nenv .GlobalEnv case symbol left unchanged.Create examples illustrate cases.A6. See examples illustrate -mentioned cases.bound symbol env, unchanged.Symbol x bound env, remains unchanged.promise object (.e., formal argument function)\nexpression slot promise replaces symbol.ordinary variable, value substituted, unless\nenv .GlobalEnv case symbol left unchanged.","code":"\nrlang::expr\n#> function (expr) \n#> {\n#>     enexpr(expr)\n#> }\n#> <bytecode: 0x5590469d62f8>\n#> <environment: namespace:rlang>\nx <- expr(x <- 1)\nx\n#> x <- 1\nrlang::enexpr\n#> function (arg) \n#> {\n#>     .Call(ffi_enexpr, substitute(arg), parent.frame())\n#> }\n#> <bytecode: 0x55904236cea8>\n#> <environment: namespace:rlang>\nf1 <- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 <- function(x, y) {\n  enexprs(x = x, y = y)\n}\nf1(a + b, c + d)\nf2(a + b, c + d)\nf1 <- function(x, y) {\n  exprs(x = x, y = y)\n}\n\nf1(a + b, c + d)\n#> $x\n#> x\n#> \n#> $y\n#> y\nf2 <- function(x, y) {\n  enexprs(x = x, y = y)\n}\n\nf2(a + b, c + d)\n#> $x\n#> a + b\n#> \n#> $y\n#> c + d\nenexpr(x + y)\n#> Error in `enexpr()`:\n#> ! `arg` must be a symbol\narg <- missing_arg()\n\nenexpr(arg)\n\nis_missing(enexpr(arg))\n#> [1] TRUE\nexprs(a)\n#> [[1]]\n#> a\n\nexprs(a = )\n#> $a\nmap_lgl(exprs(a), is_symbol)\n#>      \n#> TRUE\n\nmap_lgl(exprs(a = ), is_symbol)\n#>    a \n#> TRUE\nmap_lgl(exprs(a), is_missing)\n#>       \n#> FALSE\n\nmap_lgl(exprs(a = ), is_missing)\n#>    a \n#> TRUE\nalist(\"x\" = 1, TRUE, \"z\" = expr(x + y))\n#> $x\n#> [1] 1\n#> \n#> [[2]]\n#> [1] TRUE\n#> \n#> $z\n#> expr(x + y)\n\nexprs(\"x\" = 1, TRUE, \"z\" = expr(x + y), .named = TRUE)\n#> $x\n#> [1] 1\n#> \n#> $`TRUE`\n#> [1] TRUE\n#> \n#> $z\n#> expr(x + y)\nalist(\"x\" = 1, , TRUE, )\n#> $x\n#> [1] 1\n#> \n#> [[2]]\n#> \n#> \n#> [[3]]\n#> [1] TRUE\n#> \n#> [[4]]\n\nexprs(\"x\" = 1, , TRUE, , .ignore_empty = \"trailing\")\n#> $x\n#> [1] 1\n#> \n#> [[2]]\n#> \n#> \n#> [[3]]\n#> [1] TRUE\n\nexprs(\"x\" = 1, , TRUE, , .ignore_empty = \"none\")\n#> $x\n#> [1] 1\n#> \n#> [[2]]\n#> \n#> \n#> [[3]]\n#> [1] TRUE\n#> \n#> [[4]]\n\nexprs(\"x\" = 1, , TRUE, , .ignore_empty = \"all\")\n#> $x\n#> [1] 1\n#> \n#> [[2]]\n#> [1] TRUE\nalist(foo := bar)\n#> [[1]]\n#> `:=`(foo, bar)\n\nexprs(foo := bar, .unquote_names = FALSE)\n#> [[1]]\n#> `:=`(foo, bar)\n\nexprs(foo := bar, .unquote_names = TRUE)\n#> $foo\n#> bar\nsubstitute(x + y, env = list(y = 2))\n#> x + 2\nmsg <- \"old\"\ndelayedAssign(\"myVar\", msg) # creates a promise\nsubstitute(myVar)\n#> myVar\nmsg <- \"new!\"\nmyVar\n#> [1] \"new!\"\nsubstitute(x + y, env = env(x = 2, y = 1))\n#> 2 + 1\n\nx <- 2\ny <- 1\nsubstitute(x + y, env = .GlobalEnv)\n#> x + y"},{"path":"quasiquotation.html","id":"unquoting-exercises-19.4.8","chapter":"19 Quasiquotation","heading":"19.3 Unquoting (Exercises 19.4.8)","text":"Q1. Given following components:Use quasiquotation construct following calls:A1. Using quasiquotation construct specified calls:Q2. following two calls print , actually different:’s difference? one natural?A2. can see difference two expression convert lists:can seen, second element call object, b integer vector:can also noticed ASTs expressions:first call natural, since second one inlines vector directly call, something rarely done.","code":"\nxy <- expr(x + y)\nxz <- expr(x + z)\nyz <- expr(y + z)\nabc <- exprs(a, b, c)\n(x + y) / (y + z)\n-(x + z)^(y + z)\n(x + y) + (y + z) - (x + y)\natan2(x + y, y + z)\nsum(x + y, x + y, y + z)\nsum(a, b, c)\nmean(c(a, b, c), na.rm = TRUE)\nfoo(a = x + y, b = y + z)\nxy <- expr(x + y)\nxz <- expr(x + z)\nyz <- expr(y + z)\nabc <- exprs(a, b, c)\n\nexpr((!!xy) / (!!yz))\n#> (x + y)/(y + z)\n\nexpr(-(!!xz)^(!!yz))\n#> -(x + z)^(y + z)\n\nexpr(((!!xy)) + (!!yz) - (!!xy))\n#> (x + y) + (y + z) - (x + y)\n\ncall2(\"atan2\", expr(!!xy), expr(!!yz))\n#> atan2(x + y, y + z)\n\ncall2(\"sum\", expr(!!xy), expr(!!xy), expr(!!yz))\n#> sum(x + y, x + y, y + z)\n\ncall2(\"sum\", !!!abc)\n#> sum(a, b, c)\n\nexpr(mean(c(!!!abc), na.rm = TRUE))\n#> mean(c(a, b, c), na.rm = TRUE)\n\ncall2(\"foo\", a = expr(!!xy), b = expr(!!yz))\n#> foo(a = x + y, b = y + z)\n(a <- expr(mean(1:10)))\n#> mean(1:10)\n(b <- expr(mean(!!(1:10))))\n#> mean(1:10)\nidentical(a, b)\n#> [1] FALSE\nas.list(expr(mean(1:10)))\n#> [[1]]\n#> mean\n#> \n#> [[2]]\n#> 1:10\n\nas.list(expr(mean(!!(1:10))))\n#> [[1]]\n#> mean\n#> \n#> [[2]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nwaldo::compare(a, b)\n#> `old[[2]]` is a call\n#> `new[[2]]` is an integer vector (1, 2, 3, 4, 5, ...)\nast(expr(mean(1:10)))\n#> █─expr \n#> └─█─mean \n#>   └─█─`:` \n#>     ├─1 \n#>     └─10\n\nast(expr(mean(!!(1:10))))\n#> █─expr \n#> └─█─mean \n#>   └─<inline integer>"},{"path":"quasiquotation.html","id":"dot-dot-dot-exercises-19.6.5","chapter":"19 Quasiquotation","heading":"19.4 ... (dot-dot-dot) (Exercises 19.6.5)","text":"Q1. One way implement exec() shown . Describe works. key ideas?A1. keys ideas underlie implementation exec() function following:constructs call using function f argument ..., evaluates call environment .env.constructs call using function f argument ..., evaluates call environment .env.uses dynamic dots via list2(), means can splice arguments using !!!, can inject names using :=, trailing commas problem.uses dynamic dots via list2(), means can splice arguments using !!!, can inject names using :=, trailing commas problem.example:Q2. Carefully read source code interaction(), expand.grid(), par(). Compare contrast techniques use switching dots list behaviour.A2. Source code reveals following comparison table:functions capture dots list.Using dots, functions check:list entered argument checking number argumentsif count 1, checking argument listQ3. Explain problem definition set_attr()A3. set_attr() function signature parameter called x, additionally uses dynamic dots pass multiple arguments specify additional attributes x., shown example, creates problem attribute named x. Naming arguments won’t help either:can avoid issues renaming parameter:","code":"\nexec <- function(f, ..., .env = caller_env()) {\n  args <- list2(...)\n  do.call(f, args, envir = .env)\n}\nvec <- c(1:5, NA)\nargs_list <- list(trim = 0, na.rm = TRUE)\n\nexec(mean, vec, !!!args_list, , .env = caller_env())\n#> [1] 3\n\nrm(\"exec\")\nset_attr <- function(x, ...) {\n  attr <- rlang::list2(...)\n  attributes(x) <- attr\n  x\n}\nset_attr(1:10, x = 10)\n#> Error in attributes(x) <- attr: attributes must be named\nset_attr <- function(x, ...) {\n  attr <- rlang::list2(...)\n  attributes(x) <- attr\n  x\n}\nset_attr(x = 1:10, x = 10)\n#> Error in set_attr(x = 1:10, x = 10): formal argument \"x\" matched by multiple actual arguments\nset_attr <- function(.x, ...) {\n  attr <- rlang::list2(...)\n  attributes(.x) <- attr\n  .x\n}\n\nset_attr(.x = 1:10, x = 10)\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> attr(,\"x\")\n#> [1] 10"},{"path":"quasiquotation.html","id":"case-studies-exercises-19.7.5","chapter":"19 Quasiquotation","heading":"19.5 Case studies (Exercises 19.7.5)","text":"Q1. linear-model example, replace expr() reduce(summands, ~ expr(!!.x + !!.y)) call2(): reduce(summands, call2, \"+\"). Compare contrast two approaches. think easier read?A1. can rewrite linear() function chapter using call2() follows:personally find version call2() much readable since !! syntax bit esoteric.Q2. Re-implement Box-Cox transform defined using unquoting new_function():A2. Re-implementation Box-Cox transform using unquoting new_function():Let’s try see produces output :Q3. Re-implement simple compose() defined using quasiquotation new_function():A3. Following re-implementation compose() using quasiquotation new_function():Checking new version behaves way original version:","code":"\nlinear <- function(var, val) {\n  var <- ensym(var)\n  coef_name <- map(seq_along(val[-1]), ~ expr((!!var)[[!!.x]]))\n\n  summands <- map2(val[-1], coef_name, ~ expr((!!.x * !!.y)))\n  summands <- c(val[[1]], summands)\n\n  reduce(summands, ~ call2(\"+\", .x, .y))\n}\n\nlinear(x, c(10, 5, -4))\n#> 10 + (5 * x[[1L]]) + (-4 * x[[2L]])\nbc <- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x^lambda - 1) / lambda\n  }\n}\nbc_new <- function(lambda) {\n  lambda <- enexpr(lambda)\n\n  if (!!lambda == 0) {\n    new_function(\n      exprs(x = ),\n      expr(log(x))\n    )\n  } else {\n    new_function(\n      exprs(x = ),\n      expr((x^(!!lambda) - 1) / (!!lambda))\n    )\n  }\n}\nbc(0)(1)\n#> [1] 0\nbc_new(0)(1)\n#> [1] 0\n\nbc(2)(2)\n#> [1] 1.5\nbc_new(2)(2)\n#> [1] 1.5\ncompose <- function(f, g) {\n  function(...) f(g(...))\n}\ncompose_new <- function(f, g) {\n  f <- enexpr(f) # or ensym(f)\n  g <- enexpr(g) # or ensym(g)\n\n  new_function(\n    exprs(... = ),\n    expr((!!f)((!!g)(...)))\n  )\n}\nnot_null <- compose(`!`, is.null)\nnot_null(4)\n#> [1] TRUE\n\nnot_null2 <- compose_new(`!`, is.null)\nnot_null2(4)\n#> [1] TRUE"},{"path":"quasiquotation.html","id":"session-information-14","chapter":"19 Quasiquotation","heading":"19.6 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version  date (UTC) lib source\n#>  base        * 4.4.1    2024-08-22 [3] local\n#>  bookdown      0.40     2024-07-02 [1] RSPM\n#>  bslib         0.8.0    2024-07-29 [1] RSPM\n#>  cachem        1.1.0    2024-05-16 [1] RSPM\n#>  cli           3.6.3    2024-06-21 [1] RSPM\n#>  colorspace    2.1-1    2024-07-26 [1] RSPM\n#>  compiler      4.4.1    2024-08-22 [3] local\n#>  crayon        1.5.3    2024-06-20 [1] RSPM\n#>  datasets    * 4.4.1    2024-08-22 [3] local\n#>  diffobj       0.3.5    2021-10-05 [1] RSPM\n#>  digest        0.6.37   2024-08-19 [1] RSPM\n#>  downlit       0.4.4    2024-06-10 [1] RSPM\n#>  dplyr       * 1.1.4    2023-11-17 [1] RSPM\n#>  evaluate      1.0.0    2024-09-17 [1] RSPM\n#>  fansi         1.0.6    2023-12-08 [1] RSPM\n#>  farver        2.1.2    2024-05-13 [1] RSPM\n#>  fastmap       1.2.0    2024-05-15 [1] RSPM\n#>  fs            1.6.4    2024-04-25 [1] RSPM\n#>  generics      0.1.3    2022-07-05 [1] RSPM\n#>  ggplot2     * 3.5.1    2024-04-23 [1] RSPM\n#>  glue          1.8.0    2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1    2024-08-22 [3] local\n#>  grDevices   * 4.4.1    2024-08-22 [3] local\n#>  grid          4.4.1    2024-08-22 [3] local\n#>  gtable        0.3.5    2024-04-22 [1] RSPM\n#>  highr         0.11     2024-05-26 [1] RSPM\n#>  htmltools     0.5.8.1  2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4    2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9    2024-09-20 [1] RSPM\n#>  knitr         1.48     2024-07-07 [1] RSPM\n#>  labeling      0.4.3    2023-08-29 [1] RSPM\n#>  lifecycle     1.0.4    2023-11-07 [1] RSPM\n#>  lobstr      * 1.1.2    2022-06-22 [1] RSPM\n#>  magrittr    * 2.0.3    2022-03-30 [1] RSPM\n#>  MASS        * 7.3-60.2 2024-04-26 [3] CRAN (R 4.4.1)\n#>  memoise       2.0.1    2021-11-26 [1] RSPM\n#>  methods     * 4.4.1    2024-08-22 [3] local\n#>  munsell       0.5.1    2024-04-01 [1] RSPM\n#>  pillar        1.9.0    2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3    2019-09-22 [1] RSPM\n#>  purrr       * 1.0.2    2023-08-10 [1] RSPM\n#>  R6            2.5.1    2021-08-19 [1] RSPM\n#>  rematch2      2.1.2    2020-05-01 [1] RSPM\n#>  rlang       * 1.1.4    2024-06-04 [1] RSPM\n#>  rmarkdown     2.28     2024-08-17 [1] RSPM\n#>  sass          0.4.9    2024-03-15 [1] RSPM\n#>  scales        1.3.0    2023-11-28 [1] RSPM\n#>  sessioninfo   1.2.2    2021-12-06 [1] RSPM\n#>  stats       * 4.4.1    2024-08-22 [3] local\n#>  tibble        3.2.1    2023-03-20 [1] RSPM\n#>  tidyselect    1.2.1    2024-03-11 [1] RSPM\n#>  tools         4.4.1    2024-08-22 [3] local\n#>  utf8          1.2.4    2023-10-22 [1] RSPM\n#>  utils       * 4.4.1    2024-08-22 [3] local\n#>  vctrs         0.6.5    2023-12-01 [1] RSPM\n#>  waldo         0.5.3    2024-08-23 [1] RSPM\n#>  withr         3.0.1    2024-07-31 [1] RSPM\n#>  xfun          0.47     2024-08-17 [1] RSPM\n#>  xml2          1.3.6    2023-12-04 [1] RSPM\n#>  yaml          2.3.10   2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"evaluation.html","id":"evaluation","chapter":"20 Evaluation","heading":"20 Evaluation","text":"Attaching needed libraries:","code":"\nlibrary(rlang)"},{"path":"evaluation.html","id":"evaluation-basics-exercises-20.2.4","chapter":"20 Evaluation","heading":"20.1 Evaluation basics (Exercises 20.2.4)","text":"Q1. Carefully read documentation source(). environment use default? supply local = TRUE? provide custom environment?A1. parameter local source() decides environment parsed expressions evaluated.default local = FALSE, corresponds user’s workspace (global environment, .e.).local = TRUE, environment source() called used.specify custom environment, sys.source() function can used, provides envir parameter.Q2. Predict results following lines code:A2. Correctly predicted 😉Q3. Fill function bodies re-implement get() using sym() eval(), assign() using sym(), expr(), eval(). Don’t worry multiple ways choosing environment get() assign() support; assume user supplies explicitly.A3. required re-implementations:get()assign()Q4. Modify source2() returns result every expression, just last one. Can eliminate loop?A4. can use purrr::map() iterate every expression return result every expression:Q5. can make base::local() slightly easier understand spreading multiple lines:Explain local() works words. (Hint: might want print(call) help understand substitute() , read documentation remind environment new.env() inherit .)A5. order figure function works, let’s add suggested print(call):docs substitute() mention:Substituting quoting often cause confusion argument expression(…). result call expression constructor function needs evaluated eval give actual expression object.Thus, get actual expression object, quoted expression needs evaluated using eval():Finally, generated call evaluated caller environment. final function call looks like following:Note bindings x y found inner environment, bindings functions eval(), quote(), etc. found outer environment.","code":"\nwithr::with_tempdir(\n  code = {\n    f <- tempfile()\n    writeLines(\"rlang::env_print()\", f)\n    foo <- function() source(f, local = FALSE)\n    foo()\n  }\n)\n#> <environment: global>\n#> Parent: <environment: package:rlang>\n#> Bindings:\n#> • .Random.seed: <int>\n#> • foo: <fn>\n#> • f: <chr>\nwithr::with_tempdir(\n  code = {\n    f <- tempfile()\n    writeLines(\"rlang::env_print()\", f)\n    foo <- function() source(f, local = TRUE)\n    foo()\n  }\n)\n#> <environment: 0x556dc0fee6a8>\n#> Parent: <environment: global>\neval(expr(eval(expr(eval(expr(2 + 2))))))\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))\neval(expr(eval(expr(eval(expr(2 + 2))))))\n#> [1] 4\n\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n#> [1] 4\n\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n#> eval(expr(eval(expr(eval(expr(2 + 2))))))\n# name is a string\nget2 <- function(name, env) {}\nassign2 <- function(name, value, env) {}\nget2 <- function(name, env = caller_env()) {\n  name <- sym(name)\n  eval(name, env)\n}\n\nx <- 2\n\nget2(\"x\")\n#> [1] 2\nget(\"x\")\n#> [1] 2\n\ny <- 1:4\nassign(\"y[1]\", 2)\n\nget2(\"y[1]\")\n#> [1] 2\nget(\"y[1]\")\n#> [1] 2\nassign2 <- function(name, value, env = caller_env()) {\n  name <- sym(name)\n  eval(expr(!!name <- !!value), env)\n}\n\nassign(\"y1\", 4)\ny1\n#> [1] 4\n\nassign2(\"y2\", 4)\ny2\n#> [1] 4\nsource2 <- function(path, env = caller_env()) {\n  file <- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs <- parse_exprs(file)\n  purrr::map(exprs, ~ eval(.x, env))\n}\n\nwithr::with_tempdir(\n  code = {\n    f <- tempfile(fileext = \".R\")\n    writeLines(\"1 + 1; 2 + 4\", f)\n    source2(f)\n  }\n)\n#> [[1]]\n#> [1] 2\n#> \n#> [[2]]\n#> [1] 6\nlocal3 <- function(expr, envir = new.env()) {\n  call <- substitute(eval(quote(expr), envir))\n  eval(call, envir = parent.frame())\n}\nlocal3 <- function(expr, envir = new.env()) {\n  call <- substitute(eval(quote(expr), envir))\n  print(call)\n\n  eval(call, envir = parent.frame())\n}\n\nlocal3({\n  x <- 10\n  y <- 200\n  x + y\n})\n#> eval(quote({\n#>     x <- 10\n#>     y <- 200\n#>     x + y\n#> }), new.env())\n#> [1] 210\nis_expression(eval(quote({\n  x <- 10\n  y <- 200\n  x + y\n}), new.env()))\n#> [1] TRUE\n# outer environment\neval(\n  # inner environment\n  eval(quote({\n    x <- 10\n    y <- 200\n    x + y\n  }), new.env()),\n  envir = parent.frame()\n)"},{"path":"evaluation.html","id":"quosures-exercises-20.3.6","chapter":"20 Evaluation","heading":"20.2 Quosures (Exercises 20.3.6)","text":"Q1. Predict following quosures return evaluated.A1. Correctly predicted 😉Q2. Write enenv() function captures environment associated argument. (Hint: require two function calls.)A2. can make use get_env() helper get environment associated argument:","code":"\nq1 <- new_quosure(expr(x), env(x = 1))\nq1\n#> <quosure>\n#> expr: ^x\n#> env:  0x556dc2b3cd98\nq2 <- new_quosure(expr(x + !!q1), env(x = 10))\nq2\n#> <quosure>\n#> expr: ^x + (^x)\n#> env:  0x556dbff069f0\nq3 <- new_quosure(expr(x + !!q2), env(x = 100))\nq3\n#> <quosure>\n#> expr: ^x + (^x + (^x))\n#> env:  0x556dbce16d90\nq1 <- new_quosure(expr(x), env(x = 1))\neval_tidy(q1)\n#> [1] 1\n\nq2 <- new_quosure(expr(x + !!q1), env(x = 10))\neval_tidy(q2)\n#> [1] 11\n\nq3 <- new_quosure(expr(x + !!q2), env(x = 100))\neval_tidy(q3)\n#> [1] 111\nenenv <- function(x) {\n  x <- enquo(x)\n  get_env(x)\n}\n\nenenv(x)\n#> <environment: R_GlobalEnv>\n\nfoo <- function(x) enenv(x)\nfoo()\n#> <environment: 0x556dc16f9228>"},{"path":"evaluation.html","id":"data-masks-exercises-20.4.6","chapter":"20 Evaluation","heading":"20.3 Data masks (Exercises 20.4.6)","text":"Q1. use loop transform2() instead map()? Consider transform2(df, x = x * 2, x = x * 2).A1. see map() appropriate function, let’s create version function map() see happens.use () loop, iteration, updating x column current expression evaluation. , repeatedly modifying column works.use map() instead, trying evaluate expressions time; .e., column attempted modify using multiple expressions.Q2. ’s alternative implementation subset2():Compare contrast subset3() subset2(). advantages disadvantages?A2. Let’s first juxtapose functions outputs can compare better.Disadvantages subset3() subset2()filtering conditions specified rows don’t evaluate logical, function doesn’t fail informatively. Indeed, silently returns incorrect result.Advantages subset3() subset2()might argue function shorter advantage, much subjective preference.Q3. following function implements basics dplyr::arrange(). Annotate line comment explaining . Can explain !!.na.last strictly correct, omitting !! unlikely cause problems?A3. Annotated version function:see doesn’t matter whether whether unquote .na.last argument , let’s look smaller example:can seen:without unquoting, .na.last found function environmentwith unquoting, .na.last included order call object ","code":"\ntransform2 <- function(.data, ...) {\n  dots <- enquos(...)\n\n  for (i in seq_along(dots)) {\n    name <- names(dots)[[i]]\n    dot <- dots[[i]]\n\n    .data[[name]] <- eval_tidy(dot, .data)\n  }\n\n  .data\n}\n\ntransform3 <- function(.data, ...) {\n  dots <- enquos(...)\n\n  purrr::map(dots, function(x, .data = .data) {\n    name <- names(x)\n    dot <- x\n\n    .data[[name]] <- eval_tidy(dot, .data)\n\n    .data\n  })\n}\ndf <- data.frame(x = 1:3)\ntransform2(df, x = x * 2, x = x * 2)\n#>    x\n#> 1  4\n#> 2  8\n#> 3 12\ndf <- data.frame(x = 1:3)\ntransform3(df, x = x * 2, x = x * 2)\n#> Error in `purrr::map()`:\n#> ℹ In index: 1.\n#> ℹ With name: x.\n#> Caused by error:\n#> ! promise already under evaluation: recursive default argument reference or earlier problems?\nsubset3 <- function(data, rows) {\n  rows <- enquo(rows)\n  eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)\n}\ndf <- data.frame(x = 1:3)\nsubset3(df, x == 1)\nsubset2 <- function(data, rows) {\n  rows <- enquo(rows)\n  rows_val <- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\ndf <- data.frame(x = 1:3)\nsubset2(df, x == 1)\n#>   x\n#> 1 1\nsubset3 <- function(data, rows) {\n  rows <- enquo(rows)\n  eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)\n}\n\nsubset3(df, x == 1)\n#>   x\n#> 1 1\nrm(\"x\")\nexists(\"x\")\n#> [1] FALSE\n\nsubset2(df, x + 1)\n#> Error in subset2(df, x + 1): is.logical(rows_val) is not TRUE\n\nsubset3(df, x + 1)\n#>     x\n#> 2   2\n#> 3   3\n#> NA NA\narrange2 <- function(.df, ..., .na.last = TRUE) {\n  args <- enquos(...)\n  order_call <- expr(order(!!!args, na.last = !!.na.last))\n  ord <- eval_tidy(order_call, .df)\n  stopifnot(length(ord) == nrow(.df))\n  .df[ord, , drop = FALSE]\n}\narrange2 <- function(.df, ..., .na.last = TRUE) {\n  # capture user-supplied expressions (and corresponding environments) as quosures\n  args <- enquos(...)\n\n  # create a call object by splicing a list of quosures\n  order_call <- expr(order(!!!args, na.last = !!.na.last))\n\n  # and evaluate the constructed call in the data frame\n  ord <- eval_tidy(order_call, .df)\n\n  # sanity check\n  stopifnot(length(ord) == nrow(.df))\n\n  .df[ord, , drop = FALSE]\n}\nx <- TRUE\neval(expr(c(x = !!x)))\n#>    x \n#> TRUE\neval(expr(c(x = x)))\n#>    x \n#> TRUE"},{"path":"evaluation.html","id":"using-tidy-evaluation-exercises-20.5.4","chapter":"20 Evaluation","heading":"20.4 Using tidy evaluation (Exercises 20.5.4)","text":"Q1. ’ve included alternative implementation threshold_var() . makes different approach used ? makes harder?A1. First, let’s compare two definitions function make sure produce output:key difference subsetting operator used:old version uses non-quoting [[ operator. Thus, var argument first needs converted string.new version uses quoting $ operator. Thus, var argument first quoted unquoted (using !!).","code":"\nthreshold_var <- function(df, var, val) {\n  var <- ensym(var)\n  subset2(df, `$`(.data, !!var) >= !!val)\n}\nthreshold_var_old <- function(df, var, val) {\n  var <- as_string(ensym(var))\n  subset2(df, .data[[var]] >= !!val)\n}\n\nthreshold_var_new <- threshold_var\n\ndf <- data.frame(x = 1:10)\n\nidentical(\n  threshold_var(df, x, 8),\n  threshold_var(df, x, 8)\n)\n#> [1] TRUE"},{"path":"evaluation.html","id":"base-evaluation-exercises-20.6.3","chapter":"20 Evaluation","heading":"20.5 Base evaluation (Exercises 20.6.3)","text":"Q1. function fail?A1. doesn’t work lm_call call evaluated caller_env(), finds binding base::data() function, data execution environment.make work, need unquote data expression:Q2. model building, typically response data relatively constant rapidly experiment different predictors. Write small wrapper allows reduce duplication code .A2. small wrapper allows enter predictors:function flexible enough also allow changing data dependent variable:Q3. Another way write resample_lm() include resample expression (data[sample(nrow(data), replace = TRUE), , drop = FALSE]) data argument. Implement approach. advantages? disadvantages?A3. variant resample_lm(), providing resampled data argument.makes use R’s lazy evaluation function arguments. , resample_data argument evaluated needed function.","code":"\nlm3a <- function(formula, data) {\n  formula <- enexpr(formula)\n  lm_call <- expr(lm(!!formula, data = data))\n  eval(lm_call, caller_env())\n}\n\nlm3a(mpg ~ disp, mtcars)$call\n#> Error in as.data.frame.default(data, optional = TRUE):\n#> cannot coerce class ‘\"function\"’ to a data.frame\nlm3a <- function(formula, data) {\n  formula <- enexpr(formula)\n  lm_call <- expr(lm(!!formula, data = !!data))\n  eval(lm_call, caller_env())\n}\n\nis_call(lm3a(mpg ~ disp, mtcars)$call)\n#> [1] TRUE\nlm(mpg ~ disp, data = mtcars)\nlm(mpg ~ I(1 / disp), data = mtcars)\nlm(mpg ~ disp * cyl, data = mtcars)\nlm_custom <- function(data = mtcars, x, y = mpg) {\n  x <- enexpr(x)\n  y <- enexpr(y)\n  data <- enexpr(data)\n\n  lm_call <- expr(lm(formula = !!y ~ !!x, data = !!data))\n\n  eval(lm_call, caller_env())\n}\n\nidentical(\n  lm_custom(x = disp),\n  lm(mpg ~ disp, data = mtcars)\n)\n#> [1] TRUE\n\nidentical(\n  lm_custom(x = I(1 / disp)),\n  lm(mpg ~ I(1 / disp), data = mtcars)\n)\n#> [1] TRUE\n\nidentical(\n  lm_custom(x = disp * cyl),\n  lm(mpg ~ disp * cyl, data = mtcars)\n)\n#> [1] TRUE\nlm_custom(data = iris, x = Sepal.Length, y = Petal.Width)\n#> \n#> Call:\n#> lm(formula = Petal.Width ~ Sepal.Length, data = iris)\n#> \n#> Coefficients:\n#>  (Intercept)  Sepal.Length  \n#>      -3.2002        0.7529\nresample_lm3 <- function(formula,\n                         data,\n                         resample_data = data[sample(nrow(data), replace = TRUE), , drop = FALSE],\n                         env = current_env()) {\n  formula <- enexpr(formula)\n  lm_call <- expr(lm(!!formula, data = resample_data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\n\ndf <- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2))\nresample_lm3(y ~ x, data = df)\n#> lm(y ~ x, data = resample_data)\n#> \n#> Call:\n#> lm(formula = y ~ x, data = resample_data)\n#> \n#> Coefficients:\n#> (Intercept)            x  \n#>       2.654        3.420"},{"path":"evaluation.html","id":"session-information-15","chapter":"20 Evaluation","heading":"20.6 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  purrr         1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang       * 1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"translation.html","id":"translation","chapter":"21 Translation","heading":"21 Translation","text":"Needed libraries:","code":"\nlibrary(rlang)\nlibrary(purrr)"},{"path":"translation.html","id":"html-exercises-21.2.6","chapter":"21 Translation","heading":"21.1 HTML (Exercises 21.2.6)","text":"Q1. escaping rules <script> tags different contain JavaScript, HTML. Instead escaping angle brackets ampersands, need escape <\/script> tag isn’t closed early. example, script(\"'<\/script>'\"), shouldn’t generate :ButAdapt escape() follow rules new argument script set TRUE.A1. Let’s first start boilerplate code included book:also need tweak boilerplate pass additional parameter escape():Q2. use ... functions big downsides. ’s input validation little information documentation autocomplete used function. Create new function , given named list tags attribute names (like ), creates tag functions named arguments.tags get class id attributes.Q3. Reason following code calls with_html() referencing objects environment. work fail? ? Run code verify predictions.A3. work , first need copy-paste relevant code book:Note with_html() uses eval_tidy(), therefore code argument evaluated first html_tags named list, acts data mask, object found data mask, searches caller environment.reason, first example code work:following code, however, going work already address element data mask, p() take function address() input, escape() doesn’t know deal objects function type:Q4. Currently HTML doesn’t look terribly pretty, ’s hard see structure. adapt tag() indenting formatting? (may need research block inline tags.)A4. Let’s first look currently looks like:can improve follow Google HTML/CSS Style Guide., need create new function indent code conditionally:can update body() function use new helper:new formatting looks much better:","code":"  <script>'<\/script>'<\/script>  <script>'<\\/script>'<\/script>\nescape <- function(x, ...) UseMethod(\"escape\")\n\nescape.character <- function(x, script = FALSE) {\n  if (script) {\n    x <- gsub(\"<\/script>\", \"<\\\\/script>\", x, fixed = TRUE)\n  } else {\n    x <- gsub(\"&\", \"&amp;\", x)\n    x <- gsub(\"<\", \"&lt;\", x)\n    x <- gsub(\">\", \"&gt;\", x)\n  }\n\n  html(x)\n}\n\nescape.advr_html <- function(x, ...) x\nhtml <- function(x) structure(x, class = \"advr_html\")\n\nprint.advr_html <- function(x, ...) {\n  out <- paste0(\"<HTML> \", x)\n  cat(paste(strwrap(out), collapse = \"\\n\"), \"\\n\", sep = \"\")\n}\n\ndots_partition <- function(...) {\n  dots <- list2(...)\n\n  if (is.null(names(dots))) {\n    is_named <- rep(FALSE, length(dots))\n  } else {\n    is_named <- names(dots) != \"\"\n  }\n\n  list(\n    named = dots[is_named],\n    unnamed = dots[!is_named]\n  )\n}\n\ntag <- function(tag, script = FALSE) {\n  force(script)\n  new_function(\n    exprs(... = ),\n    expr({\n      dots <- dots_partition(...)\n      attribs <- html_attributes(dots$named)\n      children <- map_chr(.x = dots$unnamed, .f = ~ escape(.x, !!script))\n\n      html(paste0(\n        !!paste0(\"<\", tag), attribs, \">\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"<\/\", tag, \">\")\n      ))\n    }),\n    caller_env()\n  )\n}\n\nvoid_tag <- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots <- dots_partition(...)\n      if (length(dots$unnamed) > 0) {\n        abort(!!paste0(\"<\", tag, \"> must not have unnamed arguments\"))\n      }\n      attribs <- html_attributes(dots$named)\n\n      html(paste0(!!paste0(\"<\", tag), attribs, \" />\"))\n    }),\n    caller_env()\n  )\n}\n\np <- tag(\"p\")\nscript <- tag(\"script\", script = TRUE)\nscript(\"'<\/script>'\")\n#> <HTML> <script>'<\\/script>'<\/script>\nlist(\n  a = c(\"href\"),\n  img = c(\"src\", \"width\", \"height\")\n)\ngreeting <- \"Hello!\"\nwith_html(p(greeting))\np <- function() \"p\"\naddress <- \"123 anywhere street\"\nwith_html(p(address))\ntags <- c(\n  \"a\", \"abbr\", \"address\", \"article\", \"aside\", \"audio\",\n  \"b\", \"bdi\", \"bdo\", \"blockquote\", \"body\", \"button\", \"canvas\",\n  \"caption\", \"cite\", \"code\", \"colgroup\", \"data\", \"datalist\",\n  \"dd\", \"del\", \"details\", \"dfn\", \"div\", \"dl\", \"dt\", \"em\",\n  \"eventsource\", \"fieldset\", \"figcaption\", \"figure\", \"footer\",\n  \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\",\n  \"hgroup\", \"html\", \"i\", \"iframe\", \"ins\", \"kbd\", \"label\",\n  \"legend\", \"li\", \"mark\", \"map\", \"menu\", \"meter\", \"nav\",\n  \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\",\n  \"p\", \"pre\", \"progress\", \"q\", \"ruby\", \"rp\", \"rt\", \"s\", \"samp\",\n  \"script\", \"section\", \"select\", \"small\", \"span\", \"strong\",\n  \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\",\n  \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\",\n  \"u\", \"ul\", \"var\", \"video\"\n)\n\nvoid_tags <- c(\n  \"area\", \"base\", \"br\", \"col\", \"command\", \"embed\",\n  \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n  \"source\", \"track\", \"wbr\"\n)\n\nhtml_tags <- c(\n  tags %>% set_names() %>% map(tag),\n  void_tags %>% set_names() %>% map(void_tag)\n)\n\nwith_html <- function(code) {\n  code <- enquo(code)\n  eval_tidy(code, html_tags)\n}\ngreeting <- \"Hello!\"\nwith_html(p(greeting))\n#> <HTML> <p>Hello!<\/p>\n\"address\" %in% names(html_tags)\n#> [1] TRUE\n\np <- function() \"p\"\naddress <- \"123 anywhere street\"\nwith_html(p(address))\n#> Error in `map_chr()`:\n#> ℹ In index: 1.\n#> Caused by error in `UseMethod()`:\n#> ! no applicable method for 'escape' applied to an object of class \"function\"\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n#> <HTML> <body><h1 id='first'>A heading<\/h1><p>Some\n#> text &amp;<b>some bold text.<\/b><\/p><img\n#> src='myimg.png' width='100' height='100' /><\/body>\nprint.advr_html <- function(x, ...) {\n  cat(paste(\"<HTML>\", x, sep = \"\\n\"))\n}\n\nindent <- function(x) {\n  paste0(\"  \", gsub(\"\\n\", \"\\n  \", x))\n}\n\nformat_code <- function(children, indent = FALSE) {\n  if (indent) {\n    paste0(\"\\n\", paste0(indent(children), collapse = \"\\n\"), \"\\n\")\n  } else {\n    paste(children, collapse = \"\")\n  }\n}\nhtml_tags$body <- function(...) {\n  dots <- dots_partition(...)\n  attribs <- html_attributes(dots$named)\n  children <- map_chr(dots$unnamed, escape)\n\n  html(paste0(\n    \"<body\", attribs, \">\",\n    format_code(children, indent = TRUE),\n    \"<\/body>\"\n  ))\n}\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n#> <HTML>\n#> <body>\n#>   <h1 id='first'>A heading<\/h1>\n#>   <p>Some text &amp;<b>some bold text.<\/b><\/p>\n#>   <img src='myimg.png' width='100' height='100' />\n#> <\/body>"},{"path":"translation.html","id":"latex-exercises-21.3.8","chapter":"21 Translation","heading":"21.2 LaTeX (Exercises 21.3.8)","text":"didn’t manage solve exercises, ’d recommend checking solutions official solutions manual.Q1. Add escaping. special symbols escaped adding backslash front \\, $, %. Just HTML, ’ll need make sure don’t end double-escaping. ’ll need create small S3 class use function operators. also allow embed arbitrary LaTeX needed.Q2. Complete DSL support functions plotmath supports.","code":""},{"path":"translation.html","id":"session-information-16","chapter":"21 Translation","heading":"21.3 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  purrr       * 1.0.2   2023-08-10 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang       * 1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"debugging.html","id":"debugging","chapter":"22 Debugging","heading":"22 Debugging","text":"exercises.","code":""},{"path":"measuring-performance.html","id":"measuring-performance","chapter":"23 Measuring performance","heading":"23 Measuring performance","text":"Attaching needed libraries:","code":"\nlibrary(profvis, warn.conflicts = FALSE)\nlibrary(dplyr, warn.conflicts = FALSE)"},{"path":"measuring-performance.html","id":"profiling-exercises-23.2.4","chapter":"23 Measuring performance","heading":"23.1 Profiling (Exercises 23.2.4)","text":"Q1. Profile following function torture = TRUE. surprising? Read source code rm() figure ’s going .A1. Let’s source functions mentioned exercises.First, try without torture = TRUE: returns meaningful results.mentioned docs, setting torture = TRUETriggers garbage collection every torture memory allocation call.process somehow never seems finish crashes RStudio session stops!question says documentation rm() may provide clues:still couldn’t figure . recommend checking official answer.","code":"\nf <- function(n = 1e5) {\n  x <- rep(1, n)\n  rm(x)\n}\nsource(\"profiling-exercises.R\")\nprofvis(f())\n#> Error in parse_rprof_lines(lines, expr_source): No parsing data available. Maybe your function was too fast?\nprofvis(f(), torture = TRUE)\nrm\n#> function (..., list = character(), pos = -1, envir = as.environment(pos), \n#>     inherits = FALSE) \n#> {\n#>     if (...length()) {\n#>         dots <- match.call(expand.dots = FALSE)$...\n#>         if (!all(vapply(dots, function(x) is.symbol(x) || is.character(x), \n#>             NA, USE.NAMES = FALSE))) \n#>             stop(\"... must contain names or character strings\")\n#>         list <- .Primitive(\"c\")(list, vapply(dots, as.character, \n#>             \"\"))\n#>     }\n#>     .Internal(remove(list, envir, inherits))\n#> }\n#> <bytecode: 0x5639d1876c48>\n#> <environment: namespace:base>"},{"path":"measuring-performance.html","id":"microbenchmarking-exercises-23.3.3","chapter":"23 Measuring performance","heading":"23.2 Microbenchmarking (Exercises 23.3.3)","text":"Q1. Instead using bench::mark(), use built-function system.time(). system.time() much less precise, ’ll need repeat operation many times loop, divide find average time operation, code .estimates system.time() compare bench::mark()? different?A1. Let’s benchmark first using two approaches:Now can compare results alternatives:comparison reveals two approaches yield quite similar results. Slight differences exact values possibly due differences precision timers used internally functions.Q2. two ways compute square root vector. think fastest? slowest? Use microbenchmarking test answers.A2. Microbenchmarking ways compute square root vector mentioned chapter.specialized primitive function sqrt() (written C) fastest way compute square root.","code":"\nn <- 1e6\nsystem.time(for (i in 1:n) sqrt(x)) / n\nsystem.time(for (i in 1:n) x^0.5) / n\nn <- 1e6\nx <- runif(100)\n\n# bench -------------------\n\nbench_df <- bench::mark(\n  sqrt(x),\n  x^0.5,\n  iterations = n,\n  time_unit = \"us\"\n)\n\nt_bench_df <- bench_df %>%\n  select(expression, time) %>%\n  rowwise() %>%\n  mutate(bench_mean = mean(unlist(time))) %>%\n  ungroup() %>%\n  select(-time)\n\n# system.time -------------------\n\n# garbage collection performed immediately before the timing\nt1_systime_gc <- system.time(for (i in 1:n) sqrt(x), gcFirst = TRUE) / n\nt2_systime_gc <- system.time(for (i in 1:n) x^0.5, gcFirst = TRUE) / n\n\n# garbage collection not performed immediately before the timing\nt1_systime_nogc <- system.time(for (i in 1:n) sqrt(x), gcFirst = FALSE) / n\nt2_systime_nogc <- system.time(for (i in 1:n) x^0.5, gcFirst = FALSE) / n\n\nt_systime_df <- tibble(\n  \"expression\" = bench_df$expression,\n  \"systime_with_gc\" = c(t1_systime_gc[\"elapsed\"], t2_systime_gc[\"elapsed\"]),\n  \"systime_with_nogc\" = c(t1_systime_nogc[\"elapsed\"], t2_systime_nogc[\"elapsed\"])\n) %>%\n  mutate(\n    systime_with_gc = systime_with_gc * 1e6, # in microseconds\n    systime_with_nogc = systime_with_nogc * 1e6 # in microseconds\n  )\n# note that system time columns report time in microseconds\nfull_join(t_bench_df, t_systime_df, by = \"expression\")\n#> # A tibble: 2 × 4\n#>   expression bench_mean systime_with_gc systime_with_nogc\n#>   <bch:expr>   <bch:tm>           <dbl>             <dbl>\n#> 1 sqrt(x)       509.8ns           0.416             0.426\n#> 2 x^0.5          2.21µs           1.99              1.99\nx^(1 / 2)\nexp(log(x) / 2)\nx <- runif(1000)\n\nbench::mark(\n  sqrt(x),\n  x^0.5,\n  x^(1 / 2),\n  exp(log(x) / 2),\n  iterations = 1000\n) %>%\n  select(expression, median) %>%\n  arrange(median)\n#> # A tibble: 4 × 2\n#>   expression      median\n#>   <bch:expr>    <bch:tm>\n#> 1 sqrt(x)         3.02µs\n#> 2 exp(log(x)/2)  12.57µs\n#> 3 x^0.5          18.82µs\n#> 4 x^(1/2)        18.91µs"},{"path":"measuring-performance.html","id":"session-information-17","chapter":"23 Measuring performance","heading":"23.3 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bench         1.1.3   2023-05-04 [1] RSPM\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  dplyr       * 1.1.4   2023-11-17 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  generics      0.1.3   2022-07-05 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  htmlwidgets   1.6.4   2023-12-06 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  profmem       0.6.0   2020-12-13 [1] RSPM\n#>  profvis     * 0.4.0   2024-09-20 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tibble        3.2.1   2023-03-20 [1] RSPM\n#>  tidyselect    1.2.1   2024-03-11 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"},{"path":"improving-performance.html","id":"improving-performance","chapter":"24 Improving performance","heading":"24 Improving performance","text":"Attaching needed libraries:","code":"\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(purrr)"},{"path":"improving-performance.html","id":"exercises-24.3.1","chapter":"24 Improving performance","heading":"24.1 Exercises 24.3.1","text":"Q1. faster alternatives lm()? specifically designed work larger datasets?A1. Faster alternatives lm() can found visiting CRAN Task View: High-Performance Parallel Computing R page.available options:speedglm::speedlm() (large datasets)speedglm::speedlm() (large datasets)biglm::biglm() (specifically designed data large fit memory)biglm::biglm() (specifically designed data large fit memory)RcppEigen::fastLm() (using Eigen linear algebra library)RcppEigen::fastLm() (using Eigen linear algebra library)High performances can obtained packages especially R linked optimized BLAS, ATLAS. can check information using sessionInfo():Comparing performance different alternatives:results might change depending size dataset, performance benefits accruing bigger dataset.experiment different algorithms find one fits needs dataset best.Q2. package implements version match() ’s faster repeated look ups? much faster ?A2. package (respective function) fastmatch::fmatch()7.documentation function notes:slightly faster built-version uses specialized code, addition retains hash table within table object can re-used, dramatically reducing look-time especially large table.small vector, fmatch() slightly faster, order magnitude., larger vector, fmatch() orders magnitude faster! ⚡can also look hash table:Additionally, fastmatch provides equivalent familiar infix operator:Q3. List four functions (just base R) convert string date time object. strengths weaknesses?A3. four functions convert string date time object:base::.POSIXct()base::.POSIXlt()lubridate::ymd_hms()fasttime::fastPOSIXct()can also compare performance:many packages implement way convert string date time object. , see CRAN Task View: Time Series AnalysisQ4. packages provide ability compute rolling mean?A4. packages respective functions provide way compute rolling mean:RcppRoll::roll_mean()data.table::frollmean()roll::roll_mean()zoo::rollmean()slider::slide_dbl()Q5. alternatives optim()?A5. optim() function provides general-purpose optimization. noted docs:General-purpose optimization based Nelder–Mead, quasi-Newton conjugate-gradient algorithms. includes option box-constrained optimization simulated annealing.many alternatives exact one want choose depend type optimization like .available options can seen CRAN Task View: Optimization Mathematical Programming.","code":"\nsessInfo <- sessionInfo()\nsessInfo$matprod\n#> [1] \"default\"\nsessInfo$LAPACK\n#> [1] \"/usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\"\nlibrary(gapminder)\n\n# having a look at the data\nglimpse(gapminder)\n#> Rows: 1,704\n#> Columns: 6\n#> $ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanist…\n#> $ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia…\n#> $ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982…\n#> $ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, …\n#> $ pop       <int> 8425333, 9240934, 10267083, 11537966, 13…\n#> $ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, …\n\nbench::mark(\n  \"lm\"       = stats::lm(lifeExp ~ continent * gdpPercap, gapminder),\n  \"speedglm\" = speedglm::speedlm(lifeExp ~ continent * gdpPercap, gapminder),\n  \"biglm\"    = biglm::biglm(lifeExp ~ continent * gdpPercap, gapminder),\n  \"fastLm\"   = RcppEigen::fastLm(lifeExp ~ continent * gdpPercap, gapminder),\n  check      = FALSE,\n  iterations = 1000\n)[1:5]\n#> # A tibble: 4 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 lm         858.84µs 898.37µs     1091.    1.26MB\n#> 2 speedglm     1.08ms   1.11ms      882.   70.75MB\n#> 3 biglm      758.73µs 791.16µs     1237.  589.44KB\n#> 4 fastLm       1.04ms   1.06ms      939.    4.54MB\nlibrary(fastmatch, warn.conflicts = FALSE)\n\nsmall_vec <- c(\"a\", \"b\", \"x\", \"m\", \"n\", \"y\")\n\nlength(small_vec)\n#> [1] 6\n\nbench::mark(\n  \"base\" = match(c(\"x\", \"y\"), small_vec),\n  \"fastmatch\" = fmatch(c(\"x\", \"y\"), small_vec)\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base         1.13µs   1.19µs   761811.     2.8KB\n#> 2 fastmatch    1.04µs   1.08µs   874249.    2.66KB\nlarge_vec <- c(rep(c(\"a\", \"b\"), 1e4), \"x\", rep(c(\"m\", \"n\"), 1e6), \"y\")\n\nlength(large_vec)\n#> [1] 2020002\n\nbench::mark(\n  \"base\" = match(c(\"x\", \"y\"), large_vec),\n  \"fastmatch\" = fmatch(c(\"x\", \"y\"), large_vec)\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base        22.21ms  22.37ms      44.5    31.4MB\n#> 2 fastmatch    1.01µs   1.07µs  874815.         0B\nfmatch.hash(c(\"x\", \"y\"), small_vec)\n#> [1] \"a\" \"b\" \"x\" \"m\" \"n\" \"y\"\n#> attr(,\".match.hash\")\n#> <hash table>\nlibrary(fastmatch)\n\nsmall_vec <- c(\"a\", \"b\", \"x\", \"m\", \"n\", \"y\")\n\nc(\"x\", \"y\") %in% small_vec\n#> [1] TRUE TRUE\n\nc(\"x\", \"y\") %fin% small_vec\n#> [1] TRUE TRUE\nbase::as.POSIXct(\"2022-05-05 09:23:22\")\n#> [1] \"2022-05-05 09:23:22 UTC\"\nbase::as.POSIXlt(\"2022-05-05 09:23:22\")\n#> [1] \"2022-05-05 09:23:22 UTC\"\nlubridate::ymd_hms(\"2022-05-05-09-23-22\")\n#> [1] \"2022-05-05 09:23:22 UTC\"\nfasttime::fastPOSIXct(\"2022-05-05 09:23:22\")\n#> [1] \"2022-05-05 09:23:22 UTC\"\nbench::mark(\n  \"as.POSIXct\" = base::as.POSIXct(\"2022-05-05 09:23:22\"),\n  \"as.POSIXlt\" = base::as.POSIXlt(\"2022-05-05 09:23:22\"),\n  \"ymd_hms\" = lubridate::ymd_hms(\"2022-05-05-09-23-22\"),\n  \"fastPOSIXct\" = fasttime::fastPOSIXct(\"2022-05-05 09:23:22\"),\n  check = FALSE,\n  iterations = 1000\n)\n#> # A tibble: 4 × 6\n#>   expression       min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 as.POSIXct   28.47µs  30.15µs    31560.        0B    31.6 \n#> 2 as.POSIXlt   19.23µs  20.39µs    47551.        0B     0   \n#> 3 ymd_hms       2.23ms    2.3ms      433.    21.5KB     3.93\n#> 4 fastPOSIXct   1.17µs   1.26µs   750354.        0B     0"},{"path":"improving-performance.html","id":"exercises-24.4.3","chapter":"24 Improving performance","heading":"24.2 Exercises 24.4.3","text":"Q1. ’s difference rowSums() .rowSums()?A1. documentation functions state:versions initial dot name (.colSums() etc) ‘bare-bones’ versions use programming: apply numeric (like) matrices name result.Looking source code,rowSums() function number checks validate arguments acceptable.rowSums() directly proceeds computation using internal code built R interpreterBut comparable performance:Q2. Make faster version chisq.test() computes chi-square test statistic input two numeric vectors missing values. can try simplifying chisq.test() coding mathematical definition.A2. function supposed accept two numeric vectors without missing values, can make chisq.test() less work removing code corresponding following :checks data frame matrix inputsgoodness--fit testsimulating p-valueschecking missing valuesThis leaves us much simpler, bare bones implementation:, indeed, custom function performs slightly better8 base equivalent:Q3. Can make faster version table() case input two integer vectors missing values? Can use speed chi-square test?A3. order make leaner version table(), can take similar approach trim unnecessary input checks light new API accepting just two vectors without missing values. can remove following components code:extracting data objects entered ... argumentdealing missing valuesother input validation checksIn addition removal, can also use fastmatch::fmatch() instead match():custom function indeed performs slightly better:can also use function custom chi-squared test function see performance improves :, indeed, new version custom function performs even better previously :","code":"\nrowSums\n#> function (x, na.rm = FALSE, dims = 1L) \n#> {\n#>     if (is.data.frame(x)) \n#>         x <- as.matrix(x)\n#>     if (!is.array(x) || length(dn <- dim(x)) < 2L) \n#>         stop(\"'x' must be an array of at least two dimensions\")\n#>     if (dims < 1L || dims > length(dn) - 1L) \n#>         stop(\"invalid 'dims'\")\n#>     p <- prod(dn[-(id <- seq_len(dims))])\n#>     dn <- dn[id]\n#>     z <- if (is.complex(x)) \n#>         .Internal(rowSums(Re(x), prod(dn), p, na.rm)) + (0+1i) * \n#>             .Internal(rowSums(Im(x), prod(dn), p, na.rm))\n#>     else .Internal(rowSums(x, prod(dn), p, na.rm))\n#>     if (length(dn) > 1L) {\n#>         dim(z) <- dn\n#>         dimnames(z) <- dimnames(x)[id]\n#>     }\n#>     else names(z) <- dimnames(x)[[1L]]\n#>     z\n#> }\n#> <bytecode: 0x556e216fa540>\n#> <environment: namespace:base>\n.rowSums\n#> function (x, m, n, na.rm = FALSE) \n#> .Internal(rowSums(x, m, n, na.rm))\n#> <bytecode: 0x556e2644ec90>\n#> <environment: namespace:base>\nx <- cbind(x1 = 3, x2 = c(4:1e4, 2:1e5))\n\nbench::mark(\n  \"rowSums\" = rowSums(x),\n  \".rowSums\" = .rowSums(x, dim(x)[[1]], dim(x)[[2]])\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 rowSums       825µs   1.29ms      895.     859KB\n#> 2 .rowSums      832µs   1.29ms      854.     859KB\nmy_chisq_test <- function(x, y) {\n  x <- table(x, y)\n  n <- sum(x)\n\n  nr <- as.integer(nrow(x))\n  nc <- as.integer(ncol(x))\n\n  sr <- rowSums(x)\n  sc <- colSums(x)\n  E <- outer(sr, sc, \"*\") / n\n  v <- function(r, c, n) c * r * (n - r) * (n - c) / n^3\n  V <- outer(sr, sc, v, n)\n  dimnames(E) <- dimnames(x)\n\n  STATISTIC <- sum((abs(x - E))^2 / E)\n  PARAMETER <- (nr - 1L) * (nc - 1L)\n  PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)\n\n  names(STATISTIC) <- \"X-squared\"\n  names(PARAMETER) <- \"df\"\n\n  structure(\n    list(\n      statistic = STATISTIC,\n      parameter = PARAMETER,\n      p.value = PVAL,\n      method = \"Pearson's Chi-squared test\",\n      observed = x,\n      expected = E,\n      residuals = (x - E) / sqrt(E),\n      stdres = (x - E) / sqrt(V)\n    ),\n    class = \"htest\"\n  )\n}\nm <- c(rep(\"a\", 1000), rep(\"b\", 9000))\nn <- c(rep(c(\"x\", \"y\"), 5000))\n\nbench::mark(\n  \"base\" = chisq.test(m, n)$statistic[[1]],\n  \"custom\" = my_chisq_test(m, n)$statistic[[1]]\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base          884µs    917µs     1073.    1.57MB\n#> 2 custom        689µs    724µs     1316.    5.29MB\nmy_table <- function(x, y) {\n  x_sorted <- sort(unique(x))\n  y_sorted <- sort(unique(y))\n\n  x_length <- length(x_sorted)\n  y_length <- length(y_sorted)\n\n  bin <-\n    fastmatch::fmatch(x, x_sorted) +\n    x_length * fastmatch::fmatch(y, y_sorted) -\n    x_length\n\n  y <- tabulate(bin, x_length * y_length)\n\n  y <- array(\n    y,\n    dim = c(x_length, y_length),\n    dimnames = list(x = x_sorted, y = y_sorted)\n  )\n\n  class(y) <- \"table\"\n  y\n}\nx <- c(rep(\"a\", 1000), rep(\"b\", 9000))\ny <- c(rep(c(\"x\", \"y\"), 5000))\n\n# `check = FALSE` because the custom function has an additional attribute:\n# \".match.hash\"\nbench::mark(\n  \"base\" = table(x, y),\n  \"custom\" = my_table(x, y),\n  check = FALSE\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base          619µs    646µs     1530.     960KB\n#> 2 custom        350µs    361µs     2729.     485KB\nmy_chisq_test2 <- function(x, y) {\n  x <- my_table(x, y)\n  n <- sum(x)\n\n  nr <- as.integer(nrow(x))\n  nc <- as.integer(ncol(x))\n\n  sr <- rowSums(x)\n  sc <- colSums(x)\n  E <- outer(sr, sc, \"*\") / n\n  v <- function(r, c, n) c * r * (n - r) * (n - c) / n^3\n  V <- outer(sr, sc, v, n)\n  dimnames(E) <- dimnames(x)\n\n  STATISTIC <- sum((abs(x - E))^2 / E)\n  PARAMETER <- (nr - 1L) * (nc - 1L)\n  PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)\n\n  names(STATISTIC) <- \"X-squared\"\n  names(PARAMETER) <- \"df\"\n\n  structure(\n    list(\n      statistic = STATISTIC,\n      parameter = PARAMETER,\n      p.value = PVAL,\n      method = \"Pearson's Chi-squared test\",\n      observed = x,\n      expected = E,\n      residuals = (x - E) / sqrt(E),\n      stdres = (x - E) / sqrt(V)\n    ),\n    class = \"htest\"\n  )\n}\nm <- c(rep(\"a\", 1000), rep(\"b\", 9000))\nn <- c(rep(c(\"x\", \"y\"), 5000))\n\nbench::mark(\n  \"base\" = chisq.test(m, n)$statistic[[1]],\n  \"custom\" = my_chisq_test2(m, n)$statistic[[1]]\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base          887µs    925µs     1074.    1.28MB\n#> 2 custom        413µs    430µs     2310.  586.98KB"},{"path":"improving-performance.html","id":"exercises-24.5.1","chapter":"24 Improving performance","heading":"24.3 Exercises 24.5.1","text":"Q1. density functions, e.g., dnorm(), common interface. arguments vectorised ? rnorm(10, mean = 10:1) ?A1. density function family following interface:Reading documentation reveals following parameters vectorized:\nx, q, p, mean, sd.means something like following work:, functions don’t multiple vectorized parameters, won’t. example,following function call generates 10 random numbers (since n = 10) 10 different distributions means supplied vector 10:1.Q2. Compare speed apply(x, 1, sum) rowSums(x) varying sizes x.A2. can write custom function vary number rows matrix extract data frame comparing performance two functions.Plotting data reveals rowSums(x) O(1) behavior, O(n) behavior.Q3. can use crossprod() compute weighted sum? much faster naive sum(x * w)?A3. functions provide way compute weighted sum:benchmarking performance reveals latter significantly faster former!","code":"\ndnorm(x, mean = 0, sd = 1, log = FALSE)\npnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)\nqnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)\nrnorm(n, mean = 0, sd = 1)\nrnorm(c(1, 2, 3), mean = c(0, -1, 5))\n#> [1] 1.124335 0.930398 3.844935\npnorm(c(1, 2, 3), mean = c(0, -1, 5), log.p = c(FALSE, TRUE, TRUE))\n#> [1] 0.84134475 0.99865010 0.02275013\nrnorm(n = 10, mean = 10:1)\n#>  [1]  8.2421770  9.3920474  7.1362118  7.5789906  5.2551688\n#>  [6]  6.0143714  4.6147891  1.1096247  2.8759129 -0.6756857\nbenc_perform <- function(nRow, nCol = 100) {\n  x <- matrix(data = rnorm(nRow * nCol), nrow = nRow, ncol = nCol)\n\n  bench::mark(\n    rowSums(x),\n    apply(x, 1, sum)\n  )[1:5]\n}\n\nnRowList <- list(10, 100, 500, 1000, 5000, 10000, 50000, 100000)\n\nnames(nRowList) <- as.character(nRowList)\n\nbenchDF <- map_dfr(\n  .x = nRowList,\n  .f = ~ benc_perform(.x),\n  .id = \"nRows\"\n) %>%\n  mutate(nRows = as.numeric(nRows))\nggplot(\n  benchDF,\n  aes(\n    x = as.numeric(nRows),\n    y = median,\n    group = as.character(expression),\n    color = as.character(expression)\n  )\n) +\n  geom_point() +\n  geom_line() +\n  labs(\n    x = \"Number of Rows\",\n    y = \"Median Execution Time\",\n    colour = \"Function used\"\n  )\nx <- c(1:6, 2, 3)\nw <- rnorm(length(x))\n\ncrossprod(x, w)[[1]]\n#> [1] 15.94691\nsum(x * w)[[1]]\n#> [1] 15.94691\nbench::mark(\n  crossprod(x, w)[[1]],\n  sum(x * w)[[1]],\n  iterations = 1e6\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression                min   median `itr/sec` mem_alloc\n#>   <bch:expr>           <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 crossprod(x, w)[[1]]    381ns    421ns  2180042.        0B\n#> 2 sum(x * w)[[1]]         430ns    471ns  1926142.        0B"},{"path":"rewriting-r-code-in-c.html","id":"rewriting-r-code-in-c","chapter":"25 Rewriting R code in C++","heading":"25 Rewriting R code in C++","text":"","code":"\nlibrary(Rcpp, warn.conflicts = FALSE)"},{"path":"rewriting-r-code-in-c.html","id":"getting-started-with-c-exercises-25.2.6","chapter":"25 Rewriting R code in C++","heading":"25.1 Getting started with C++ (Exercises 25.2.6)","text":"Q1. basics C++ hand, ’s now great time practice reading writing simple C++ functions. following functions, read code figure corresponding base R function . might understand every part code yet, able figure basics function .A1.f1() mean():f2() cumsum():f3() ():f4() Position():f5() pmin():Q2. practice function writing skills, convert following functions C++. now, assume inputs missing values.().().cumprod(), cummin(), cummax().cumprod(), cummin(), cummax().diff(). Start assuming lag 1, generalise lag n.diff(). Start assuming lag 1, generalise lag n.range().range().var(). Read approaches can take Wikipedia. Whenever implementing numerical algorithm, ’s always good check already known problem.var(). Read approaches can take Wikipedia. Whenever implementing numerical algorithm, ’s always good check already known problem.A2. performance benefits going observed function primitive since already tuned max R performance. , expect performance gain diff() var().()cumprod()cumminC()cummaxC()diff()range()var()","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble f1(NumericVector x) {\n  int n = x.size();\n  double y = 0;\n\n  for(int i = 0; i < n; ++i) {\n    y += x[i] / n;\n  }\n  return y;\n}\n\n// [[Rcpp::export]]\nNumericVector f2(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  out[0] = x[0];\n  for(int i = 1; i < n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nbool f3(LogicalVector x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    if (x[i]) return true;\n  }\n  return false;\n}\n\n// [[Rcpp::export]]\nint f4(Function pred, List x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    LogicalVector res = pred(x[i]);\n    if (res[0]) return i + 1;\n  }\n  return 0;\n}\n\n// [[Rcpp::export]]\nNumericVector f5(NumericVector x, NumericVector y) {\n  int n = std::max(x.size(), y.size());\n  NumericVector x1 = rep_len(x, n);\n  NumericVector y1 = rep_len(y, n);\n\n  NumericVector out(n);\n\n  for (int i = 0; i < n; ++i) {\n    out[i] = std::min(x1[i], y1[i]);\n  }\n\n  return out;\n}\nx <- c(1, 2, 3, 4, 5, 6)\n\nf1(x)\n#> [1] 3.5\nmean(x)\n#> [1] 3.5\nx <- c(1, 3, 5, 6)\n\nf2(x)\n#> [1]  1  4  9 15\ncumsum(x)\n#> [1]  1  4  9 15\nx1 <- c(TRUE, FALSE, FALSE, TRUE)\nx2 <- c(FALSE, FALSE)\n\nf3(x1)\n#> [1] TRUE\nany(x1)\n#> [1] TRUE\n\nf3(x2)\n#> [1] FALSE\nany(x2)\n#> [1] FALSE\nx <- list(\"a\", TRUE, \"m\", 2)\n\nf4(is.numeric, x)\n#> [1] 4\nPosition(is.numeric, x)\n#> [1] 4\nv1 <- c(1, 3, 4, 5, 6, 7)\nv2 <- c(1, 2, 7, 2, 8, 1)\n\nf5(v1, v2)\n#> [1] 1 2 4 2 6 1\npmin(v1, v2)\n#> [1] 1 2 4 2 6 1\nis.primitive(all)\n#> [1] TRUE\nis.primitive(cumprod)\n#> [1] TRUE\nis.primitive(diff)\n#> [1] FALSE\nis.primitive(range)\n#> [1] TRUE\nis.primitive(var)\n#> [1] FALSE#include <vector>\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nbool allC(std::vector<bool> x)\n{\n    for (const auto& xElement : x)\n    {\n        if (!xElement) return false;\n    }\n\n    return true;\n}\nv1 <- rep(TRUE, 10)\nv2 <- c(rep(TRUE, 5), rep(FALSE, 5))\n\nall(v1)\n#> [1] TRUE\nallC(v1)\n#> [1] TRUE\n\nall(v2)\n#> [1] FALSE\nallC(v2)\n#> [1] FALSE\n\n# performance benefits?\nbench::mark(\n  all(c(rep(TRUE, 1000), rep(FALSE, 1000))),\n  allC(c(rep(TRUE, 1000), rep(FALSE, 1000))),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression                                      min\n#>   <bch:expr>                                 <bch:tm>\n#> 1 all(c(rep(TRUE, 1000), rep(FALSE, 1000)))     6.4µs\n#> 2 allC(c(rep(TRUE, 1000), rep(FALSE, 1000)))   7.86µs\n#>     median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1    6.8µs   123037.    15.8KB        0\n#> 2   8.36µs   115607.    15.8KB        0#include <vector>\n\n// [[Rcpp::export]]\nstd::vector<double> cumprodC(const std::vector<double> &x)\n{\n    std::vector<double> out{x};\n\n    for (std::size_t i = 1; i < x.size(); i++)\n    {\n        out[i] = out[i - 1] * x[i];\n    }\n\n    return out;\n}\nv1 <- c(10, 4, 6, 8)\n\ncumprod(v1)\n#> [1]   10   40  240 1920\ncumprodC(v1)\n#> [1]   10   40  240 1920\n\n# performance benefits?\nbench::mark(\n  cumprod(v1),\n  cumprodC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression        min   median `itr/sec` mem_alloc\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 cumprod(v1)      90ns    101ns  8086928.        0B\n#> 2 cumprodC(v1)    681ns    722ns  1249785.    4.12KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0#include <vector>\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::vector<double> cumminC(const std::vector<double> &x)\n{\n    std::vector<double> out{x};\n\n    for (std::size_t i = 1; i < x.size(); i++)\n    {\n        out[i] = (out[i] < out[i - 1]) ? out[i] : out[i - 1];\n    }\n\n    return out;\n}\nv1 <- c(3:1, 2:0, 4:2)\n\ncummin(v1)\n#> [1] 3 2 1 1 1 0 0 0 0\ncumminC(v1)\n#> [1] 3 2 1 1 1 0 0 0 0\n\n# performance benefits?\nbench::mark(\n  cummin(v1),\n  cumminC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression       min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 cummin(v1)     110ns    121ns  6312137.        0B        0\n#> 2 cumminC(v1)    762ns    972ns   960967.    4.12KB        0#include <vector>\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::vector<double> cummaxC(const std::vector<double> &x)\n{\n    std::vector<double> out{x};\n\n    for (std::size_t i = 1; i < x.size(); i++)\n    {\n        out[i] = (out[i] > out[i - 1]) ? out[i] : out[i - 1];\n    }\n    \n    return out;\n}\nv1 <- c(3:1, 2:0, 4:2)\n\ncummax(v1)\n#> [1] 3 3 3 3 3 3 4 4 4\ncummaxC(v1)\n#> [1] 3 3 3 3 3 3 4 4 4\n\n# performance benefits?\nbench::mark(\n  cummax(v1),\n  cummaxC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression       min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 cummax(v1)     100ns    111ns  7424317.        0B        0\n#> 2 cummaxC(v1)    761ns    792ns  1101428.    4.12KB        0#include <vector>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::vector<double> diffC(const std::vector<double> &x, int lag)\n{\n    std::vector<double> vec_start;\n    std::vector<double> vec_lagged;\n    std::vector<double> vec_diff;\n\n    for (std::size_t i = lag; i < x.size(); i++)\n    {\n        vec_lagged.push_back(x[i]);\n    }\n\n    for (std::size_t i = 0; i < (x.size() - lag); i++)\n    {\n        vec_start.push_back(x[i]);\n    }\n\n    std::transform(\n        vec_lagged.begin(), vec_lagged.end(),\n        vec_start.begin(), std::back_inserter(vec_diff),\n        std::minus<double>());\n\n    return vec_diff;\n}\nv1 <- c(1, 2, 4, 8, 13)\nv2 <- c(1, 2, NA, 8, 13)\n\ndiff(v1, 2)\n#> [1] 3 6 9\ndiffC(v1, 2)\n#> [1] 3 6 9\n\ndiff(v2, 2)\n#> [1] NA  6 NA\ndiffC(v2, 2)\n#> [1] NA  6 NA\n\n# performance benefits?\nbench::mark(\n  diff(v1, 2),\n  diffC(v1, 2),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression        min   median `itr/sec` mem_alloc\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 diff(v1, 2)    3.87µs   4.65µs   208383.        0B\n#> 2 diffC(v1, 2)   1.06µs   1.18µs   788015.        0B\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// [[Rcpp::export]]\nstd::vector<double> rangeC(std::vector<double> x)\n{\n    std::vector<double> rangeVec{0.0, 0.0};\n\n    rangeVec.at(0) = *std::min_element(x.begin(), x.end());\n    rangeVec.at(1) = *std::max_element(x.begin(), x.end());\n\n    return rangeVec;\n}\nv1 <- c(10, 4, 6, 8)\n\nrange(v1)\n#> [1]  4 10\nrangeC(v1)\n#> [1]  4 10\n\n# performance benefits?\nbench::mark(\n  range(v1),\n  rangeC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 range(v1)    2.48µs   2.83µs   341507.        0B        0\n#> 2 rangeC(v1) 691.04ns 762.05ns  1186709.    4.12KB        0#include <vector>\n#include <cmath>\n#include <numeric>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\ndouble variance(std::vector<double> x)\n{\n    double sumSquared{0};\n\n    double mean = std::accumulate(x.begin(), x.end(), 0.0) / x.size();\n\n    for (const auto& xElement : x)\n    {\n        sumSquared += pow(xElement - mean, 2.0);\n    }\n\n    return sumSquared / (x.size() - 1);\n}\nv1 <- c(1, 4, 7, 8)\n\nvar(v1)\n#> [1] 10\nvariance(v1)\n#> [1] 10\n\n# performance benefits?\nbench::mark(\n  var(v1),\n  variance(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression        min   median `itr/sec` mem_alloc\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 var(v1)        5.39µs   5.87µs   165394.        0B\n#> 2 variance(v1) 661.01ns 682.02ns  1320929.    4.12KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0"},{"path":"rewriting-r-code-in-c.html","id":"missing-values-exercises-25.4.5","chapter":"25 Rewriting R code in C++","heading":"25.2 Missing values (Exercises 25.4.5)","text":"Q1. Rewrite functions Exercise 25.2.6 deal missing values. na.rm true, ignore missing values. na.rm false, return missing value input contains missing values. good functions practice min(), max(), range(), mean(), var().A1. create version range() deals missing values. principle applies others:Q2. Rewrite cumsum() diff() can handle missing values. Note functions slightly complicated behaviour.A2. cumsum() docs say:NA value x causes corresponding following elements return value NA, integer overflow cumsum (warning).Similarly, diff() docs say:NA’s propagate.Therefore, functions don’t allow removing missing values NAs propagate.seen examples , diffC() already behaves way.Similarly, cumsumC() propagates NAs well.","code":"#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <Rcpp.h>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::vector<double> rangeC_NA(std::vector<double> x, bool removeNA = true)\n{\n    std::vector<double> rangeVec{0.0, 0.0};\n\n    bool naPresent = std::any_of(\n        x.begin(),\n        x.end(),\n        [](double d)\n        { return isnan(d); });\n\n    if (naPresent)\n    {\n        if (removeNA)\n        {\n            std::remove(x.begin(), x.end(), NAN);\n        }\n        else\n        {\n            rangeVec.at(0) = NA_REAL; // NAN;\n            rangeVec.at(1) = NA_REAL; // NAN;\n\n            return rangeVec;\n        }\n    }\n\n    rangeVec.at(0) = *std::min_element(x.begin(), x.end());\n    rangeVec.at(1) = *std::max_element(x.begin(), x.end());\n\n    return rangeVec;\n}\nv1 <- c(10, 4, NA, 6, 8)\n\nrange(v1, na.rm = FALSE)\n#> [1] NA NA\nrangeC_NA(v1, FALSE)\n#> [1] NA NA\n\nrange(v1, na.rm = TRUE)\n#> [1]  4 10\nrangeC_NA(v1, TRUE)\n#> [1]  4 10#include <Rcpp.h>\nusing namespace Rcpp;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nNumericVector cumsumC(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n  \n  out[0] = x[0];\n  for(int i = 1; i < n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  \n  return out;\n}\nv1 <- c(1, 2, 3, 4)\nv2 <- c(1, 2, NA, 4)\n\ncumsum(v1)\n#> [1]  1  3  6 10\ncumsumC(v1)\n#> [1]  1  3  6 10\n\ncumsum(v2)\n#> [1]  1  3 NA NA\ncumsumC(v2)\n#> [1]  1  3 NA NA"},{"path":"rewriting-r-code-in-c.html","id":"standard-template-library-exercises-25.5.7","chapter":"25 Rewriting R code in C++","heading":"25.3 Standard Template Library (Exercises 25.5.7)","text":"Q1. practice using STL algorithms data structures, implement following using R functions C++, using hints provided:A1.median.default() using partial_sort.%% using unordered_set find() count() methods.unique() using unordered_set (challenge: one line!).Note functions comparable. far can see, way get output R version function using unordered_set data structure.can make comparable version using set data structure:min() using std::min(), max() using std::max()..min() using min_element, .max() using max_element.setdiff(), union(), intersect() integers using sorted ranges set_union, set_intersection set_difference.Note following C++ implementations given functions strictly equivalent R versions. far can see, way identical satisfying specifications mentioned question.union()intersect()setdiff()","code":"#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\ndouble medianC(std::vector<double> &x)\n{\n    int middleIndex = static_cast<int>(x.size() / 2);\n\n    std::partial_sort(x.begin(), x.begin() + middleIndex, x.end());\n\n    // for even number of observations\n    if (x.size() % 2 == 0)\n    {\n        return (x[middleIndex - 1] + x[middleIndex]) / 2;\n    }\n\n    return x[middleIndex];\n}\nv1 <- c(1, 3, 3, 6, 7, 8, 9)\nv2 <- c(1, 2, 3, 4, 5, 6, 8, 9)\n\nmedian.default(v1)\n#> [1] 6\nmedianC(v1)\n#> [1] 6\n\nmedian.default(v2)\n#> [1] 4.5\nmedianC(v2)\n#> [1] 4.5\n\n# performance benefits?\nbench::mark(\n  median.default(v2),\n  medianC(v2),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression              min   median `itr/sec` mem_alloc\n#>   <bch:expr>         <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 median.default(v2)     20µs   21.4µs    43839.        0B\n#> 2 medianC(v2)           681ns  711.1ns  1280110.        0B\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0#include <vector>\n#include <unordered_set>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::vector<bool> matchC(const std::vector<double> &x, const std::vector<double> &table)\n{\n    std::unordered_set<double> tableUnique(table.begin(), table.end());\n    std::vector<bool> out;\n\n    for (const auto &xElem : x)\n    {\n        out.push_back(tableUnique.find(xElem) != tableUnique.end() ? true : false);\n    }\n\n    return out;\n}\nx1 <- c(3, 4, 8)\nx2 <- c(1, 2, 3, 3, 4, 4, 5, 6)\n\nx1 %in% x2\n#> [1]  TRUE  TRUE FALSE\nmatchC(x1, x2)\n#> [1]  TRUE  TRUE FALSE\n\n# performance benefits?\nbench::mark(\n  x1 %in% x2,\n  matchC(x1, x2),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression          min   median `itr/sec` mem_alloc\n#>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 x1 %in% x2     862.05ns   1.15µs   715353.        0B\n#> 2 matchC(x1, x2)   1.24µs   1.32µs   700526.    4.12KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0#include <unordered_set>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::unordered_set<double> uniqueC(const std::vector<double> &x)\n{\n    std::unordered_set<double> xSet(x.begin(), x.end());\n\n    return xSet;\n}\nv1 <- c(1, 3, 3, 6, 7, 8, 9)\n\nunique(v1)\n#> [1] 1 3 6 7 8 9\nuniqueC(v1)\n#> [1] 9 8 7 6 3 1#include <set>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::set<double> uniqueC2(const std::vector<double> &x)\n{\n    std::set<double> xSet(x.begin(), x.end());\n\n    return xSet;\n}\nv1 <- c(1, 3, 3, 6, 7, 8, 9)\n\nunique(v1)\n#> [1] 1 3 6 7 8 9\nuniqueC2(v1)\n#> [1] 1 3 6 7 8 9\n\n# performance benefits?\nbench::mark(\n  unique(v1),\n  uniqueC2(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression        min   median `itr/sec` mem_alloc\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 unique(v1)     2.04µs   2.31µs   414515.        0B\n#> 2 uniqueC2(v1) 921.08ns      1µs   862077.    4.12KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nconst double minC(const std::vector<double> &x)\n{\n     return *std::min_element(x.begin(), x.end());\n}\n\n// [[Rcpp::export]]\nconst double maxC(std::vector<double> x)\n{\n     return *std::max_element(x.begin(), x.end());\n}\nv1 <- c(3, 3, 6, 1, 9, 7, 8)\n\nmin(v1)\n#> [1] 1\nminC(v1)\n#> [1] 1\n\n# performance benefits?\nbench::mark(\n  min(v1),\n  minC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 min(v1)       200ns    220ns  3889805.        0B        0\n#> 2 minC(v1)      641ns    691ns  1269191.    4.12KB        0\n\nmax(v1)\n#> [1] 9\nmaxC(v1)\n#> [1] 9\n\n# performance benefits?\nbench::mark(\n  max(v1),\n  maxC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 max(v1)       211ns    231ns  3657657.        0B        0\n#> 2 maxC(v1)      661ns    691ns  1297430.    4.12KB        0#include <vector>\n#include <algorithm>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nint which_maxC(std::vector<double> &x)\n{\n    int maxIndex = std::distance(x.begin(), std::max_element(x.begin(), x.end()));\n  \n    // R is 1-index based, while C++ is 0-index based\n    return maxIndex + 1;\n}\n\n// [[Rcpp::export]]\nint which_minC(std::vector<double> &x)\n{\n    int minIndex = std::distance(x.begin(), std::min_element(x.begin(), x.end()));\n  \n    // R is 1-index based, while C++ is 0-index based\n    return minIndex + 1;\n}\nv1 <- c(3, 3, 6, 1, 9, 7, 8)\n\nwhich.min(v1)\n#> [1] 4\nwhich_minC(v1)\n#> [1] 4\n\n# performance benefits?\nbench::mark(\n  which.min(v1),\n  which_minC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression          min   median `itr/sec` mem_alloc\n#>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 which.min(v1)     380ns    391ns  2261301.        0B\n#> 2 which_minC(v1)    671ns    691ns  1234899.    4.12KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0\n\nwhich.max(v1)\n#> [1] 5\nwhich_maxC(v1)\n#> [1] 5\n\n# performance benefits?\nbench::mark(\n  which.max(v1),\n  which_maxC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression          min   median `itr/sec` mem_alloc\n#>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 which.max(v1)     380ns    411ns  2180867.        0B\n#> 2 which_maxC(v1)    661ns    682ns  1329827.    4.12KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::set<int> unionC(std::vector<int> &v1, std::vector<int> &v2)\n{\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n\n    std::vector<int> union_vec(v1.size() + v2.size());\n    auto it = std::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), union_vec.begin());\n\n    union_vec.resize(it - union_vec.begin());\n    std::set<int> union_set(union_vec.begin(), union_vec.end());\n\n    return union_set;\n}\nv1 <- c(1, 4, 5, 5, 5, 6, 2)\nv2 <- c(4, 1, 6, 8)\n\nunion(v1, v2)\n#> [1] 1 4 5 6 2 8\nunionC(v1, v2)\n#> [1] 1 2 4 5 6 8#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::set<int> intersectC(std::vector<int> &v1, std::vector<int> &v2)\n{\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n\n    std::vector<int> union_vec(v1.size() + v2.size());\n    auto it = std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), union_vec.begin());\n\n    union_vec.resize(it - union_vec.begin());\n    std::set<int> union_set(union_vec.begin(), union_vec.end());\n\n    return union_set;\n}\nv1 <- c(1, 4, 5, 5, 5, 6, 2)\nv2 <- c(4, 1, 6, 8)\n\nintersect(v1, v2)\n#> [1] 1 4 6\nintersectC(v1, v2)\n#> [1] 1 4 6#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::set<int> setdiffC(std::vector<int> &v1, std::vector<int> &v2)\n{\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n\n    std::vector<int> union_vec(v1.size() + v2.size());\n    auto it = std::set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), union_vec.begin());\n\n    union_vec.resize(it - union_vec.begin());\n    std::set<int> union_set(union_vec.begin(), union_vec.end());\n\n    return union_set;\n}\nv1 <- c(1, 4, 5, 5, 5, 6, 2)\nv2 <- c(4, 1, 6, 8)\n\nsetdiff(v1, v2)\n#> [1] 5 2\nsetdiffC(v1, v2)\n#> [1] 2 5"},{"path":"rewriting-r-code-in-c.html","id":"session-information-18","chapter":"25 Rewriting R code in C++","heading":"25.4 Session information","text":"","code":"\nsessioninfo::session_info(include_base = TRUE)\n#> ─ Session info ───────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.4.1 (2024-06-14)\n#>  os       Ubuntu 22.04.5 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2024-10-01\n#>  pandoc   3.4 @ /opt/hostedtoolcache/pandoc/3.4/x64/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────\n#>  package     * version date (UTC) lib source\n#>  base        * 4.4.1   2024-08-22 [3] local\n#>  bench         1.1.3   2023-05-04 [1] RSPM\n#>  bookdown      0.40    2024-07-02 [1] RSPM\n#>  bslib         0.8.0   2024-07-29 [1] RSPM\n#>  cachem        1.1.0   2024-05-16 [1] RSPM\n#>  cli           3.6.3   2024-06-21 [1] RSPM\n#>  compiler      4.4.1   2024-08-22 [3] local\n#>  datasets    * 4.4.1   2024-08-22 [3] local\n#>  digest        0.6.37  2024-08-19 [1] RSPM\n#>  downlit       0.4.4   2024-06-10 [1] RSPM\n#>  evaluate      1.0.0   2024-09-17 [1] RSPM\n#>  fansi         1.0.6   2023-12-08 [1] RSPM\n#>  fastmap       1.2.0   2024-05-15 [1] RSPM\n#>  fs            1.6.4   2024-04-25 [1] RSPM\n#>  glue          1.8.0   2024-09-30 [1] RSPM\n#>  graphics    * 4.4.1   2024-08-22 [3] local\n#>  grDevices   * 4.4.1   2024-08-22 [3] local\n#>  htmltools     0.5.8.1 2024-04-04 [1] RSPM\n#>  jquerylib     0.1.4   2021-04-26 [1] RSPM\n#>  jsonlite      1.8.9   2024-09-20 [1] RSPM\n#>  knitr         1.48    2024-07-07 [1] RSPM\n#>  lifecycle     1.0.4   2023-11-07 [1] RSPM\n#>  magrittr    * 2.0.3   2022-03-30 [1] RSPM\n#>  memoise       2.0.1   2021-11-26 [1] RSPM\n#>  methods     * 4.4.1   2024-08-22 [3] local\n#>  pillar        1.9.0   2023-03-22 [1] RSPM\n#>  pkgconfig     2.0.3   2019-09-22 [1] RSPM\n#>  profmem       0.6.0   2020-12-13 [1] RSPM\n#>  R6            2.5.1   2021-08-19 [1] RSPM\n#>  Rcpp        * 1.0.13  2024-07-17 [1] RSPM\n#>  rlang         1.1.4   2024-06-04 [1] RSPM\n#>  rmarkdown     2.28    2024-08-17 [1] RSPM\n#>  sass          0.4.9   2024-03-15 [1] RSPM\n#>  sessioninfo   1.2.2   2021-12-06 [1] RSPM\n#>  stats       * 4.4.1   2024-08-22 [3] local\n#>  tibble        3.2.1   2023-03-20 [1] RSPM\n#>  tools         4.4.1   2024-08-22 [3] local\n#>  utf8          1.2.4   2023-10-22 [1] RSPM\n#>  utils       * 4.4.1   2024-08-22 [3] local\n#>  vctrs         0.6.5   2023-12-01 [1] RSPM\n#>  withr         3.0.1   2024-07-31 [1] RSPM\n#>  xfun          0.47    2024-08-17 [1] RSPM\n#>  xml2          1.3.6   2023-12-04 [1] RSPM\n#>  yaml          2.3.10  2024-07-26 [1] RSPM\n#> \n#>  [1] /home/runner/work/_temp/Library\n#>  [2] /opt/R/4.4.1/lib/R/site-library\n#>  [3] /opt/R/4.4.1/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────"}]
