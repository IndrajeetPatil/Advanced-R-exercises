[{"path":"index.html","id":"about","chapter":"About","heading":"About","text":"solutions exercises Advanced R (2nd Edition) book.Note reading official solutions manual, detailed explanations guaranteed correct solutions original author also involved writing . provide guarantees. üò¨solutionsMy solutionsOfficial solutionsOfficial solutions","code":""},{"path":"introduction.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"exercises.","code":""},{"path":"names-and-values.html","id":"names-and-values","chapter":"2 Names and values","heading":"2 Names and values","text":"","code":""},{"path":"names-and-values.html","id":"exercises","chapter":"2 Names and values","heading":"2.1 2.2.2 Exercises","text":"Q1. Explain relationshipAll variable names actively bound value.Q2. Function object addressFollowing code verifies indeed calls point underlying function object.Q3. Converting non-syntactic namesThe conversion non-syntactic names syntactic ones can sometimes corrupt data. datasets may require non-syntactic names.suppress behavior, one can set check.names = FALSE.Q4. Behavior make.names()just prepends X non-syntactic names invalid characters (like @) translated ..Q5. .123e1 syntactic name?parsed number.","code":"\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\nlibrary(lobstr)\n\nobj_addr(a)\n#> [1] \"0x176ceaa0\"\nobj_addr(b)\n#> [1] \"0x176ceaa0\"\nobj_addr(c)\n#> [1] \"0x176ceaa0\"\nobj_addr(d)\n#> [1] \"0x16a5ca98\"\nobj_addr(mean)\n#> [1] \"0x17d95650\"\nobj_addr(base::mean)\n#> [1] \"0x17d95650\"\nobj_addr(get(\"mean\"))\n#> [1] \"0x17d95650\"\nobj_addr(evalq(mean))\n#> [1] \"0x17d95650\"\nobj_addr(match.fun(\"mean\"))\n#> [1] \"0x17d95650\"\nmake.names(c(\"123abc\", \"@me\", \"_yu\", \"  gh\", \"else\"))\n#> [1] \"X123abc\" \"X.me\"    \"X_yu\"    \"X..gh\"   \"else.\"\n.123e1 < 1\n#> [1] FALSE"},{"path":"names-and-values.html","id":"exercises-1","chapter":"2 Names and values","heading":"2.2 2.3.6 Exercises","text":"Q1. Usefulness tracemem()tracemem() traces copying objects R, since object created assigned name, nothing trace.Q2. two copies run code?4 double - integer (4L) - modified place.Try integer:still produces copy, Solutions manual:Please aware running code RStudio result additional copies reference environment pane.Q3. Study relationshipQ4. List inside another listFigure :\nhttps://advanced-r-solutions.rbind.io/images/names_values/copy_on_modify_fig2.png","code":"\ntracemem(1:10)\n#> [1] \"<00000000165A2380>\"\nx <- c(1L, 2L, 3L)\ntracemem(x)\n#> [1] \"<000000001F733998>\"\n\nx[[3]] <- 4\n#> tracemem[0x000000001f733998 -> 0x000000001f5ce5b8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local \n#> tracemem[0x000000001f5ce5b8 -> 0x0000000031a2afc8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\nx <- c(1L, 2L, 3L)\ntracemem(x)\n#> [1] \"<000000001F217360>\"\n\nx[[3]] <- 4L\n#> tracemem[0x000000001f217360 -> 0x000000001f3c4548]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\n\nref(a)\n#> [1:0x1e0b1440] <int>\n\nref(b)\n#> o [1:0x31a1eba8] <list> \n#> +-[2:0x1e0b1440] <int> \n#> \\-[2:0x1e0b1440]\n\nref(c)\n#> o [1:0x31a38078] <list> \n#> +-o [2:0x31a1eba8] <list> \n#> | +-[3:0x1e0b1440] <int> \n#> | \\-[3:0x1e0b1440] \n#> +-[3:0x1e0b1440] \n#> \\-[4:0x1e181208] <int>\nx <- list(1:10)\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nobj_addr(x)\n#> [1] \"0x1f90e068\"\n\nx[[2]] <- x\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> [[2]]\n#> [[2]][[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nobj_addr(x)\n#> [1] \"0x1f530a28\"\n\nref(x)\n#> o [1:0x1f530a28] <list> \n#> +-[2:0x1e360c20] <int> \n#> \\-o [3:0x1f90e068] <list> \n#>   \\-[2:0x1e360c20]"},{"path":"names-and-values.html","id":"exercises-2","chapter":"2 Names and values","heading":"2.3 2.4.1 Exercises","text":"Q1. Object size difference {base} lobstrThis function‚Ä¶detect elements list shared.Q2. Misleading object sizeThese functions externally created objects R, always available, doesn‚Äôt make much sense measure size.Nevertheless, ‚Äôs still interesting addition size list objects.Q3. Predict object sizes","code":"\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#> 8005648 bytes\n\nobj_size(y)\n#> 80,896 B\nfuns <- list(mean, sd, var)\nobj_size(funs)\n#> 17,608 B\nobj_size(mean)\n#> 1,184 B\nobj_size(sd)\n#> 4,480 B\nobj_size(var)\n#> 12,472 B\n\nobj_size(mean) + obj_size(sd) + obj_size(var)\n#> 18,136 B\na <- runif(1e6)\nobj_size(a)\n#> 8,000,048 B\n\nb <- list(a, a)\nobj_size(b)\n#> 8,000,112 B\nobj_size(a, b)\n#> 8,000,112 B\n\nb[[1]][[1]] <- 10\nobj_size(b)\n#> 16,000,160 B\nobj_size(a, b)\n#> 16,000,160 B\n\nb[[2]][[1]] <- 10\nobj_size(b)\n#> 16,000,160 B\nobj_size(a, b)\n#> 24,000,208 B"},{"path":"names-and-values.html","id":"exercises-3","chapter":"2 Names and values","heading":"2.4 2.5.3 Exercises","text":"Q1. circular list?Copy--modify prevents creation circular list.Q2. Performance loops without creating copiesLet‚Äôs first microbenchmark functions create copies varying lengths number columns.Plotting benchmarks reveals performance gets increasingly worse number dataframes increases:Q3. tracemem() environmentIt doesn‚Äôt work documentation makes clear :useful trace NULL, environments, promises, weak references, external pointer objects, duplicated","code":"\nx <- list()\n\nobj_addr(x)\n#> [1] \"0x32697e58\"\n\ntracemem(x)\n#> [1] \"<0000000032697E58>\"\n\nx[[1]] <- x\n#> tracemem[0x0000000032697e58 -> 0x00000000327cb010]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\n\nobj_addr(x[[1]])\n#> [1] \"0x32697e58\"\nlibrary(bench)\nlibrary(tidyverse)\n\ngenerateDataFrame <- function(ncol) {\n  as.data.frame(matrix(runif(100 * ncol), nrow = 100))\n}\n\nwithCopy <- function(ncol) {\n  x <- generateDataFrame(ncol)\n  medians <- vapply(x, median, numeric(1))\n\n  for (i in seq_along(medians)) {\n    x[[i]] <- x[[i]] - medians[[i]]\n  }\n\n  return(x)\n}\n\nwithoutCopy <- function(ncol) {\n  x <- generateDataFrame(ncol)\n  medians <- vapply(x, median, numeric(1))\n\n  y <- as.list(x)\n\n  for (i in seq_along(medians)) {\n    y[[i]] <- y[[i]] - medians[[i]]\n  }\n\n  return(y)\n}\n\nbenchComparison <- function(ncol) {\n  bench::mark(\n    withCopy(ncol),\n    withoutCopy(ncol),\n    iterations = 100,\n    check = FALSE\n  ) %>%\n    dplyr::select(expression:total_time)\n}\n\nnColList <- list(1, 10, 50, 100, 250, 500, 1000)\n\nnames(nColList) <- as.character(nColList)\n\nbenchDf <- purrr::map_dfr(\n  .x = nColList,\n  .f = benchComparison,\n  .id = \"nColumns\"\n)\nggplot(benchDf,\n       aes(\n         x = as.numeric(nColumns),\n         y = median,\n         group = as.character(expression),\n         color = as.character(expression)\n       )) +\n  geom_line() +\n  labs(\n    x = \"Number of Columns\",\n    y = \"Median Execution Time (ms)\",\n    colour = \"Type of function\"\n  )\ne <- rlang::env(a = 1, b = \"3\")\ntracemem(e)\n#> Error in tracemem(e): 'tracemem' is not useful for promise and environment objects"},{"path":"vectors.html","id":"vectors","chapter":"3 Vectors","heading":"3 Vectors","text":"","code":""},{"path":"vectors.html","id":"exercise-3.2.5","chapter":"3 Vectors","heading":"3.1 Exercise 3.2.5","text":"Q1. Create raw complex scalarsThe raw type holds raw bytes. example,can use also figure differences similar characters:Complex vectors can used represent (surprise!) complex numbers.Example complex scalar:Q2. Vector coercion rulesUsually, general type take precedence.Let‚Äôs try examples.Q3. Comparisons different typesThe coercion vectors reveal comparisons return results .Q4. NA defaults \"logical\" typeThe \"logical\" type lowest coercion hierarchy.NA defaulting type (e.g.¬†\"numeric\") mean time missing element vector, rest elements converted type higher hierarchy, problematic types lower hierarchy.Q5. Misleading variants .* functionsis.atomic()functions checks object atomic type (NULL), atomic vector.Quoting docs:.atomic true atomic types (‚Äúlogical‚Äù, ‚Äúinteger‚Äù, ‚Äúnumeric‚Äù, ‚Äúcomplex‚Äù, ‚Äúcharacter‚Äù ‚Äúraw‚Äù) NULL..numeric()documentation says:.numeric return true base type class double integer values can reasonably regarded numericTherefore, function checks double integer base types types based top types (factor, Date, POSIXt, difftime)..vector()documentation function reveals:.vector returns TRUE x vector specified mode attributes names. returns FALSE otherwise.Thus, function can incorrect presence object attributes names.better way check vector:","code":"\nx <- \"A string\"\n\n(y <- charToRaw(x))\n#> [1] 41 20 73 74 72 69 6e 67\n\ntypeof(y)\n#> [1] \"raw\"\ncharToRaw(\"‚Äì\") # en-dash\n#> [1] 96\ncharToRaw(\"‚Äî\") # em-dash\n#> [1] 97\n(x <- complex(length.out = 1, real = 1, imaginary = 8))\n#> [1] 1+8i\n\ntypeof(x)\n#> [1] \"complex\"\nc(1, FALSE)\n#> [1] 1 0\n\nc(\"a\", 1)\n#> [1] \"a\" \"1\"\n\nc(TRUE, 1L)\n#> [1] 1 1\nc(1.0, 1L)\n#> [1] 1 1\n\nc(1.0, \"1.0\")\n#> [1] \"1\"   \"1.0\"\n\nc(TRUE, \"1.0\")\n#> [1] \"TRUE\" \"1.0\"\n1 == \"1\"\n#> [1] TRUE\n\nc(1, \"1\")\n#> [1] \"1\" \"1\"\n-1 < FALSE\n#> [1] TRUE\n\nc(-1, FALSE)\n#> [1] -1  0\n\"one\" < 2\n#> [1] FALSE\n\nc(\"one\", 2)\n#> [1] \"one\" \"2\"\n\nsort(c(\"one\", 2))\n#> [1] \"2\"   \"one\"\ntypeof(NA)\n#> [1] \"logical\"\n\nc(FALSE, NA_character_)\n#> [1] \"FALSE\" NA\nis.atomic(NULL)\n#> [1] TRUE\n\nis.vector(NULL)\n#> [1] FALSE\nx <- factor(c(1L, 2L))\n\nis.numeric(x)\n#> [1] FALSE\nx <- c(\"x\" = 1, \"y\" = 2)\n\nis.vector(x)\n#> [1] TRUE\n\nattr(x, \"m\") <- \"abcdef\"\n\nis.vector(x)\n#> [1] FALSE\nis.null(dim(x))\n#> [1] TRUE"},{"path":"vectors.html","id":"exercise-3.3.4","chapter":"3 Vectors","heading":"3.2 Exercise 3.3.4","text":"Q1. Reading source codeQ2. 1-dimensional vectorDimensions 1-dimensional vector NULL.NROW() NCOL() helpful getting dimensions 1D vectors treating matrices dataframes.Q3. Difference vectors arrays1:5 dimensionless vectorx1, x2, x3 one-dimensional arrayWe can look dim attributeQ4. structure()?attributes (emphasis mine):Note attributes (namely class, comment, dim, dimnames, names, row.names tsp) treated specially restrictions values can set.","code":"\nsetNames\n#> function (object = nm, nm) \n#> {\n#>     names(object) <- nm\n#>     object\n#> }\n#> <bytecode: 0x00000000179ab218>\n#> <environment: namespace:stats>\n\nsetNames(c(1, 2), c(\"a\", \"b\"))\n#> a b \n#> 1 2\nunname\n#> function (obj, force = FALSE) \n#> {\n#>     if (!is.null(names(obj))) \n#>         names(obj) <- NULL\n#>     if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n#>         dimnames(obj) <- NULL\n#>     obj\n#> }\n#> <bytecode: 0x0000000015613698>\n#> <environment: namespace:base>\n\nA <- provideDimnames(N <- array(1:24, dim = 2:4))\n\nunname(A, force = TRUE)\n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\n#> \n#> , , 3\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   13   15   17\n#> [2,]   14   16   18\n#> \n#> , , 4\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   19   21   23\n#> [2,]   20   22   24\nx <- character(0)\n\ndim(x)\n#> NULL\n\nnrow(x)\n#> NULL\nNROW(x)\n#> [1] 0\n\nncol(x)\n#> NULL\nNCOL(x)\n#> [1] 1\n(x <- 1:5)\n#> [1] 1 2 3 4 5\ndim(x)\n#> NULL\n\n(x1 <- array(1:5, c(1, 1, 5)))\n#> , , 1\n#> \n#>      [,1]\n#> [1,]    1\n#> \n#> , , 2\n#> \n#>      [,1]\n#> [1,]    2\n#> \n#> , , 3\n#> \n#>      [,1]\n#> [1,]    3\n#> \n#> , , 4\n#> \n#>      [,1]\n#> [1,]    4\n#> \n#> , , 5\n#> \n#>      [,1]\n#> [1,]    5\n(x2 <- array(1:5, c(1, 5, 1)))\n#> , , 1\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n(x3 <- array(1:5, c(5, 1, 1)))\n#> , , 1\n#> \n#>      [,1]\n#> [1,]    1\n#> [2,]    2\n#> [3,]    3\n#> [4,]    4\n#> [5,]    5\n\ndim(x1)\n#> [1] 1 1 5\ndim(x2)\n#> [1] 1 5 1\ndim(x3)\n#> [1] 5 1 1\nstructure(1:5, x = \"my attribute\")\n#> [1] 1 2 3 4 5\n#> attr(,\"x\")\n#> [1] \"my attribute\"\n\nstructure(1:5, comment = \"my attribute\")\n#> [1] 1 2 3 4 5"},{"path":"vectors.html","id":"exercise-3.4.5","chapter":"3 Vectors","heading":"3.3 Exercise 3.4.5","text":"Q1. table() functiontable() returns array integer type dimensions scale number variables present.Q2. Factor reversalIts levels changes underlying integer values remain .Q3. Factor reversal-2f2: underlying integers reversed, levels remain unchanged.\nf3: levels underlying integers reversed.","code":"\n(x <- table(mtcars$am))\n#> \n#>  0  1 \n#> 19 13\n(y <- table(mtcars$am, mtcars$cyl))\n#>    \n#>      4  6  8\n#>   0  3  4 12\n#>   1  8  3  2\n(z <- table(mtcars$am, mtcars$cyl, mtcars$vs))\n#> , ,  = 0\n#> \n#>    \n#>      4  6  8\n#>   0  0  0 12\n#>   1  1  3  2\n#> \n#> , ,  = 1\n#> \n#>    \n#>      4  6  8\n#>   0  3  4  0\n#>   1  7  0  0\n\n# type\npurrr::map(list(x, y, z), typeof)\n#> [[1]]\n#> [1] \"integer\"\n#> \n#> [[2]]\n#> [1] \"integer\"\n#> \n#> [[3]]\n#> [1] \"integer\"\n\n# attributes\npurrr::map(list(x, y, z), attributes)\n#> [[1]]\n#> [[1]]$dim\n#> [1] 2\n#> \n#> [[1]]$dimnames\n#> [[1]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> \n#> [[1]]$class\n#> [1] \"table\"\n#> \n#> \n#> [[2]]\n#> [[2]]$dim\n#> [1] 2 3\n#> \n#> [[2]]$dimnames\n#> [[2]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> [[2]]$dimnames[[2]]\n#> [1] \"4\" \"6\" \"8\"\n#> \n#> \n#> [[2]]$class\n#> [1] \"table\"\n#> \n#> \n#> [[3]]\n#> [[3]]$dim\n#> [1] 2 3 2\n#> \n#> [[3]]$dimnames\n#> [[3]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> [[3]]$dimnames[[2]]\n#> [1] \"4\" \"6\" \"8\"\n#> \n#> [[3]]$dimnames[[3]]\n#> [1] \"0\" \"1\"\n#> \n#> \n#> [[3]]$class\n#> [1] \"table\"\nf1 <- factor(letters)\nf1\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> 26 Levels: a b c d e f g h i j k l m n o p q r s t u ... z\nas.integer(f1)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n#> [19] 19 20 21 22 23 24 25 26\n\nlevels(f1) <- rev(levels(f1))\nf1\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> 26 Levels: z y x w v u t s r q p o n m l k j i h g f ... a\nas.integer(f1)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n#> [19] 19 20 21 22 23 24 25 26\nf2 <- rev(factor(letters))\nf2\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> 26 Levels: a b c d e f g h i j k l m n o p q r s t u ... z\nas.integer(f2)\n#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9\n#> [19]  8  7  6  5  4  3  2  1\n\nf3 <- factor(letters, levels = rev(letters))\nf3\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> 26 Levels: z y x w v u t s r q p o n m l k j i h g f ... a\nas.integer(f3)\n#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9\n#> [19]  8  7  6  5  4  3  2  1"},{"path":"vectors.html","id":"exercise-3.5.4","chapter":"3 Vectors","heading":"3.4 Exercise 3.5.4","text":"Q1. Differences list atomic vectorQ2. Converting list atomic vectorList already vector, .vector going change anything, .atomic.vector. Thus need use unlist().Q3. Comparing c() unlist() date datetimeBehavior c(): Works expected. odd thing strips tzone attribute.Behavior unlist(): Removes attributes left underlying double representations objects.","code":"\nx <- list(a = 1, b = 2)\n\nis.vector(x)\n#> [1] TRUE\nis.atomic(x)\n#> [1] FALSE\n\nas.vector(x)\n#> $a\n#> [1] 1\n#> \n#> $b\n#> [1] 2\n\nunlist(x)\n#> a b \n#> 1 2\n# creating a date and datetime\ndate <- as.Date(\"1947-08-15\")\ndatetime <- as.POSIXct(\"1950-01-26 00:01\", tz = \"UTC\")\n\n# check attributes\nattributes(date)\n#> $class\n#> [1] \"Date\"\nattributes(datetime)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\n\n# check their underlying double representation\nas.double(date) # number of days since the Unix epoch 1970-01-01\n#> [1] -8175\nas.double(datetime) # number of seconds since then\n#> [1] -628991940\nc(date, datetime)\n#> [1] \"1947-08-15\" \"1950-01-26\"\n\nattributes(c(date, datetime))\n#> $class\n#> [1] \"Date\"\n\nc(datetime, date)\n#> [1] \"1950-01-26 00:01:00 UTC\" \"1947-08-15 00:00:00 UTC\"\n\nattributes(c(datetime, date))\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\nunlist(list(date, datetime))\n#> [1]      -8175 -628991940\n\nunlist(list(datetime, date))\n#> [1] -628991940      -8175"},{"path":"vectors.html","id":"exercise-3.6.8","chapter":"3 Vectors","heading":"3.5 Exercise 3.6.8","text":"Q1. Data frame 0 dimensionsData frame 0 rows possible. basically list vector length 0.Data frame 0 columns possible. empty list.one go:Q2. Non-unique rownamesIf attempt set rownames unique, work.Q3. Transposing dataframesTransposing dataframe transforms matrix coerces elements type.Q4. .matrix() dataframeThe return type .matrix() depends dataframe column types.documentation data.matrix():Return matrix obtained converting variables data frame numeric mode binding together columns matrix.data.matrix() always returns numeric matrix:","code":"\ndata.frame(x = numeric(0))\n#> [1] x\n#> <0 rows> (or 0-length row.names)\ndata.frame(row.names = 1)\n#> data frame with 0 columns and 1 row\ndata.frame()\n#> data frame with 0 columns and 0 rows\n\ndim(data.frame())\n#> [1] 0 0\ndata.frame(row.names = c(1, 1))\n#> Error in data.frame(row.names = c(1, 1)): duplicate row.names: 1\n# original\n(df <- head(iris))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n\n# transpose\nt(df)\n#>              1        2        3        4        5       \n#> Sepal.Length \"5.1\"    \"4.9\"    \"4.7\"    \"4.6\"    \"5.0\"   \n#> Sepal.Width  \"3.5\"    \"3.0\"    \"3.2\"    \"3.1\"    \"3.6\"   \n#> Petal.Length \"1.4\"    \"1.4\"    \"1.3\"    \"1.5\"    \"1.4\"   \n#> Petal.Width  \"0.2\"    \"0.2\"    \"0.2\"    \"0.2\"    \"0.2\"   \n#> Species      \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\"\n#>              6       \n#> Sepal.Length \"5.4\"   \n#> Sepal.Width  \"3.9\"   \n#> Petal.Length \"1.7\"   \n#> Petal.Width  \"0.4\"   \n#> Species      \"setosa\"\n\n# transpose of a transpose\nt(t(df))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1 \"5.1\"        \"3.5\"       \"1.4\"        \"0.2\"      \n#> 2 \"4.9\"        \"3.0\"       \"1.4\"        \"0.2\"      \n#> 3 \"4.7\"        \"3.2\"       \"1.3\"        \"0.2\"      \n#> 4 \"4.6\"        \"3.1\"       \"1.5\"        \"0.2\"      \n#> 5 \"5.0\"        \"3.6\"       \"1.4\"        \"0.2\"      \n#> 6 \"5.4\"        \"3.9\"       \"1.7\"        \"0.4\"      \n#>   Species \n#> 1 \"setosa\"\n#> 2 \"setosa\"\n#> 3 \"setosa\"\n#> 4 \"setosa\"\n#> 5 \"setosa\"\n#> 6 \"setosa\"\n\n# is it a dataframe?\nis.data.frame(df)\n#> [1] TRUE\nis.data.frame(t(df))\n#> [1] FALSE\nis.data.frame(t(t(df)))\n#> [1] FALSE\n\n# check type\ntypeof(df)\n#> [1] \"list\"\ntypeof(t(df))\n#> [1] \"character\"\ntypeof(t(t(df)))\n#> [1] \"character\"\n\n# check dimensions\ndim(df)\n#> [1] 6 5\ndim(t(df))\n#> [1] 5 6\ndim(t(t(df)))\n#> [1] 6 5\n# example with mixed types (coerced to character)\n(df <- head(iris))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n\nas.matrix(df)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1 \"5.1\"        \"3.5\"       \"1.4\"        \"0.2\"      \n#> 2 \"4.9\"        \"3.0\"       \"1.4\"        \"0.2\"      \n#> 3 \"4.7\"        \"3.2\"       \"1.3\"        \"0.2\"      \n#> 4 \"4.6\"        \"3.1\"       \"1.5\"        \"0.2\"      \n#> 5 \"5.0\"        \"3.6\"       \"1.4\"        \"0.2\"      \n#> 6 \"5.4\"        \"3.9\"       \"1.7\"        \"0.4\"      \n#>   Species \n#> 1 \"setosa\"\n#> 2 \"setosa\"\n#> 3 \"setosa\"\n#> 4 \"setosa\"\n#> 5 \"setosa\"\n#> 6 \"setosa\"\n\nstr(as.matrix(df))\n#>  chr [1:6, 1:5] \"5.1\" \"4.9\" \"4.7\" \"4.6\" \"5.0\" \"5.4\" ...\n#>  - attr(*, \"dimnames\")=List of 2\n#>   ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ : chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ...\n\n# another example (no such coercion)\nBOD\n#>   Time demand\n#> 1    1    8.3\n#> 2    2   10.3\n#> 3    3   19.0\n#> 4    4   16.0\n#> 5    5   15.6\n#> 6    7   19.8\n\nas.matrix(BOD)\n#>      Time demand\n#> [1,]    1    8.3\n#> [2,]    2   10.3\n#> [3,]    3   19.0\n#> [4,]    4   16.0\n#> [5,]    5   15.6\n#> [6,]    7   19.8\ndata.matrix(df)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2       1\n#> 2          4.9         3.0          1.4         0.2       1\n#> 3          4.7         3.2          1.3         0.2       1\n#> 4          4.6         3.1          1.5         0.2       1\n#> 5          5.0         3.6          1.4         0.2       1\n#> 6          5.4         3.9          1.7         0.4       1\n\nstr(data.matrix(df))\n#>  num [1:6, 1:5] 5.1 4.9 4.7 4.6 5 5.4 3.5 3 3.2 3.1 ...\n#>  - attr(*, \"dimnames\")=List of 2\n#>   ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ : chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ..."},{"path":"subsetting.html","id":"subsetting","chapter":"4 Subsetting","heading":"4 Subsetting","text":"","code":""},{"path":"subsetting.html","id":"exercise-4.2.6","chapter":"4 Subsetting","heading":"4.1 Exercise 4.2.6","text":"Q1. Fix following common data frame subsetting errors:A1. Fixed versions commands:Q2. following code yield five missing values?A2. two reasons:default type NA R logical type.R recycles indexes match length vector.Q3. upper.tri() return? subsetting matrix work? need additional subsetting rules describe behaviour?A3. documentation upper.tri() states-Returns matrix logicals size given matrix entries TRUE upper triangleThat , upper.tri() return matrix logicals.used matrix subsetting, logical matrix returns vector:Q4. mtcars[1:20] return error? differ similar mtcars[1:20, ]?indexed like list, data frame columns given indices selected.mtcars[1:20] doesn‚Äôt work 11 columns mtcars dataset.hand, mtcars[1:20, ] indexes dataframe like matrix, indeed 20 rows mtcars, columns rows selected.Q5. Implement function extracts diagonal entries matrix (behave like diag(x) x matrix).A5. can combine existing functions advantage:Q6. df[.na(df)] <- 0 ? work?A6. command replaces every instance NA dataframe 0..na(df) produces matrix logical values, provides way select assign.","code":"mtcars[mtcars$cyl = 4, ]\nmtcars[-1:4, ]\nmtcars[mtcars$cyl <= 5]\nmtcars[mtcars$cyl == 4 | 6, ]\nmtcars[mtcars$cyl == 4, ]\nmtcars[-(1:4), ]\nmtcars[mtcars$cyl <= 5, ]\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\nx <- 1:5\nx[NA]\n#> [1] NA NA NA NA NA\ntypeof(NA)\n#> [1] \"logical\"\nx <- 1:5\nx[c(TRUE, FALSE)] # recycled to c(TRUE, FALSE, TRUE, FALSE, TRUE)\n#> [1] 1 3 5\nx <- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]\n(x <- outer(1:5, 1:5, FUN = \"*\"))\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]    2    4    6    8   10\n#> [3,]    3    6    9   12   15\n#> [4,]    4    8   12   16   20\n#> [5,]    5   10   15   20   25\n\nupper.tri(x)\n#>       [,1]  [,2]  [,3]  [,4]  [,5]\n#> [1,] FALSE  TRUE  TRUE  TRUE  TRUE\n#> [2,] FALSE FALSE  TRUE  TRUE  TRUE\n#> [3,] FALSE FALSE FALSE  TRUE  TRUE\n#> [4,] FALSE FALSE FALSE FALSE  TRUE\n#> [5,] FALSE FALSE FALSE FALSE FALSE\nx[upper.tri(x)]\n#>  [1]  2  3  6  4  8 12  5 10 15 20\nhead(mtcars[1:2])\n#>                    mpg cyl\n#> Mazda RX4         21.0   6\n#> Mazda RX4 Wag     21.0   6\n#> Datsun 710        22.8   4\n#> Hornet 4 Drive    21.4   6\n#> Hornet Sportabout 18.7   8\n#> Valiant           18.1   6\nnrow(mtcars[1:20, ])\n#> [1] 20\nx[!upper.tri(x) & !lower.tri(x)]\n#> [1]  1  4  9 16 25\n\ndiag(x)\n#> [1]  1  4  9 16 25\n(df <- tibble(x = c(1, 2, NA), y = c(NA, 5, NA)))\n#> # A tibble: 3 x 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     1    NA\n#> 2     2     5\n#> 3    NA    NA\n\nis.na(df)\n#>          x     y\n#> [1,] FALSE  TRUE\n#> [2,] FALSE FALSE\n#> [3,]  TRUE  TRUE\n\nclass(is.na(df))\n#> [1] \"matrix\" \"array\""},{"path":"subsetting.html","id":"exercise-4.3.5","chapter":"4 Subsetting","heading":"4.2 Exercise 4.3.5","text":"Q1. Brainstorm many ways possible extract third value cyl variable mtcars dataset.A1. Possible ways :Q2. Given linear model, e.g., mod <- lm(mpg ~ wt, data = mtcars), extract residual degrees freedom. extract R squared model summary (summary(mod))A2. Specified linear model:extracting residual degrees freedomextracting R squared model summary","code":"\nmtcars$cyl[[3]]\n#> [1] 4\nmtcars[, \"cyl\"][[3]]\n#> [1] 4\nmtcars[[\"cyl\"]][[3]]\n#> [1] 4\n\nmtcars[3, ]$cyl\n#> [1] 4\nmtcars[3, \"cyl\"]\n#> [1] 4\nmtcars[3, ][[\"cyl\"]]\n#> [1] 4\n\nmtcars[[c(2, 3)]]\n#> [1] 4\nmtcars[3, 2]\n#> [1] 4\nmod <- lm(mpg ~ wt, data = mtcars)\nmod$df.residual \n#> [1] 30\n\n# or \n\nmod[[\"df.residual\"]]\n#> [1] 30\nsummary(mod)$r.squared\n#> [1] 0.7528328"},{"path":"control-flow.html","id":"control-flow","chapter":"5 Control flow","heading":"5 Control flow","text":"","code":""},{"path":"control-flow.html","id":"exercise-5.2.4","chapter":"5 Control flow","heading":"5.1 Exercise 5.2.4","text":"Q1. ifelse() return typeIt‚Äôs type unstable, .e.¬†type return depend type condition (yes , .e.), works cases test argument evaluated logical type.Additionally, test doesn‚Äôt resolve logical type, try coerce whatever resulting type logical:Q2. following code work?can seen, code works tests successfully coerced logical type.","code":"\nifelse(TRUE, 1, \"no\") # numeric returned\n#> [1] 1\nifelse(FALSE, 1, \"no\") # character returned\n#> [1] \"no\"\nifelse(NA, 1, \"no\")\n#> [1] NA\n# will work\nifelse(\"TRUE\", 1, \"no\")\n#> [1] 1\nifelse(\"true\", 1, \"no\")\n#> [1] 1\n\n# won't work\nifelse(\"tRuE\", 1, \"no\")\n#> [1] NA\nifelse(NaN, 1, \"no\")\n#> [1] NA\nx <- 1:10\nas.logical(length(1:10))\n#> [1] TRUE\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"not empty\"\n\nx <- numeric()\nas.logical(length(numeric()))\n#> [1] FALSE\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"empty\""},{"path":"control-flow.html","id":"exercise-5.3.3","chapter":"5 Control flow","heading":"5.2 Exercise 5.3.3","text":"Q1. work?works 1:length(x) goes ways; case, 1 0. , since --bound values atomic vectors NA, related operations also lead NA.way avoid unintended behavior :Q2. Index vectorsSurprisingly (least ), x takes values vector xs:Q3. Index increaseIn loop - like loop - index updated beginning iteration.","code":"\nx <- numeric()\nout <- vector(\"list\", length(x))\n\nfor (i in 1:length(x)) {\n  print(x[i])\n  print(out[i])\n\n  out[i] <- x[i]^2\n}\n#> [1] NA\n#> [[1]]\n#> NULL\n#> \n#> numeric(0)\n#> list()\n\nout\n#> [[1]]\n#> [1] NA\nx <- numeric()\nout <- vector(\"list\", length(x))\n\nfor (i in 1:seq_along(x)) {\n  out[i] <- x[i]^2\n}\n#> Error in 1:seq_along(x): argument of length 0\n\nout\n#> list()\n# xs <- c(1, 2, 3)\nxs <- c(4, 5, 6)\nfor (x in xs) {\n  print(x)\n  xs <- c(xs, x * 2)\n}\n#> [1] 4\n#> [1] 5\n#> [1] 6\n\nxs\n#> [1]  4  5  6  8 10 12\nfor (i in 1:3) {\n  cat(\"before: \", i, \"\\n\")\n  i <- i * 2\n  cat(\"after: \", i, \"\\n\")\n}\n#> before:  1 \n#> after:  2 \n#> before:  2 \n#> after:  4 \n#> before:  3 \n#> after:  6\n\ni <- 1\nwhile (i < 3) {\n  cat(\"before: \", i, \"\\n\")\n  i <- i * 2\n  cat(\"after: \", i, \"\\n\")\n}\n#> before:  1 \n#> after:  2 \n#> before:  2 \n#> after:  4"},{"path":"functions.html","id":"functions","chapter":"6 Functions","heading":"6 Functions","text":"","code":""},{"path":"functions.html","id":"exercise-6.2.5","chapter":"6 Functions","heading":"6.1 Exercise 6.2.5","text":"Q1. Function namesGiven name, match.fun() lets find function., given function, doesn‚Äôt make sense find name R can multiple names bound function.Q2. Correct way call anonymous functionsThis correct since function evaluate 3(), syntactically allowed since literals can‚Äôt treated like functions.correct.Q3. Scan code opportunities use anonymous functionSelf activity.Q4. Detecting functions primitive functionsUse .function() check object function:Use .primitive() check function primitive:Q5. Detecting functions primitive functionsWhich base function arguments?scan() function arguments.many base functions arguments? ‚Äôs special functions?time writing, 253 base functions arguments. primitive functionsHow adapt code find primitive functions?Q6. Important components functionExcept primitive functions, functions 3 important components:formals()body()environment()Q7. Printing function environmentAll package functions print environment:two exceptions rule:primitive functions:functions created global environment:","code":"\nmatch.fun(\"mean\")\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x0000000017d95328>\n#> <environment: namespace:base>\nf1 <- function(x) mean(x)\nf2 <- f1\n\nmatch.fun(\"f1\")\n#> function(x) mean(x)\n\nmatch.fun(\"f2\")\n#> function(x) mean(x)\n(function(x) 3())()\n#> Error in (function(x) 3())(): attempt to apply non-function\n(function(x) 3)()\n#> [1] 3\n# these are functions\nf <- function(x) 3\nis.function(mean)\n#> [1] TRUE\nis.function(f)\n#> [1] TRUE\n\n# these aren't\nis.function(\"x\")\n#> [1] FALSE\nis.function(new.env())\n#> [1] FALSE\n# primitive\nis.primitive(sum)\n#> [1] TRUE\nis.primitive(`+`)\n#> [1] TRUE\n\n# not primitive\nis.primitive(mean)\n#> [1] FALSE\nis.primitive(read.csv)\n#> [1] FALSE\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\nlibrary(tidyverse)\n\ndf_formals <- purrr::map_df(funs, ~ length(formals(.))) %>%\n  tidyr::pivot_longer(\n    cols = dplyr::everything(),\n    names_to = \"function\",\n    values_to = \"argumentCount\"\n  ) %>%\n  dplyr::arrange(desc(argumentCount))\ndplyr::filter(df_formals, argumentCount == 0)\n#> # A tibble: 253 x 2\n#>    `function` argumentCount\n#>    <chr>              <int>\n#>  1 -                      0\n#>  2 !                      0\n#>  3 !=                     0\n#>  4 $                      0\n#>  5 $<-                    0\n#>  6 %%                     0\n#>  7 %*%                    0\n#>  8 %/%                    0\n#>  9 &                      0\n#> 10 &&                     0\n#> # ... with 243 more rows\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\nprimitives <- Filter(is.primitive, funs)\n\nnames(primitives)\n#>   [1] \"-\"                    \"!\"                   \n#>   [3] \"!=\"                   \"$\"                   \n#>   [5] \"$<-\"                  \"%%\"                  \n#>   [7] \"%*%\"                  \"%/%\"                 \n#>   [9] \"&\"                    \"&&\"                  \n#>  [11] \"(\"                    \"*\"                   \n#>  [13] \"...elt\"               \"...length\"           \n#>  [15] \"...names\"             \".C\"                  \n#>  [17] \".cache_class\"         \".Call\"               \n#>  [19] \".Call.graphics\"       \".class2\"             \n#>  [21] \".External\"            \".External.graphics\"  \n#>  [23] \".External2\"           \".Fortran\"            \n#>  [25] \".Internal\"            \".isMethodsDispatchOn\"\n#>  [27] \".Primitive\"           \".primTrace\"          \n#>  [29] \".primUntrace\"         \".subset\"             \n#>  [31] \".subset2\"             \"/\"                   \n#>  [33] \":\"                    \"::\"                  \n#>  [35] \":::\"                  \"@\"                   \n#>  [37] \"@<-\"                  \"[\"                   \n#>  [39] \"[[\"                   \"[[<-\"                \n#>  [41] \"[<-\"                  \"^\"                   \n#>  [43] \"{\"                    \"|\"                   \n#>  [45] \"||\"                   \"~\"                   \n#>  [47] \"+\"                    \"<\"                   \n#>  [49] \"<-\"                   \"<<-\"                 \n#>  [51] \"<=\"                   \"=\"                   \n#>  [53] \"==\"                   \">\"                   \n#>  [55] \">=\"                   \"abs\"                 \n#>  [57] \"acos\"                 \"acosh\"               \n#>  [59] \"all\"                  \"any\"                 \n#>  [61] \"anyNA\"                \"Arg\"                 \n#>  [63] \"as.call\"              \"as.character\"        \n#>  [65] \"as.complex\"           \"as.double\"           \n#>  [67] \"as.environment\"       \"as.integer\"          \n#>  [69] \"as.logical\"           \"as.numeric\"          \n#>  [71] \"as.raw\"               \"asin\"                \n#>  [73] \"asinh\"                \"atan\"                \n#>  [75] \"atanh\"                \"attr\"                \n#>  [77] \"attr<-\"               \"attributes\"          \n#>  [79] \"attributes<-\"         \"baseenv\"             \n#>  [81] \"break\"                \"browser\"             \n#>  [83] \"c\"                    \"call\"                \n#>  [85] \"ceiling\"              \"class\"               \n#>  [87] \"class<-\"              \"Conj\"                \n#>  [89] \"cos\"                  \"cosh\"                \n#>  [91] \"cospi\"                \"cummax\"              \n#>  [93] \"cummin\"               \"cumprod\"             \n#>  [95] \"cumsum\"               \"digamma\"             \n#>  [97] \"dim\"                  \"dim<-\"               \n#>  [99] \"dimnames\"             \"dimnames<-\"          \n#> [101] \"emptyenv\"             \"enc2native\"          \n#> [103] \"enc2utf8\"             \"environment<-\"       \n#> [105] \"exp\"                  \"expm1\"               \n#> [107] \"expression\"           \"floor\"               \n#> [109] \"for\"                  \"forceAndCall\"        \n#> [111] \"function\"             \"gamma\"               \n#> [113] \"gc.time\"              \"globalenv\"           \n#> [115] \"if\"                   \"Im\"                  \n#> [117] \"interactive\"          \"invisible\"           \n#> [119] \"is.array\"             \"is.atomic\"           \n#> [121] \"is.call\"              \"is.character\"        \n#> [123] \"is.complex\"           \"is.double\"           \n#> [125] \"is.environment\"       \"is.expression\"       \n#> [127] \"is.finite\"            \"is.function\"         \n#> [129] \"is.infinite\"          \"is.integer\"          \n#> [131] \"is.language\"          \"is.list\"             \n#> [133] \"is.logical\"           \"is.matrix\"           \n#> [135] \"is.na\"                \"is.name\"             \n#> [137] \"is.nan\"               \"is.null\"             \n#> [139] \"is.numeric\"           \"is.object\"           \n#> [141] \"is.pairlist\"          \"is.raw\"              \n#> [143] \"is.recursive\"         \"is.single\"           \n#> [145] \"is.symbol\"            \"isS4\"                \n#> [147] \"lazyLoadDBfetch\"      \"length\"              \n#> [149] \"length<-\"             \"levels<-\"            \n#> [151] \"lgamma\"               \"list\"                \n#> [153] \"log\"                  \"log10\"               \n#> [155] \"log1p\"                \"log2\"                \n#> [157] \"max\"                  \"min\"                 \n#> [159] \"missing\"              \"Mod\"                 \n#> [161] \"names\"                \"names<-\"             \n#> [163] \"nargs\"                \"next\"                \n#> [165] \"nzchar\"               \"oldClass\"            \n#> [167] \"oldClass<-\"           \"on.exit\"             \n#> [169] \"pos.to.env\"           \"proc.time\"           \n#> [171] \"prod\"                 \"quote\"               \n#> [173] \"range\"                \"Re\"                  \n#> [175] \"rep\"                  \"repeat\"              \n#> [177] \"retracemem\"           \"return\"              \n#> [179] \"round\"                \"seq.int\"             \n#> [181] \"seq_along\"            \"seq_len\"             \n#> [183] \"sign\"                 \"signif\"              \n#> [185] \"sin\"                  \"sinh\"                \n#> [187] \"sinpi\"                \"sqrt\"                \n#> [189] \"standardGeneric\"      \"storage.mode<-\"      \n#> [191] \"substitute\"           \"sum\"                 \n#> [193] \"switch\"               \"tan\"                 \n#> [195] \"tanh\"                 \"tanpi\"               \n#> [197] \"tracemem\"             \"trigamma\"            \n#> [199] \"trunc\"                \"unclass\"             \n#> [201] \"untracemem\"           \"UseMethod\"           \n#> [203] \"while\"                \"xtfrm\"\n# base\nmean\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x0000000017d95328>\n#> <environment: namespace:base>\n\n# other package function\npurrr::map\n#> function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> }\n#> <bytecode: 0x000000001c66c310>\n#> <environment: namespace:purrr>\nsum\n#> function (..., na.rm = FALSE)  .Primitive(\"sum\")\nf <- function(x) mean(x)\nf\n#> function(x) mean(x)"},{"path":"functions.html","id":"exercise-6.4.5","chapter":"6 Functions","heading":"6.2 Exercise 6.4.5","text":"Q1. cIn c(c = c):\n* first c interpreted function c()\n* second c name vector element\n* third c variable value 10Q2. Four principles govern R looks valuesName masking (names defined inside function mask names defined outside function)Name masking (names defined inside function mask names defined outside function)Functions vs.¬†variables (rule also applies function names)Functions vs.¬†variables (rule also applies function names)fresh start (every time function called new environment created host execution)fresh start (every time function called new environment created host execution)Dynamic look-(R looks values function run, function created)Dynamic look-(R looks values function run, function created)Q3. Predict returnCorrectly predicted üòâüòâ","code":"\nc <- 10\nc(c = c)\n#>  c \n#> 10\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\n\nf(10)\n#> [1] 202"},{"path":"functions.html","id":"exercise-6.5.4","chapter":"6 Functions","heading":"6.3 Exercise 6.5.4","text":"Q1. Property &&&& evaluates left right short-circuit evaluation, .e., first operand TRUE, R short-circuit even look second operand.Replacing && & undesirable performs element-wise logical comparisons returns vector values always useful decision (TRUE, FALSE, NA).Q2. Principle behind returnThe function returns 100, principle work lazy evaluation. function environment encounters x, evaluates argument x = z since name z already bound value 100, x also bound value.can check looking memory addresses:Q3. Principle behind returnTODO:","code":"\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\n\nx_ok(1)\n#> [1] TRUE\n\nx_ok(1:3)\n#> [1] FALSE\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\n\nx_ok(1)\n#> [1] TRUE\n\nx_ok(1:3)\n#> [1] FALSE FALSE FALSE\nf2 <- function(x = z) {\n  z <- 100\n  print(x)\n\n  print(lobstr::obj_addrs(list(x, z)))\n}\n\nf2()\n#> [1] 100\n#> [1] \"0x32fd5dc8\" \"0x32fd5dc8\"\ny <- 10\nf1 <- function(x =\n                 {\n                   y <- 1\n                   2\n                 },\n               y = 0)\n{\n  c(x, y)\n}\n\nf1()\n#> [1] 2 1\n\ny\n#> [1] 10"},{"path":"functions.html","id":"exercise-6.6.1","chapter":"6 Functions","heading":"6.4 Exercise 6.6.1","text":"Q1. Explain resultsLet‚Äôs look arguments functions:can seen, sum() function doesn‚Äôt na.omit argument. , input na.omit = TRUE treated 1 (logical implicitly coerced numeric), thus results. , expression evaluates sum(1, 2, 3, 1).mean() function, one parameter (x) ‚Äôs matched first argument (1). , expression evaluates mean(1).Q2. Finding documentation plot argumentsFirst, check documentation plot():Since ... passed par(), can look documentation:docs parameters interest reside .Q3. Reading source code plot.defaultSource code can found .plot.default() passes ... localTitle(), passes title().title() four parts: main, sub, xlab, ylab.single argument col work ambiguous element apply argument .","code":"\nsum(1, 2, 3)\n#> [1] 6\n\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\n\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1\nstr(sum)\n#> function (..., na.rm = FALSE)\nstr(mean)\n#> function (x, ...)\nstr(plot)\n#> function (x, y, ...)\nstr(par)\n#> function (..., no.readonly = FALSE)\nlocalTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)\n\ntitle <- function(main = NULL, sub = NULL, xlab = NULL, ylab = NULL,\n                  line = NA, outer = FALSE, ...) {\n  main <- as.graphicsAnnot(main)\n  sub <- as.graphicsAnnot(sub)\n  xlab <- as.graphicsAnnot(xlab)\n  ylab <- as.graphicsAnnot(ylab)\n  .External.graphics(C_title, main, sub, xlab, ylab, line, outer, ...)\n  invisible()\n}"},{"path":"functionals.html","id":"functionals","chapter":"7 Functionals","heading":"7 Functionals","text":"","code":""},{"path":"functionals.html","id":"exercise-9.2.6","chapter":"7 Functionals","heading":"7.1 Exercise 9.2.6","text":"Q1. Study as_mapper()can extract attributes using purrr::attr_getter():Q2. Properly specifying anonymous functionsAs shown as_mapper() outputs , second call appropriate generating random numbers translates pluck() function indices plucking taken randomly generated numbers.Q3. Use appropriate map() functionCompute standard deviation every column numeric data frame.Compute standard deviation every numeric column mixed data frame.Compute number levels every factor data frame.Q4. Statistics visualization purrrExtract p-value test, visualise.Q5. Fixing non-functioning codeQ6. Use map() fit linear models mtcars datasetQ7. Computing R-squared","code":"\nlibrary(purrr)\n\n# mapping by position -----------------------\n\nx <- list(1, list(2, 3, list(1, 2)))\n\nmap(x, 1)\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\nas_mapper(1)\n#> function (x, ...) \n#> pluck(x, 1, .default = NULL)\n#> <environment: 0x000000001c5e9680>\n\nmap(x, list(2, 1))\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> [1] 3\nas_mapper(list(2, 1))\n#> function (x, ...) \n#> pluck(x, 2, 1, .default = NULL)\n#> <environment: 0x000000001c835278>\n\n# mapping by name -----------------------\n\ny <- list(\n  list(m = \"a\", list(1, m = \"mo\")),\n  list(n = \"b\", list(2, n = \"no\"))\n)\n\nmap(y, \"m\")\n#> [[1]]\n#> [1] \"a\"\n#> \n#> [[2]]\n#> NULL\nas_mapper(\"m\")\n#> function (x, ...) \n#> pluck(x, \"m\", .default = NULL)\n#> <environment: 0x000000001ca7a9b8>\n\n# mixing position and name\nmap(y, list(2, \"m\"))\n#> [[1]]\n#> [1] \"mo\"\n#> \n#> [[2]]\n#> NULL\nas_mapper(list(2, \"m\"))\n#> function (x, ...) \n#> pluck(x, 2, \"m\", .default = NULL)\n#> <environment: 0x000000001cc223b0>\n\n# compact functions ----------------------------\n\nmap(y, ~ length(.x))\n#> [[1]]\n#> [1] 2\n#> \n#> [[2]]\n#> [1] 2\nas_mapper(~ length(.x))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> length(.x)\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\npluck(Titanic, attr_getter(\"class\"))\n#> [1] \"table\"\nlibrary(purrr)\n\nmap(1:3, ~ runif(2))\n#> [[1]]\n#> [1] 0.5889851 0.2633994\n#> \n#> [[2]]\n#> [1] 0.4663557 0.5375121\n#> \n#> [[3]]\n#> [1] 0.0123880 0.2234035\nas_mapper(~ runif(2))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> runif(2)\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\n\nmap(1:3, runif(2))\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> NULL\n#> \n#> [[3]]\n#> NULL\nas_mapper(runif(2))\n#> function (x, ...) \n#> pluck(x, 0.463742666877806, 0.340928186429664, .default = NULL)\n#> <environment: 0x0000000015200b80>\nmap_dbl(mtcars, sd)\n#>         mpg         cyl        disp          hp        drat \n#>   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787 \n#>          wt        qsec          vs          am        gear \n#>   0.9784574   1.7869432   0.5040161   0.4989909   0.7378041 \n#>        carb \n#>   1.6152000\nkeep(iris, is.numeric) %>%\n  map_dbl(sd)\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#>    0.8280661    0.4358663    1.7652982    0.7622377\nmodify_if(dplyr::starwars, is.character, as.factor) %>%\n  keep(is.factor) %>%\n  map_int(~ length(levels(.)))\n#>       name hair_color skin_color  eye_color        sex \n#>         87         12         31         15          4 \n#>     gender  homeworld    species \n#>          2         48         37\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\n\np <- map_dbl(trials, \"p.value\")\n\nplot(p)\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, .f = ~ map(., ~ triple(.)))\n#> [[1]]\n#> [[1]][[1]]\n#> [1] 3\n#> \n#> [[1]][[2]]\n#> [1]  9 27\n#> \n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1]  9 18\n#> \n#> [[2]][[2]]\n#> [1] 21\n#> \n#> [[2]][[3]]\n#> [1] 12 21 18\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\n\nmap(formulas, ~ lm(formula = ., data = mtcars))\n#> [[1]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)         disp  \n#>    29.59985     -0.04122  \n#> \n#> \n#> [[2]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)    I(1/disp)  \n#>       10.75      1557.67  \n#> \n#> \n#> [[3]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)         disp           wt  \n#>    34.96055     -0.01772     -3.35083  \n#> \n#> \n#> [[4]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)    I(1/disp)           wt  \n#>      19.024     1142.560       -1.798\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))\n\nmap_dbl(\n  bootstraps,\n  ~ summary(lm(formula = mpg ~ disp, data = .))$r.squared\n)\n#>  [1] 0.6942450 0.8271582 0.7628381 0.7398933 0.7518817\n#>  [6] 0.5796623 0.7159374 0.6419460 0.6164419 0.6778441"},{"path":"functionals.html","id":"exercise-9.4.6","chapter":"7 Functionals","heading":"7.2 Exercise 9.4.6","text":"Q1. Explain resultsmodify() returns object type input. Since input dataframe certain dimensions .f = 1 translates plucking first element column, returns dataframes dimensions plucked element recycled across rows.Q2. Use iwalk() instead walk2()Q3. Explain codemap2() supplies functions defined .x = trans f anonymous functions, names columns defined .y = mtcars[nm] picked var anonymous function. Note function iterating indices vectors transformations column names.map approach, function iterating indices vectors column names.Q4. Difference map2() walk2()use map2(), work, print NULL terminal every element list.","code":"\nhead(modify(mtcars, 1))\n#>                   mpg cyl disp  hp drat   wt  qsec vs am\n#> Mazda RX4          21   6  160 110  3.9 2.62 16.46  0  1\n#> Mazda RX4 Wag      21   6  160 110  3.9 2.62 16.46  0  1\n#> Datsun 710         21   6  160 110  3.9 2.62 16.46  0  1\n#> Hornet 4 Drive     21   6  160 110  3.9 2.62 16.46  0  1\n#> Hornet Sportabout  21   6  160 110  3.9 2.62 16.46  0  1\n#> Valiant            21   6  160 110  3.9 2.62 16.46  0  1\n#>                   gear carb\n#> Mazda RX4            4    4\n#> Mazda RX4 Wag        4    4\n#> Datsun 710           4    4\n#> Hornet 4 Drive       4    4\n#> Hornet Sportabout    4    4\n#> Valiant              4    4\n# with walk2() -----------------------\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(.x = cyls, .y = paths, .f = write.csv)\n\n# with iwalk --------------------------\n\ncyls <- split(mtcars, mtcars$cyl)\nnames(cyls) <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\niwalk(cyls, ~ write.csv(.x, .y))\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))\nbods <- split(BOD, BOD$Time)\nnm <- names(bods)\nmap2(bods, nm, write.csv)"},{"path":"functionals.html","id":"exercise-9.6.3","chapter":"7 Functionals","heading":"7.3 Exercise 9.6.3","text":"Q1. Predicate functionsA predicate function returns single TRUE FALSE..na() function return single value, instead returns vector thus isn‚Äôt predicate function.closest equivalent predicate function base-R anyNA() function.Q2. Fix simple_reduceSupplied function:Struggles inputs length 0 1 function tries access --bound values.problem can solved adding init argument, supplies default initial value function operate :Let‚Äôs try :different kind function:another one:","code":"\n# contrast the following behavior of predicate functions\nis.character(c(\"x\", 2))\n#> [1] TRUE\nis.null(c(3, NULL))\n#> [1] FALSE\n\n# with this behavior\nis.na(c(NA, 1))\n#> [1]  TRUE FALSE\nanyNA(c(NA, 1))\n#> [1] TRUE\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nsimple_reduce(numeric(), sum)\n#> Error in x[[1]]: subscript out of bounds\nsimple_reduce(1, sum)\n#> Error in x[[i]]: subscript out of bounds\nsimple_reduce(1:3, sum)\n#> [1] 6\nsimple_reduce2 <- function(x, f, init = 0) {\n  # initializer will become the first value\n  if (length(x) == 0L) {\n    return(init)\n  }\n  if (length(x) == 1L) {\n    return(x[[1L]])\n  }\n\n  out <- x[[1]]\n\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nsimple_reduce2(numeric(), sum)\n#> [1] 0\nsimple_reduce2(1, sum)\n#> [1] 1\nsimple_reduce2(1:3, sum)\n#> [1] 6\nsimple_reduce2(numeric(), `*`, init = 1)\n#> [1] 1\nsimple_reduce2(1, `*`, init = 1)\n#> [1] 1\nsimple_reduce2(1:3, `*`, init = 1)\n#> [1] 6\nsimple_reduce2(numeric(), `%/%`)\n#> [1] 0\nsimple_reduce2(1, `%/%`)\n#> [1] 1\nsimple_reduce2(1:3, `%/%`)\n#> [1] 0"},{"path":"functionals.html","id":"exercise-9.7.3","chapter":"7 Functionals","heading":"7.4 Exercise 9.7.3","text":"Q1.Q2. eapply() rapply()eapply() applies FUN named values environment returns results list.rapply() recursive version lapply flexibility result structured (= ‚Äú..‚Äù).","code":""},{"path":"base-types.html","id":"base-types","chapter":"8 Base Types","heading":"8 Base Types","text":"exercises.","code":""},{"path":"s3.html","id":"s3","chapter":"9 S3","heading":"9 S3","text":"","code":""},{"path":"s3.html","id":"exercise-13.2.1","chapter":"9 S3","heading":"9.1 Exercise 13.2.1","text":"Q1. Differences t.test t.data.framet.test() generic function perform t-test.t.test() generic function perform t-test.t.data.frame method generic t() (matrix transform function) dispatched data.frame objects need transformed.t.data.frame method generic t() (matrix transform function) dispatched data.frame objects need transformed.Q2. base-R function ..equal().* functions like .data.frame()install.packages()\netc.example,Q3. .data.frame.data.frame() ?‚Äôs method generic .data.frame().Less confusing: asDataFrame.DataFrame().Q4. Difference behaviorBefore unclassing, S3 dispatches .Date method, .numeric method.BeforeAfterQ5. Object propertiesQ6. Object properties","code":"\nlibrary(sloop)\n\n# function type\nftype(t.test)\n#> [1] \"S3\"      \"generic\"\nftype(t.data.frame)\n#> [1] \"S3\"     \"method\"\nftype(as.data.frame)\n#> [1] \"S3\"      \"generic\"\nsome_days <- as.Date(\"2017-01-31\") + sample(10, 5)\n\nsome_days\n#> [1] \"2017-02-07\" \"2017-02-03\" \"2017-02-10\" \"2017-02-09\"\n#> [5] \"2017-02-01\"\n\ns3_dispatch(mean(some_days))\n#> => mean.Date\n#>  * mean.default\n\nmean(some_days)\n#> [1] \"2017-02-06\"\nunclass(some_days)\n#> [1] 17204 17200 17207 17206 17198\n\nmean(unclass(some_days))\n#> [1] 17203\n\ns3_dispatch(mean(unclass(some_days)))\n#>    mean.double\n#>    mean.numeric\n#> => mean.default\nx <- ecdf(rpois(100, 10))\nx\n#> Empirical CDF \n#> Call: ecdf(rpois(100, 10))\n#>  x[1:16] =      2,      4,      5,  ...,     17,     18\n\notype(x)\n#> [1] \"S3\"\n\nattributes(x)\n#> $class\n#> [1] \"ecdf\"     \"stepfun\"  \"function\"\n#> \n#> $call\n#> ecdf(rpois(100, 10))\n\ns3_class(x)\n#> [1] \"ecdf\"     \"stepfun\"  \"function\"\nx <- table(rpois(100, 5))\nx\n#> \n#>  1  2  3  4  5  6  7  8  9 10 \n#>  4  6  9 12 21 20 13  7  6  2\n\notype(x)\n#> [1] \"S3\"\n\nattributes(x)\n#> $dim\n#> [1] 10\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n#> \n#> \n#> $class\n#> [1] \"table\"\n\ns3_class(x)\n#> [1] \"table\""},{"path":"r6.html","id":"r6","chapter":"10 R6","heading":"10 R6","text":"","code":""},{"path":"r6.html","id":"exercise-14.2.6","chapter":"10 R6","heading":"10.1 Exercise 14.2.6","text":"Q1. R6 class bank accountCreate superclass make sure works expected.Create subclass errors attempt overdrawCreate subclass charges fee overdrawQ2. R6 class carddeck","code":"\nlibrary(R6)\n\n# define the needed class\nbankAccount <- R6::R6Class(\n  \"bankAccount\",\n  public = list(\n    # fields -----------------------\n    balance = NA,\n    name = NA,\n\n    # methods ----------------------\n    initialize = function(name = NULL, balance) {\n      self$validate(balance)\n\n      self$name <- name\n      self$balance <- balance\n    },\n    deposit = function(amount) {\n      self$validate(amount)\n      cat(\"Current balance is: \", self$balance, \"\\n\", sep = \"\")\n      cat(\"And you are depositing: \", amount)\n      self$balance <- self$balance + amount\n      invisible(self)\n    },\n    withdraw = function(amount) {\n      self$validate(amount)\n      cat(\"Current balance is: \", self$balance, \"\\n\", sep = \"\")\n      cat(\"And you are withdrawing: \", amount, \"\\n\", sep = \"\")\n      self$balance <- self$balance - amount\n      invisible(self)\n    },\n    validate = function(amount) {\n      stopifnot(is.numeric(amount), amount >= 0)\n    },\n    print = function() {\n      cat(\"Dear \", self$name, \", your balance is: \", self$balance, sep = \"\")\n      invisible(self)\n    }\n  )\n)\n\n# create an instance of an object\nindra <- bankAccount$new(name = \"Indra\", balance = 100)\n\nindra\n#> Dear Indra, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nindra$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nindra\n#> Dear Indra, your balance is: 120\n\nindra$withdraw(10)\n#> Current balance is: 120\n#> And you are withdrawing: 10\n\nindra\n#> Dear Indra, your balance is: 110\n\n# make sure input validation checks work\nindra$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nindra$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nindra$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nAnne <- bankAccount$new(name = \"Anne\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE\nbankAccountStrict <- R6::R6Class(\n  \"bankAccountStrict\",\n  inherit = bankAccount,\n  public = list(\n    withdraw = function(amount) {\n      # use method from superclass\n      super$withdraw(amount)\n\n      if (self$balance < 0) {\n        invisible(self)\n        stop(\n          cat(\"\\nYou are trying to withdraw more that your balance.\\n\"),\n          cat(\"I'm sorry, \", self$name, \", I'm afraid I can't do that.\", sep = \"\"),\n          call. = FALSE\n        )\n      }\n    }\n  )\n)\n\n# create an instance of an object\nPritesh <- bankAccountStrict$new(name = \"Pritesh\", balance = 100)\n\nPritesh\n#> Dear Pritesh, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nPritesh$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nPritesh\n#> Dear Pritesh, your balance is: 120\n\nPritesh$withdraw(150)\n#> Current balance is: 120\n#> And you are withdrawing: 150\n#> \n#> You are trying to withdraw more that your balance.\n#> I'm sorry, Pritesh, I'm afraid I can't do that.\n#> Error:\n\nPritesh\n#> Dear Pritesh, your balance is: -30\n\n# make sure input validation checks work\nPritesh$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nPritesh$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nPritesh$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nPritesh <- bankAccountStrict$new(name = \"Pritesh\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE\nbankAccountFee <- R6::R6Class(\n  \"bankAccountFee\",\n  inherit = bankAccount,\n  public = list(\n    withdraw = function(amount) {\n      # use method from superclass\n      super$withdraw(amount)\n\n      if (self$balance < 0) {\n        cat(\"\\nI am charging you 10 euros for overdrawing.\\n\")\n        self$balance <- self$balance - 10\n        invisible(self)\n      }\n    }\n  )\n)\n\n# create an instance of an object\nMangesh <- bankAccountFee$new(name = \"Mangesh\", balance = 100)\n\nMangesh\n#> Dear Mangesh, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nMangesh$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nMangesh\n#> Dear Mangesh, your balance is: 120\n\nMangesh$withdraw(150)\n#> Current balance is: 120\n#> And you are withdrawing: 150\n#> \n#> I am charging you 10 euros for overdrawing.\n\nMangesh\n#> Dear Mangesh, your balance is: -40\n\n# make sure input validation checks work\nMangesh$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nMangesh$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nMangesh$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nMangesh <- bankAccountFee$new(name = \"Mangesh\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE\nsuit <- c(\"SPADE\", \"HEARTS\", \"DIAMOND\", \"CLUB\") # sigh, Windows encoding issues\nvalue <- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste(rep(value, 4), suit)\n\ndeck <- R6::R6Class(\n  \"deck\",\n  public = list(\n    # fields -----------------------\n\n    # methods -----------------------\n    draw = function(n) {\n      sample(self$cards, n)\n    },\n    reshuffle = function() {\n      sample(self$cards)\n      invisible(self)\n    },\n    print = function() {\n      \"Drawn cards are:\"\n      \"Number of remaining cards:\"\n    }\n  )\n)\n\n# create a new instance of this object\nmydeck <- deck$new()\n\n# draw cards\nmydeck$draw(4)\n\n# reshuffle"},{"path":"r6.html","id":"exercise-14.3.3","chapter":"10 R6","heading":"10.2 Exercise 14.3.3","text":"Q2. Class store check passwordBut, course, everything possible:Q4. Inheriting private fields methods superclassUnlike classical OOP languages (e.g.¬†C++), R6 subclasses also access private methods superclass (base class).instance, following example, Duck class private method $quack(), subclass Mallard can access using super$quack().","code":"\nlibrary(R6)\n\ncheckCredentials <- R6Class(\n  \"checkCredentials\",\n  public = list(\n    # setter\n    set_password = function(password) {\n      private$.password <- password\n    },\n\n    # checker\n    check_password = function(password) {\n      if (is.null(private$.password)) {\n        stop(\"No password set to check against.\")\n      }\n\n      identical(password, private$.password)\n    },\n\n    # the default print method prints the private fields as well\n    print = function() {\n      \"Password: XXXX\"\n      \n      # for method chaining\n      invisible(self)\n    }\n  ),\n  private = list(\n    .password = NULL\n  )\n)\n\nmyCheck <- checkCredentials$new()\nmyCheck\n\nmyCheck$set_password(\"1234\")\n\nmyCheck$check_password(\"abcd\")\n#> [1] FALSE\nmyCheck$check_password(\"1234\")\n#> [1] TRUE\nmyCheck$.__enclos_env__$private$.password\n#> [1] \"1234\"\nDuck <- R6Class(\"Duck\",\n  private = list(quack = function() print(\"Quack Quack\"))\n)\n\nMallard <- R6Class(\"Mallard\",\n  inherit = Duck,\n  public = list(quack = function() super$quack())\n)\n\nmyMallard <- Mallard$new()\nmyMallard$quack()\n#> [1] \"Quack Quack\""},{"path":"r6.html","id":"exercise-14.4.4","chapter":"10 R6","heading":"10.3 Exercise 14.4.4","text":"Q1. Write R6 class edit fileLet‚Äôs check works expected:","code":"\nlibrary(R6)\n\nfileEditor <- R6Class(\n  \"fileEditor\",\n  public = list(\n    initialize = function(filePath) {\n      private$.connection <- file(filePath, open = \"wt\")\n    },\n    append_line = function(text) {\n      cat(\n        text,\n        file = private$.connection,\n        sep = \"\\n\",\n        append = TRUE\n      )\n    }\n  ),\n  private = list(\n    .connection = NULL,\n    # according to R6 docs, the destructor method should be private\n    finalize = function() {\n      print(\"Closing the file connection!\")\n      close(private$.connection)\n    }\n  )\n)\ngreetMom <- function() {\n  f <- tempfile()\n  myfileEditor <- fileEditor$new(f)\n\n  readLines(f)\n\n  myfileEditor$append_line(\"Hi mom!\")\n  myfileEditor$append_line(\"It's a beautiful day!\")\n\n  readLines(f)\n}\n\ngreetMom()\n#> [1] \"Hi mom!\"               \"It's a beautiful day!\"\n\n# force garbage collection\ngc()\n#> [1] \"Closing the file connection!\"\n#>           used (Mb) gc trigger  (Mb) max used  (Mb)\n#> Ncells 1131178 60.5    2388185 127.6  2082162 111.2\n#> Vcells 1904098 14.6    8388608  64.0  2727737  20.9"},{"path":"big-picture.html","id":"big-picture","chapter":"11 Big Picture","heading":"11 Big Picture","text":"exercises.","code":""},{"path":"debugging.html","id":"debugging","chapter":"12 Debugging","heading":"12 Debugging","text":"exercises.","code":""},{"path":"measuring-performance.html","id":"measuring-performance","chapter":"13 Measuring performance","heading":"13 Measuring performance","text":"","code":""},{"path":"measuring-performance.html","id":"exercise-23.2.4","chapter":"13 Measuring performance","heading":"13.1 Exercise 23.2.4","text":"Q1. Profiling function torture = TRUELet‚Äôs first source functions mentioned exercises.First, try without torture = TRUE: returns meaningful results.Maybe function runs fast?mentioned docs, setting torture = TRUETriggers garbage collection every torture memory allocation call.process somehow never seems finish crashes RStudio session stops!question says documentation rm() may provide clues:still couldn‚Äôt figure . recommend checking official answer.","code":"\nlibrary(profvis)\n\nsource(\"profiling-exercises.R\")\nprofvis(f())\n#> Error in parse_rprof(prof_output, expr_source): No parsing data available. Maybe your function was too fast?\nbench::mark(f(), check = FALSE, iterations = 1000)\n#> # A tibble: 1 x 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 f()           232us    283us     3171.     792KB     48.3\nprofvis(f(), torture = TRUE)\nrm\n#> function (..., list = character(), pos = -1, envir = as.environment(pos), \n#>     inherits = FALSE) \n#> {\n#>     dots <- match.call(expand.dots = FALSE)$...\n#>     if (length(dots) && !all(vapply(dots, function(x) is.symbol(x) || \n#>         is.character(x), NA, USE.NAMES = FALSE))) \n#>         stop(\"... must contain names or character strings\")\n#>     names <- vapply(dots, as.character, \"\")\n#>     if (length(names) == 0L) \n#>         names <- character()\n#>     list <- .Primitive(\"c\")(list, names)\n#>     .Internal(remove(list, envir, inherits))\n#> }\n#> <bytecode: 0x000000001593bad8>\n#> <environment: namespace:base>"},{"path":"measuring-performance.html","id":"exercise-23.3.3","chapter":"13 Measuring performance","heading":"13.2 Exercise 23.3.3","text":"Q1. Differences system.time() bench::mark()Compare results alternatives:comparison reveals two approaches yield quite similar results.Q2. Microbenchmarking ways compute square rootMicrobenchmarking ways compute square root vector mentioned chapter.specialized primitive function sqrt() (written C) fastest way compute square root.","code":"\nlibrary(dplyr)\n\nn <- 1e6\nx <- runif(100)\n\n# bench -------------------\n\nbench_df <- bench::mark(\n  sqrt(x),\n  x^0.5,\n  iterations = n\n)\n\nt_bench_df <- bench_df %>%\n  dplyr::select(expression, time) %>%\n  dplyr::rowwise() %>%\n  dplyr::mutate(mean = mean(unlist(time))) %>%\n  dplyr::ungroup() %>%\n  dplyr::select(-time)\n\n# system.time -------------------\n\n# garbage collection performed immediately before the timing\nt1_systime_gc <- system.time(for (i in 1:n) sqrt(x), gcFirst = TRUE) / n\nt2_systime_gc <- system.time(for (i in 1:n) x^0.5, gcFirst = TRUE) / n\n\n# garbage collection not performed immediately before the timing\nt1_systime_nogc <- system.time(for (i in 1:n) sqrt(x), gcFirst = FALSE) / n\nt2_systime_nogc <- system.time(for (i in 1:n) x^0.5, gcFirst = FALSE) / n\n\nt_systime_df <- tibble(\n  \"expression\" = bench_df$expression,\n  \"systime_with_gc_us\" = c(t1_systime_gc[\"elapsed\"], t2_systime_gc[\"elapsed\"]),\n  \"systime_with_nogc_us\" = c(t1_systime_nogc[\"elapsed\"], t2_systime_nogc[\"elapsed\"])\n) %>%\n  dplyr::mutate(\n    systime_with_gc_us = systime_with_gc_us * 1e6,\n    systime_with_nogc_us = systime_with_nogc_us * 1e6\n  )\nt_bench_df\n#> # A tibble: 2 x 2\n#>   expression     mean\n#>   <bch:expr> <bch:tm>\n#> 1 sqrt(x)      1.16us\n#> 2 x^0.5        4.85us\n\nt_systime_df\n#> # A tibble: 2 x 3\n#>   expression systime_with_gc_us systime_with_nogc_us\n#>   <bch:expr>              <dbl>                <dbl>\n#> 1 sqrt(x)                  1.07                0.690\n#> 2 x^0.5                    3.78                3.58\nx <- runif(1000)\n\nbench::mark(\n  sqrt(x),\n  x^0.5,\n  x^(1 / 2),\n  exp(log(x) / 2),\n  iterations = 1000\n) %>%\n  dplyr::arrange(median)\n#> # A tibble: 4 x 6\n#>   expression         min   median `itr/sec` mem_alloc\n#>   <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 sqrt(x)          5.4us      9us    99191.    7.86KB\n#> 2 x^(1/2)         31.4us     32us    29814.    7.86KB\n#> 3 x^0.5           31.5us   34.8us    25284.    7.86KB\n#> 4 exp(log(x)/2)   83.6us   85.1us    11073.    7.86KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0\n#> 3        0\n#> 4        0"},{"path":"rewriting-r-code-in-c.html","id":"rewriting-r-code-in-c","chapter":"14 Rewriting R code in C++","heading":"14 Rewriting R code in C++","text":"","code":""},{"path":"rewriting-r-code-in-c.html","id":"exercise-25.2.6","chapter":"14 Rewriting R code in C++","heading":"14.1 Exercise 25.2.6","text":"Q1. Figure base function corresponding Rccp codef1() mean():f2() cumsum():f3() ():f4() Position():f5() pmin():Q2. Converting base function RcppThe performance benefits going observed function primitive since already tuned max R performance. , expect performance gain diff() var().()cumprod()diff()TODOrange()var()","code":"\nlibrary(Rcpp)#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble f1(NumericVector x) {\n  int n = x.size();\n  double y = 0;\n\n  for(int i = 0; i < n; ++i) {\n    y += x[i] / n;\n  }\n  return y;\n}\n\n// [[Rcpp::export]]\nNumericVector f2(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  out[0] = x[0];\n  for(int i = 1; i < n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nbool f3(LogicalVector x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    if (x[i]) return true;\n  }\n  return false;\n}\n\n// [[Rcpp::export]]\nint f4(Function pred, List x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    LogicalVector res = pred(x[i]);\n    if (res[0]) return i + 1;\n  }\n  return 0;\n}\n\n// [[Rcpp::export]]\nNumericVector f5(NumericVector x, NumericVector y) {\n  int n = std::max(x.size(), y.size());\n  NumericVector x1 = rep_len(x, n);\n  NumericVector y1 = rep_len(y, n);\n\n  NumericVector out(n);\n\n  for (int i = 0; i < n; ++i) {\n    out[i] = std::min(x1[i], y1[i]);\n  }\n\n  return out;\n}\nx <- c(1, 2, 3, 4, 5, 6)\n\nf1(x)\n#> [1] 3.5\nmean(x)\n#> [1] 3.5\nx <- c(1, 3, 5, 6)\n\nf2(x)\n#> [1]  1  4  9 15\ncumsum(x)\n#> [1]  1  4  9 15\nx1 <- c(TRUE, FALSE, FALSE, TRUE)\nx2 <- c(FALSE, FALSE)\n\nf3(x1)\n#> [1] TRUE\nany(x1)\n#> [1] TRUE\n\nf3(x2)\n#> [1] FALSE\nany(x2)\n#> [1] FALSE\nx <- list(\"a\", TRUE, \"m\", 2)\n\nf4(is.numeric, x)\n#> [1] 4\nPosition(is.numeric, x)\n#> [1] 4\nv1 <- c(1, 3, 4, 5, 6, 7)\nv2 <- c(1, 2, 7, 2, 8, 1)\n\nf5(v1, v2)\n#> [1] 1 2 4 2 6 1\npmin(v1, v2)\n#> [1] 1 2 4 2 6 1\nis.primitive(all)\n#> [1] TRUE\nis.primitive(cumprod)\n#> [1] TRUE\nis.primitive(diff)\n#> [1] FALSE\nis.primitive(range)\n#> [1] TRUE\nis.primitive(var)\n#> [1] FALSE#include <vector>\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nbool allC(std::vector<bool> x)\n{\n    for (auto xElement : x)\n    {\n        if (!xElement) return false;\n    }\n\n    return true;\n}\nv1 <- rep(TRUE, 10)\nv2 <- c(rep(TRUE, 5), rep(FALSE, 5))\n\nall(v1)\n#> [1] TRUE\nallC(v1)\n#> [1] TRUE\n\nall(v2)\n#> [1] FALSE\nallC(v2)\n#> [1] FALSE\n\n# performance benefits?\nbench::mark(\n  all(c(rep(TRUE, 1000), rep(FALSE, 1000))),\n  allC(c(rep(TRUE, 1000), rep(FALSE, 1000))),\n  iterations = 100\n)\n#> # A tibble: 2 x 6\n#>   expression                                      min\n#>   <bch:expr>                                 <bch:tm>\n#> 1 all(c(rep(TRUE, 1000), rep(FALSE, 1000)))    11.4us\n#> 2 allC(c(rep(TRUE, 1000), rep(FALSE, 1000)))   17.8us\n#>     median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1   13.6us    55816.    15.8KB        0\n#> 2   19.5us    46931.    18.3KB        0#include <vector>\n\n// [[Rcpp::export]]\nstd::vector<double> cumulativeProduct(std::vector<double> x)\n{\n    std::vector<double> out = x;\n\n    for (size_t i = 1; i < x.size(); i++)\n    {\n        out[i] = out[i - 1] * x[i];\n    }\n\n    return out;\n}\nv1 <- c(10, 4, 6, 8)\n\ncumprod(v1)\n#> [1]   10   40  240 1920\ncumulativeProduct(v1)\n#> [1]   10   40  240 1920\n\n# performance benefits?\nbench::mark(\n  cumprod(v1),\n  cumulativeProduct(v1),\n  iterations = 100\n)\n#> # A tibble: 2 x 6\n#>   expression                 min   median `itr/sec`\n#>   <bch:expr>            <bch:tm> <bch:tm>     <dbl>\n#> 1 cumprod(v1)              100ns    200ns  1050420.\n#> 2 cumulativeProduct(v1)    2.2us    3.9us   229674.\n#>   mem_alloc `gc/sec`\n#>   <bch:byt>    <dbl>\n#> 1        0B        0\n#> 2    7.02KB        0#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// [[Rcpp::export]]\nstd::vector<double> rangeC(std::vector<double> x)\n{\n    std::vector<double> rangeVec{0.0, 0.0};\n\n    rangeVec.at(0) = *std::min_element(x.begin(), x.end());\n    rangeVec.at(1) = *std::max_element(x.begin(), x.end());\n\n    return rangeVec;\n}\nv1 <- c(10, 4, 6, 8)\n\nrange(v1)\n#> [1]  4 10\nrangeC(v1)\n#> [1]  4 10\n\n# performance benefits?\nbench::mark(\n  range(v1),\n  rangeC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 x 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 range(v1)     2.6us    2.9us   254842.        0B        0\n#> 2 rangeC(v1)    2.4us    4.3us   248385.    7.02KB        0#include <vector>\n#include <cmath>\n#include <numeric>\nusing namespace std;\n\n// [[Rcpp::export]]\ndouble variance(std::vector<double> x)\n{\n    double sumSquared{0};\n\n    double mean = std::accumulate(x.begin(), x.end(), 0.0) / x.size();\n\n    for (auto xElement : x)\n    {\n        sumSquared += pow(xElement - mean, 2.0);\n    }\n\n    return sumSquared / (x.size() - 1);\n}\nv1 <- c(1, 4, 7, 8)\n\nvar(v1)\n#> [1] 10\nvariance(v1)\n#> [1] 10\n\n# performance benefits?\nbench::mark(\n  var(v1),\n  variance(v1),\n  iterations = 100\n)\n#> # A tibble: 2 x 6\n#>   expression        min   median `itr/sec` mem_alloc\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 var(v1)          10us   10.4us    93179.        0B\n#> 2 variance(v1)    2.2us    2.5us   361795.    7.02KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0"},{"path":"rewriting-r-code-in-c.html","id":"exercise-25.4.5","chapter":"14 Rewriting R code in C++","heading":"14.2 Exercise 25.4.5","text":"Q1. Rewrite functions original na.rm argumentQ2. Rewrite functions without original na.rm argument","code":"#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <Rcpp.h>\nusing namespace std;\n\n// [[Rcpp::export]]\nstd::vector<double> rangeC_NA(std::vector<double> x, bool removeNA = true)\n{\n    std::vector<double> rangeVec{0.0, 0.0};\n\n    bool naPresent = std::any_of(\n        x.begin(),\n        x.end(),\n        [](double d)\n        { return isnan(d); });\n\n    if (naPresent)\n    {\n        if (removeNA)\n        {\n            std::remove(x.begin(), x.end(), NAN);\n        }\n        else\n        {\n            rangeVec.at(0) = NA_REAL; // NAN;\n            rangeVec.at(1) = NA_REAL; // NAN;\n\n            return rangeVec;\n        }\n    }\n\n    rangeVec.at(0) = *std::min_element(x.begin(), x.end());\n    rangeVec.at(1) = *std::max_element(x.begin(), x.end());\n\n    return rangeVec;\n}\nv1 <- c(10, 4, NA, 6, 8)\n\nrange(v1, na.rm = FALSE)\n#> [1] NA NA\nrangeC_NA(v1, FALSE)\n#> [1] NA NA\n\nrange(v1, na.rm = TRUE)\n#> [1]  4 10\nrangeC_NA(v1, TRUE)\n#> [1]  4 10"},{"path":"rewriting-r-code-in-c.html","id":"exercise-25.5.7","chapter":"14 Rewriting R code in C++","heading":"14.3 Exercise 25.5.7","text":"Q1. median.default() using partial_sort()","code":"#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// [[Rcpp::export]]\ndouble medianC(std::vector<double> x)\n{\n    int middleIndex = static_cast<int>(x.size() / 2);\n\n    std::partial_sort(x.begin(), x.begin() + middleIndex, x.end());\n\n    // for even number of observations\n    if (x.size() % 2 == 0)\n    {\n        return (x[middleIndex - 1] + x[middleIndex]) / 2;\n    }\n\n    return x[middleIndex];\n}\nv1 <- c(1, 3, 3, 6, 7, 8, 9)\nv2 <- c(1, 2, 3, 4, 5, 6, 8, 9)\n\nmedian.default(v1)\n#> [1] 6\nmedianC(v1)\n#> [1] 6\n\nmedian.default(v2)\n#> [1] 4.5\nmedianC(v2)\n#> [1] 4.5\n\n# performance benefits?\nbench::mark(\n  median.default(v2),\n  medianC(v2),\n  iterations = 100\n)\n#> # A tibble: 2 x 6\n#>   expression              min   median `itr/sec` mem_alloc\n#>   <bch:expr>         <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 median.default(v2)   33.5us   36.8us    22794.        0B\n#> 2 medianC(v2)           2.4us    2.8us   329707.    2.49KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0"}]
