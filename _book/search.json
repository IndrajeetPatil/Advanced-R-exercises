[{"path":"index.html","id":"about","chapter":"About","heading":"About","text":"solutions exercises Hadley Wickham’s Advanced R book:https://adv-r.hadley.nz/official solutions, look book:https://advanced-r-solutions.rbind.io/","code":""},{"path":"names-and-values.html","id":"names-and-values","chapter":"1 Names and values","heading":"1 Names and values","text":"","code":""},{"path":"names-and-values.html","id":"exercises","chapter":"1 Names and values","heading":"1.1 2.2.2 Exercises","text":"","code":""},{"path":"names-and-values.html","id":"q1.-explain-the-relationship","chapter":"1 Names and values","heading":"Q1. Explain the relationship","text":"variable names actively bound value.","code":"\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\nlibrary(lobstr)\n\nobj_addr(a)\n#> [1] \"0x289b5c60\"\nobj_addr(b)\n#> [1] \"0x289b5c60\"\nobj_addr(c)\n#> [1] \"0x289b5c60\"\nobj_addr(d)\n#> [1] \"0x28ab4020\""},{"path":"names-and-values.html","id":"q2.-function-object-address","chapter":"1 Names and values","heading":"Q2. Function object address","text":"Following code verifies indeed calls point underlying function object.","code":"\nobj_addr(mean)\n#> [1] \"0x17e31fe0\"\nobj_addr(base::mean)\n#> [1] \"0x17e31fe0\"\nobj_addr(get(\"mean\"))\n#> [1] \"0x17e31fe0\"\nobj_addr(evalq(mean))\n#> [1] \"0x17e31fe0\"\nobj_addr(match.fun(\"mean\"))\n#> [1] \"0x17e31fe0\""},{"path":"names-and-values.html","id":"q3.-converting-non-syntactic-names","chapter":"1 Names and values","heading":"Q3. Converting non-syntactic names","text":"conversion non-syntactic names syntactic ones can sometimes corrupt data. datasets may require non-syntactic names.suppress behavior, one can set check.names = FALSE.","code":""},{"path":"names-and-values.html","id":"q4.-behavior-of-make.names","chapter":"1 Names and values","heading":"Q4. Behavior of make.names()","text":"just prepends X non-syntactic names invalid characters (like @) translated ..","code":"\nmake.names(c(\"123abc\", \"@me\", \"_yu\", \"  gh\", \"else\"))\n#> [1] \"X123abc\" \"X.me\"    \"X_yu\"    \"X..gh\"   \"else.\""},{"path":"names-and-values.html","id":"q5.-why-is-.123e1-not-a-syntactic-name","chapter":"1 Names and values","heading":"Q5. Why is .123e1 not a syntactic name?","text":"parsed number.","code":"\n.123e1 < 1\n#> [1] FALSE"},{"path":"names-and-values.html","id":"exercises-1","chapter":"1 Names and values","heading":"1.2 2.3.6 Exercises","text":"","code":""},{"path":"names-and-values.html","id":"q1.-usefulness-of-tracemem","chapter":"1 Names and values","heading":"Q1. Usefulness of tracemem()","text":"tracemem() traces copying objects R, since object created assigned name, nothing trace.","code":"\ntracemem(1:10)\n#> [1] \"<00000000297646B8>\""},{"path":"names-and-values.html","id":"q2.-why-two-copies-when-you-run-this-code","chapter":"1 Names and values","heading":"Q2. Why two copies when you run this code?","text":"4 double - integer (4L) - modified place.Try integer:still produces copy, Solutions manual:Please aware running code RStudio result additional copies reference environment pane.","code":"\nx <- c(1L, 2L, 3L)\ntracemem(x)\n#> [1] \"<00000000130378D8>\"\n\nx[[3]] <- 4\n#> tracemem[0x00000000130378d8 -> 0x0000000013055948]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local \n#> tracemem[0x0000000013055948 -> 0x0000000013060e18]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\nx <- c(1L, 2L, 3L)\ntracemem(x)\n#> [1] \"<00000000130AABC0>\"\n\nx[[3]] <- 4L\n#> tracemem[0x00000000130aabc0 -> 0x00000000130db480]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local"},{"path":"names-and-values.html","id":"q3.-study-relationship","chapter":"1 Names and values","heading":"Q3. Study relationship","text":"","code":"\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\n\nref(a)\n#> [1:0x17ca4ba8] <int>\n\nref(b)\n#> o [1:0x243ee488] <list> \n#> +-[2:0x17ca4ba8] <int> \n#> \\-[2:0x17ca4ba8]\n\nref(c)\n#> o [1:0x285ee4e8] <list> \n#> +-o [2:0x243ee488] <list> \n#> | +-[3:0x17ca4ba8] <int> \n#> | \\-[3:0x17ca4ba8] \n#> +-[3:0x17ca4ba8] \n#> \\-[4:0x17b4ed20] <int>"},{"path":"names-and-values.html","id":"q4.-list-inside-another-list","chapter":"1 Names and values","heading":"Q4. List inside another list","text":"Figure :\nhttps://advanced-r-solutions.rbind.io/images/names_values/copy_on_modify_fig2.png","code":"\nx <- list(1:10)\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nobj_addr(x)\n#> [1] \"0x28808ce8\"\n\nx[[2]] <- x\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> [[2]]\n#> [[2]][[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nobj_addr(x)\n#> [1] \"0x17bd2218\"\n\nref(x)\n#> o [1:0x17bd2218] <list> \n#> +-[2:0x28586318] <int> \n#> \\-o [3:0x28808ce8] <list> \n#>   \\-[2:0x28586318]"},{"path":"names-and-values.html","id":"exercises-2","chapter":"1 Names and values","heading":"1.3 2.4.1 Exercises","text":"","code":""},{"path":"names-and-values.html","id":"q1.-object-size-difference-between-base-and-lobstr","chapter":"1 Names and values","heading":"Q1. Object size difference between {base} and {lobstr}","text":"function…detect elements list shared.","code":"\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#> 8005648 bytes\n\nobj_size(y)\n#> 80,896 B"},{"path":"names-and-values.html","id":"q2.-misleading-object-size","chapter":"1 Names and values","heading":"Q2. Misleading object size","text":"functions externally created objects R, always available, doesn’t make much sense measure size.Nevertheless, ’s still interesting addition size list objects.","code":"\nfuns <- list(mean, sd, var)\nobj_size(funs)\n#> 17,608 B\nobj_size(mean)\n#> 1,184 B\nobj_size(sd)\n#> 4,480 B\nobj_size(var)\n#> 12,472 B\n\nobj_size(mean) + obj_size(sd) + obj_size(var)\n#> 18,136 B"},{"path":"names-and-values.html","id":"q3.-predict-object-sizes","chapter":"1 Names and values","heading":"Q3. Predict object sizes","text":"","code":"\na <- runif(1e6)\nobj_size(a)\n#> 8,000,048 B\n\nb <- list(a, a)\nobj_size(b)\n#> 8,000,112 B\nobj_size(a, b)\n#> 8,000,112 B\n\nb[[1]][[1]] <- 10\nobj_size(b)\n#> 16,000,160 B\nobj_size(a, b)\n#> 16,000,160 B\n\nb[[2]][[1]] <- 10\nobj_size(b)\n#> 16,000,160 B\nobj_size(a, b)\n#> 24,000,208 B"},{"path":"names-and-values.html","id":"exercises-3","chapter":"1 Names and values","heading":"1.4 2.5.3 Exercises","text":"","code":""},{"path":"names-and-values.html","id":"q1.-why-not-a-circular-list","chapter":"1 Names and values","heading":"Q1. Why not a circular list?","text":"Copy--modify prevents creation circular list.","code":"\nx <- list()\n\nobj_addr(x)\n#> [1] \"0x29c1d6a0\"\n\ntracemem(x)\n#> [1] \"<0000000029C1D6A0>\"\n\nx[[1]] <- x\n#> tracemem[0x0000000029c1d6a0 -> 0x0000000029d242b8]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\n\nobj_addr(x[[1]])\n#> [1] \"0x29c1d6a0\""},{"path":"names-and-values.html","id":"q2.-why-are-loops-so-slow","chapter":"1 Names and values","heading":"Q2. Why are loops so slow","text":"","code":"\nlibrary(bench)"},{"path":"names-and-values.html","id":"q3.-tracemem-on-an-environment","chapter":"1 Names and values","heading":"Q3. tracemem() on an environment","text":"doesn’t work documentation makes clear :useful trace NULL, environments, promises, weak references, external pointer objects, duplicated","code":"\ne <- rlang::env(a = 1, b = \"3\")\ntracemem(e)\n#> Error in tracemem(e): 'tracemem' is not useful for promise and environment objects"},{"path":"vectors.html","id":"vectors","chapter":"2 Vectors","heading":"2 Vectors","text":"","code":""},{"path":"vectors.html","id":"exercise-3.2.5","chapter":"2 Vectors","heading":"2.1 Exercise 3.2.5","text":"","code":""},{"path":"vectors.html","id":"q1.-create-raw-and-complex-scalars","chapter":"2 Vectors","heading":"Q1. Create raw and complex scalars","text":"raw type holds raw bytes. example,can use also figure encoding issues (scalars):Complex vectors can used represent (surprise!) complex numbers.Example complex scalar:","code":"\nx <- \"A string\"\n\n(y <- charToRaw(x))\n#> [1] 41 20 73 74 72 69 6e 67\n\ntypeof(y)\n#> [1] \"raw\"\ncharToRaw(\"\\\"\")\n#> [1] 22\ncharToRaw(\"”\")\n#> [1] 94\n(x <- complex(length.out = 1, real = 1, imaginary = 8))\n#> [1] 1+8i\n\ntypeof(x)\n#> [1] \"complex\""},{"path":"vectors.html","id":"q2.-vector-coercion-rules","chapter":"2 Vectors","heading":"Q2. Vector coercion rules","text":"Usually, general type take precedence.Let’s try examples.","code":"\nc(1, FALSE)\n#> [1] 1 0\n\nc(\"a\", 1)\n#> [1] \"a\" \"1\"\n\nc(TRUE, 1L)\n#> [1] 1 1\nc(1.0, 1L)\n#> [1] 1 1\n\nc(1.0, \"1.0\")\n#> [1] \"1\"   \"1.0\"\n\nc(TRUE, \"1.0\")\n#> [1] \"TRUE\" \"1.0\""},{"path":"vectors.html","id":"q3.-comparisons-between-different-types","chapter":"2 Vectors","heading":"Q3. Comparisons between different types","text":"coercion vectors reveal comparisons return results .","code":"\n1 == \"1\"\n#> [1] TRUE\n\nc(1, \"1\")\n#> [1] \"1\" \"1\"\n-1 < FALSE\n#> [1] TRUE\n\nc(-1, FALSE)\n#> [1] -1  0\n\"one\" < 2\n#> [1] FALSE\n\nc(\"one\", 2)\n#> [1] \"one\" \"2\"\n\nsort(c(\"one\", 2))\n#> [1] \"2\"   \"one\""},{"path":"vectors.html","id":"q4.-why-na-defaults-to-logical-type","chapter":"2 Vectors","heading":"Q4. Why NA defaults to \"logical\" type","text":"\"logical\" type lowest coercion hierarchy.NA defaulting type (e.g. \"numeric\") mean time missing element vector, rest elements converted type higher hierarchy, problematic types lower hierarchy.","code":"\ntypeof(NA)\n#> [1] \"logical\"\n\nc(FALSE, NA_character_)\n#> [1] \"FALSE\" NA"},{"path":"vectors.html","id":"q5.-misleading-variants-of-is.-functions","chapter":"2 Vectors","heading":"Q5. Misleading variants of is.* functions","text":".atomic():.numeric():.vector():","code":""},{"path":"vectors.html","id":"exercise-3.3.4","chapter":"2 Vectors","heading":"2.2 Exercise 3.3.4","text":"","code":""},{"path":"vectors.html","id":"q1.-reading-source-code","chapter":"2 Vectors","heading":"Q1. Reading source code","text":"","code":"\nsetNames\n#> function (object = nm, nm) \n#> {\n#>     names(object) <- nm\n#>     object\n#> }\n#> <bytecode: 0x00000000178d6968>\n#> <environment: namespace:stats>\n\nsetNames(c(1, 2), c(\"a\", \"b\"))\n#> a b \n#> 1 2\nunname\n#> function (obj, force = FALSE) \n#> {\n#>     if (!is.null(names(obj))) \n#>         names(obj) <- NULL\n#>     if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n#>         dimnames(obj) <- NULL\n#>     obj\n#> }\n#> <bytecode: 0x000000001497e720>\n#> <environment: namespace:base>\n\nA <- provideDimnames(N <- array(1:24, dim = 2:4))\n\nunname(A, force = TRUE)\n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\n#> \n#> , , 3\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   13   15   17\n#> [2,]   14   16   18\n#> \n#> , , 4\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   19   21   23\n#> [2,]   20   22   24"},{"path":"vectors.html","id":"q2.-1-dimensional-vector","chapter":"2 Vectors","heading":"Q2. 1-dimensional vector","text":"Dimensions 1-dimensional vector NULL.NROW() NCOL() helpful getting dimensions 1D vectors treating data frame vectors.","code":"\nx <- character(0)\n\ndim(x)\n#> NULL\n\nnrow(x)\n#> NULL\nNROW(x)\n#> [1] 0\n\nncol(x)\n#> NULL\nNCOL(x)\n#> [1] 1"},{"path":"vectors.html","id":"q3.-difference-between-vectors-and-arrays","chapter":"2 Vectors","heading":"Q3. Difference between vectors and arrays","text":"1:5 1D vector without dimensions, x1, x2, x3 one-dimensional arrays.","code":"\n1:5\n#> [1] 1 2 3 4 5\n(x1 <- array(1:5, c(1, 1, 5)))\n#> , , 1\n#> \n#>      [,1]\n#> [1,]    1\n#> \n#> , , 2\n#> \n#>      [,1]\n#> [1,]    2\n#> \n#> , , 3\n#> \n#>      [,1]\n#> [1,]    3\n#> \n#> , , 4\n#> \n#>      [,1]\n#> [1,]    4\n#> \n#> , , 5\n#> \n#>      [,1]\n#> [1,]    5\n(x2 <- array(1:5, c(1, 5, 1)))\n#> , , 1\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n(x3 <- array(1:5, c(5, 1, 1)))\n#> , , 1\n#> \n#>      [,1]\n#> [1,]    1\n#> [2,]    2\n#> [3,]    3\n#> [4,]    4\n#> [5,]    5"},{"path":"vectors.html","id":"q4.-about-structure","chapter":"2 Vectors","heading":"Q4. About structure()","text":"?attributes (emphasis mine):Note attributes (namely class, comment, dim, dimnames, names, row.names tsp) treated specially restrictions values can set.","code":"\nstructure(1:5, x = \"my attribute\")\n#> [1] 1 2 3 4 5\n#> attr(,\"x\")\n#> [1] \"my attribute\"\n\nstructure(1:5, comment = \"my attribute\")\n#> [1] 1 2 3 4 5"},{"path":"vectors.html","id":"exercise-3.4.5","chapter":"2 Vectors","heading":"2.3 Exercise 3.4.5","text":"","code":""},{"path":"vectors.html","id":"q1.-table-function","chapter":"2 Vectors","heading":"Q1. table() function","text":"table() returns array integer type dimensions scale number variables present.","code":"\n(x <- table(mtcars$am))\n#> \n#>  0  1 \n#> 19 13\n(y <- table(mtcars$am, mtcars$cyl))\n#>    \n#>      4  6  8\n#>   0  3  4 12\n#>   1  8  3  2\n(z <- table(mtcars$am, mtcars$cyl, mtcars$vs))\n#> , ,  = 0\n#> \n#>    \n#>      4  6  8\n#>   0  0  0 12\n#>   1  1  3  2\n#> \n#> , ,  = 1\n#> \n#>    \n#>      4  6  8\n#>   0  3  4  0\n#>   1  7  0  0\n\n# type\npurrr::map(list(x, y, z), typeof)\n#> [[1]]\n#> [1] \"integer\"\n#> \n#> [[2]]\n#> [1] \"integer\"\n#> \n#> [[3]]\n#> [1] \"integer\"\n\n# attributes\npurrr::map(list(x, y, z), attributes)\n#> [[1]]\n#> [[1]]$dim\n#> [1] 2\n#> \n#> [[1]]$dimnames\n#> [[1]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> \n#> [[1]]$class\n#> [1] \"table\"\n#> \n#> \n#> [[2]]\n#> [[2]]$dim\n#> [1] 2 3\n#> \n#> [[2]]$dimnames\n#> [[2]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> [[2]]$dimnames[[2]]\n#> [1] \"4\" \"6\" \"8\"\n#> \n#> \n#> [[2]]$class\n#> [1] \"table\"\n#> \n#> \n#> [[3]]\n#> [[3]]$dim\n#> [1] 2 3 2\n#> \n#> [[3]]$dimnames\n#> [[3]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> [[3]]$dimnames[[2]]\n#> [1] \"4\" \"6\" \"8\"\n#> \n#> [[3]]$dimnames[[3]]\n#> [1] \"0\" \"1\"\n#> \n#> \n#> [[3]]$class\n#> [1] \"table\""},{"path":"vectors.html","id":"q2.-factor-reversal","chapter":"2 Vectors","heading":"Q2. Factor reversal","text":"levels changes underlying integer values remain .","code":"\nf1 <- factor(letters)\nf1\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> 26 Levels: a b c d e f g h i j k l m n o p q r s t u ... z\nas.integer(f1)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n#> [19] 19 20 21 22 23 24 25 26\n\nlevels(f1) <- rev(levels(f1))\nf1\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> 26 Levels: z y x w v u t s r q p o n m l k j i h g f ... a\nas.integer(f1)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n#> [19] 19 20 21 22 23 24 25 26"},{"path":"vectors.html","id":"q3.-factor-reversal-2","chapter":"2 Vectors","heading":"Q3. Factor reversal-2","text":"f2: underlying integers reversed, levels remain unchanged.\nf3: levels underlying integers reversed.","code":"\nf2 <- rev(factor(letters))\nf2\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> 26 Levels: a b c d e f g h i j k l m n o p q r s t u ... z\nas.integer(f2)\n#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9\n#> [19]  8  7  6  5  4  3  2  1\n\nf3 <- factor(letters, levels = rev(letters))\nf3\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> 26 Levels: z y x w v u t s r q p o n m l k j i h g f ... a\nas.integer(f3)\n#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9\n#> [19]  8  7  6  5  4  3  2  1"},{"path":"vectors.html","id":"exercise-3.5.4","chapter":"2 Vectors","heading":"2.4 Exercise 3.5.4","text":"","code":""},{"path":"vectors.html","id":"q1.-differences-between-list-and-atomic-vector","chapter":"2 Vectors","heading":"Q1. Differences between list and atomic vector","text":"","code":""},{"path":"vectors.html","id":"q2.-converting-a-list-to-an-atomic-vector","chapter":"2 Vectors","heading":"Q2. Converting a list to an atomic vector","text":"List already vector, .vector going change anything, .atomic.vector. Thus need use unlist().","code":"\nx <- list(a = 1, b = 2)\n\nis.vector(x)\n#> [1] TRUE\nis.atomic(x)\n#> [1] FALSE\n\nas.vector(x)\n#> $a\n#> [1] 1\n#> \n#> $b\n#> [1] 2\n\nunlist(x)\n#> a b \n#> 1 2"},{"path":"vectors.html","id":"q3.-comparing-c-and-unlist-for-date-and-datetime","chapter":"2 Vectors","heading":"Q3. Comparing c() and unlist() for date and datetime","text":"Behavior c(): Works expected. odd thing strips tzone attribute.Behavior unlist(): Removes attributes left underlying double representations objects.","code":"\n# creating a date and datetime\ndate <- as.Date(\"1947-08-15\")\ndatetime <- as.POSIXct(\"1950-01-26 00:01\", tz = \"UTC\")\n\n# check attributes\nattributes(date)\n#> $class\n#> [1] \"Date\"\nattributes(datetime)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\n\n# check their underlying double representation\nas.double(date) # number of days since the Unix epoch 1970-01-01\n#> [1] -8175\nas.double(datetime) # number of seconds since then\n#> [1] -628991940\nc(date, datetime)\n#> [1] \"1947-08-15\" \"1950-01-26\"\n\nattributes(c(date, datetime))\n#> $class\n#> [1] \"Date\"\n\nc(datetime, date)\n#> [1] \"1950-01-26 01:01:00 CET\"  \"1947-08-15 02:00:00 CEST\"\n\nattributes(c(datetime, date))\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\"\nunlist(list(date, datetime))\n#> [1]      -8175 -628991940\n\nunlist(list(datetime, date))\n#> [1] -628991940      -8175"},{"path":"vectors.html","id":"exercise-3.6.8","chapter":"2 Vectors","heading":"2.5 Exercise 3.6.8","text":"","code":""},{"path":"vectors.html","id":"q1.-data-frame-with-0-dimensions","chapter":"2 Vectors","heading":"Q1. Data frame with 0 dimensions","text":"Data frame 0 rows possible. basically list vector length 0.Data frame 0 columns possible. empty list.one go:","code":"\ndata.frame(x = numeric(0))\n#> [1] x\n#> <0 rows> (or 0-length row.names)\ndata.frame(row.names = 1)\n#> data frame with 0 columns and 1 row\ndata.frame()\n#> data frame with 0 columns and 0 rows\n\ndim(data.frame())\n#> [1] 0 0"},{"path":"vectors.html","id":"q2.-non-unique-rownames","chapter":"2 Vectors","heading":"Q2. Non-unique rownames","text":"attempt set rownames unique, work.","code":"\ndata.frame(row.names = c(1, 1))\n#> Error in data.frame(row.names = c(1, 1)): duplicate row.names: 1"},{"path":"vectors.html","id":"q3.-transposing-dataframes","chapter":"2 Vectors","heading":"Q3. Transposing dataframes","text":"Transposing dataframe transforms matrix coerces elements type.","code":"\n# original\n(df <- head(iris))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n\n# transpose\nt(df)\n#>              1        2        3        4        5       \n#> Sepal.Length \"5.1\"    \"4.9\"    \"4.7\"    \"4.6\"    \"5.0\"   \n#> Sepal.Width  \"3.5\"    \"3.0\"    \"3.2\"    \"3.1\"    \"3.6\"   \n#> Petal.Length \"1.4\"    \"1.4\"    \"1.3\"    \"1.5\"    \"1.4\"   \n#> Petal.Width  \"0.2\"    \"0.2\"    \"0.2\"    \"0.2\"    \"0.2\"   \n#> Species      \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\"\n#>              6       \n#> Sepal.Length \"5.4\"   \n#> Sepal.Width  \"3.9\"   \n#> Petal.Length \"1.7\"   \n#> Petal.Width  \"0.4\"   \n#> Species      \"setosa\"\n\n# transpose of a transpose\nt(t(df))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1 \"5.1\"        \"3.5\"       \"1.4\"        \"0.2\"      \n#> 2 \"4.9\"        \"3.0\"       \"1.4\"        \"0.2\"      \n#> 3 \"4.7\"        \"3.2\"       \"1.3\"        \"0.2\"      \n#> 4 \"4.6\"        \"3.1\"       \"1.5\"        \"0.2\"      \n#> 5 \"5.0\"        \"3.6\"       \"1.4\"        \"0.2\"      \n#> 6 \"5.4\"        \"3.9\"       \"1.7\"        \"0.4\"      \n#>   Species \n#> 1 \"setosa\"\n#> 2 \"setosa\"\n#> 3 \"setosa\"\n#> 4 \"setosa\"\n#> 5 \"setosa\"\n#> 6 \"setosa\"\n\n# is it a dataframe?\nis.data.frame(df)\n#> [1] TRUE\nis.data.frame(t(df))\n#> [1] FALSE\nis.data.frame(t(t(df)))\n#> [1] FALSE\n\n# check type\ntypeof(df)\n#> [1] \"list\"\ntypeof(t(df))\n#> [1] \"character\"\ntypeof(t(t(df)))\n#> [1] \"character\"\n\n# check dimensions\ndim(df)\n#> [1] 6 5\ndim(t(df))\n#> [1] 5 6\ndim(t(t(df)))\n#> [1] 6 5"},{"path":"vectors.html","id":"q4.-as.matrix-and-dataframe","chapter":"2 Vectors","heading":"Q4. as.matrix() and dataframe","text":"return type .matrix() depends dataframe column types.documentation data.matrix():Return matrix obtained converting variables data frame numeric mode binding together columns matrix.data.matrix() always returns numeric matrix:","code":"\n# example with mixed types (coerced to character)\n(df <- head(iris))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n\nas.matrix(df)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1 \"5.1\"        \"3.5\"       \"1.4\"        \"0.2\"      \n#> 2 \"4.9\"        \"3.0\"       \"1.4\"        \"0.2\"      \n#> 3 \"4.7\"        \"3.2\"       \"1.3\"        \"0.2\"      \n#> 4 \"4.6\"        \"3.1\"       \"1.5\"        \"0.2\"      \n#> 5 \"5.0\"        \"3.6\"       \"1.4\"        \"0.2\"      \n#> 6 \"5.4\"        \"3.9\"       \"1.7\"        \"0.4\"      \n#>   Species \n#> 1 \"setosa\"\n#> 2 \"setosa\"\n#> 3 \"setosa\"\n#> 4 \"setosa\"\n#> 5 \"setosa\"\n#> 6 \"setosa\"\n\nstr(as.matrix(df))\n#>  chr [1:6, 1:5] \"5.1\" \"4.9\" \"4.7\" \"4.6\" \"5.0\" \"5.4\" ...\n#>  - attr(*, \"dimnames\")=List of 2\n#>   ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ : chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ...\n\n# another example (no such coercion)\nBOD\n#>   Time demand\n#> 1    1    8.3\n#> 2    2   10.3\n#> 3    3   19.0\n#> 4    4   16.0\n#> 5    5   15.6\n#> 6    7   19.8\n\nas.matrix(BOD)\n#>      Time demand\n#> [1,]    1    8.3\n#> [2,]    2   10.3\n#> [3,]    3   19.0\n#> [4,]    4   16.0\n#> [5,]    5   15.6\n#> [6,]    7   19.8\ndata.matrix(df)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2       1\n#> 2          4.9         3.0          1.4         0.2       1\n#> 3          4.7         3.2          1.3         0.2       1\n#> 4          4.6         3.1          1.5         0.2       1\n#> 5          5.0         3.6          1.4         0.2       1\n#> 6          5.4         3.9          1.7         0.4       1\n\nstr(data.matrix(df))\n#>  num [1:6, 1:5] 5.1 4.9 4.7 4.6 5 5.4 3.5 3 3.2 3.1 ...\n#>  - attr(*, \"dimnames\")=List of 2\n#>   ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ : chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ..."},{"path":"control-flow.html","id":"control-flow","chapter":"3 Control flow","heading":"3 Control flow","text":"","code":""},{"path":"control-flow.html","id":"exercise-5.2.4","chapter":"3 Control flow","heading":"Exercise 5.2.4","text":"","code":""},{"path":"control-flow.html","id":"q1.-ifelse-return-type","chapter":"3 Control flow","heading":"Q1. ifelse() return type","text":"’s type unstable, .e. type return depend type condition (yes , .e.), works cases test argument evaluated logical type.Additionally, test doesn’t resolve logical type, try coerce whatever resulting type logical:","code":"\nifelse(TRUE, 1, \"no\") # numeric returned\n#> [1] 1\nifelse(FALSE, 1, \"no\") # character returned\n#> [1] \"no\"\nifelse(NA, 1, \"no\")\n#> [1] NA\n# will work\nifelse(\"TRUE\", 1, \"no\")\n#> [1] 1\nifelse(\"true\", 1, \"no\")\n#> [1] 1\n\n# won't work\nifelse(\"tRuE\", 1, \"no\")\n#> [1] NA\nifelse(NaN, 1, \"no\")\n#> [1] NA"},{"path":"control-flow.html","id":"q2.-why-does-the-following-code-work","chapter":"3 Control flow","heading":"Q2. Why does the following code work?","text":"can seen, code works tests successfully coerced logical type.","code":"\nx <- 1:10\nas.logical(length(1:10))\n#> [1] TRUE\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"not empty\"\n\nx <- numeric()\nas.logical(length(numeric()))\n#> [1] FALSE\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"empty\""},{"path":"control-flow.html","id":"exercise-5.3.3","chapter":"3 Control flow","heading":"Exercise 5.3.3","text":"","code":""},{"path":"control-flow.html","id":"q1.-why-does-this-work","chapter":"3 Control flow","heading":"Q1. Why does this work?","text":"works 1:length(x) goes ways; case, 1 0. , since --bound values atomic vectors NA, related operations also lead NA.way avoid unintended behavior :","code":"\nx <- numeric()\nout <- vector(\"list\", length(x))\n\nfor (i in 1:length(x)) {\n  print(x[i])\n  print(out[i])\n\n  out[i] <- x[i]^2\n}\n#> [1] NA\n#> [[1]]\n#> NULL\n#> \n#> numeric(0)\n#> list()\n\nout\n#> [[1]]\n#> [1] NA\nx <- numeric()\nout <- vector(\"list\", length(x))\n\nfor (i in 1:seq_along(x)) {\n  out[i] <- x[i]^2\n}\n#> Error in 1:seq_along(x): argument of length 0\n\nout\n#> list()"},{"path":"control-flow.html","id":"q2.-index-vectors","chapter":"3 Control flow","heading":"Q2. Index vectors","text":"Surprisingly (least ), x takes values vector xs:","code":"\n# xs <- c(1, 2, 3)\nxs <- c(4, 5, 6)\nfor (x in xs) {\n  print(x)\n  xs <- c(xs, x * 2)\n}\n#> [1] 4\n#> [1] 5\n#> [1] 6\n\nxs\n#> [1]  4  5  6  8 10 12"},{"path":"control-flow.html","id":"q3.-index-increase","chapter":"3 Control flow","heading":"Q3. Index increase","text":"loop - like loop - index updated beginning iteration.","code":"\nfor (i in 1:3) {\n  cat(\"before: \", i, \"\\n\")\n  i <- i * 2\n  cat(\"after: \", i, \"\\n\")\n}\n#> before:  1 \n#> after:  2 \n#> before:  2 \n#> after:  4 \n#> before:  3 \n#> after:  6\n\ni <- 1\nwhile (i < 3) {\n  cat(\"before: \", i, \"\\n\")\n  i <- i * 2\n  cat(\"after: \", i, \"\\n\")\n}\n#> before:  1 \n#> after:  2 \n#> before:  2 \n#> after:  4"},{"path":"s3.html","id":"s3","chapter":"4 S3","heading":"4 S3","text":"","code":""},{"path":"s3.html","id":"exercise-13.2.1","chapter":"4 S3","heading":"4.1 Exercise 13.2.1","text":"","code":""},{"path":"s3.html","id":"q1.-differences-between-t.test-and-t.data.frame","chapter":"4 S3","heading":"Q1. Differences between t.test and t.data.frame","text":"t.test() generic function perform t-test.t.test() generic function perform t-test.t.data.frame method generic t() (matrix transform function) dispatched data.frame objects need transformed.t.data.frame method generic t() (matrix transform function) dispatched data.frame objects need transformed.","code":"\nlibrary(sloop)\n\n# function type\nftype(t.test)\n#> [1] \"S3\"      \"generic\"\nftype(t.data.frame)\n#> [1] \"S3\"     \"method\""},{"path":"s3.html","id":"q2.-base-r-function-with-.","chapter":"4 S3","heading":"Q2. base-R function with .","text":".equal().* functions like .data.frame()install.packages()\netc.example,","code":"\nftype(as.data.frame)\n#> [1] \"S3\"      \"generic\""},{"path":"s3.html","id":"q3.-what-does-as.data.frame.data.frame-do","chapter":"4 S3","heading":"Q3. What does as.data.frame.data.frame() do?","text":"’s method generic .data.frame().Less confusing: asDataFrame.DataFrame().","code":""},{"path":"s3.html","id":"q4.-difference-in-behavior","chapter":"4 S3","heading":"Q4. Difference in behavior","text":"unclassing, S3 dispatches .Date method, .numeric method.BeforeAfter","code":"\nsome_days <- as.Date(\"2017-01-31\") + sample(10, 5)\n\nsome_days\n#> [1] \"2017-02-09\" \"2017-02-06\" \"2017-02-04\" \"2017-02-02\"\n#> [5] \"2017-02-10\"\n\ns3_dispatch(mean(some_days))\n#> => mean.Date\n#>  * mean.default\n\nmean(some_days)\n#> [1] \"2017-02-06\"\nunclass(some_days)\n#> [1] 17206 17203 17201 17199 17207\n\nmean(unclass(some_days))\n#> [1] 17203.2\n\ns3_dispatch(mean(unclass(some_days)))\n#>    mean.double\n#>    mean.numeric\n#> => mean.default"},{"path":"s3.html","id":"q5.-object-properties","chapter":"4 S3","heading":"Q5. Object properties","text":"","code":"\nx <- ecdf(rpois(100, 10))\nx\n#> Empirical CDF \n#> Call: ecdf(rpois(100, 10))\n#>  x[1:16] =      3,      4,      5,  ...,     17,     18\n\notype(x)\n#> [1] \"S3\"\n\nattributes(x)\n#> $class\n#> [1] \"ecdf\"     \"stepfun\"  \"function\"\n#> \n#> $call\n#> ecdf(rpois(100, 10))\n\ns3_class(x)\n#> [1] \"ecdf\"     \"stepfun\"  \"function\""},{"path":"s3.html","id":"q6.-object-properties","chapter":"4 S3","heading":"Q6. Object properties","text":"","code":"\nx <- table(rpois(100, 5))\nx\n#> \n#>  1  2  3  4  5  6  7  8  9 10 11 \n#>  3  4 13 16 18 14 15  7  6  3  1\n\notype(x)\n#> [1] \"S3\"\n\nattributes(x)\n#> $dim\n#> [1] 11\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\"\n#> \n#> \n#> $class\n#> [1] \"table\"\n\ns3_class(x)\n#> [1] \"table\""},{"path":"r6.html","id":"r6","chapter":"5 R6","heading":"5 R6","text":"","code":""},{"path":"r6.html","id":"exercise-14.2.6","chapter":"5 R6","heading":"5.1 Exercise 14.2.6","text":"","code":""},{"path":"r6.html","id":"q1.-r6-class-for-bank-account","chapter":"5 R6","heading":"Q1. R6 class for bank account","text":"Create superclass make sure works expected.Create subclass errors attempt overdrawCreate subclass charges fee overdraw","code":"\nlibrary(R6)\n\n# define the needed class\nbankAccount <- R6::R6Class(\n  \"bankAccount\",\n  public = list(\n    # fields -----------------------\n    balance = NA,\n    name = NA,\n\n    # methods ----------------------\n    initialize = function(name = NULL, balance) {\n      self$validate(balance)\n\n      self$name <- name\n      self$balance <- balance\n    },\n    deposit = function(amount) {\n      self$validate(amount)\n      cat(\"Current balance is: \", self$balance, \"\\n\", sep = \"\")\n      cat(\"And you are depositing: \", amount)\n      self$balance <- self$balance + amount\n      invisible(self)\n    },\n    withdraw = function(amount) {\n      self$validate(amount)\n      cat(\"Current balance is: \", self$balance, \"\\n\", sep = \"\")\n      cat(\"And you are withdrawing: \", amount, \"\\n\", sep = \"\")\n      self$balance <- self$balance - amount\n      invisible(self)\n    },\n    validate = function(amount) {\n      stopifnot(is.numeric(amount), amount >= 0)\n    },\n    print = function() {\n      cat(\"Dear \", self$name, \", your balance is: \", self$balance, sep = \"\")\n      invisible(self)\n    }\n  )\n)\n\n# create an instance of an object\nindra <- bankAccount$new(name = \"Indra\", balance = 100)\n\nindra\n#> Dear Indra, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nindra$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nindra\n#> Dear Indra, your balance is: 120\n\nindra$withdraw(10)\n#> Current balance is: 120\n#> And you are withdrawing: 10\n\nindra\n#> Dear Indra, your balance is: 110\n\n# make sure input validation checks work\nindra$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nindra$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nindra$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nAnne <- bankAccount$new(name = \"Anne\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE\nbankAccountStrict <- R6::R6Class(\n  \"bankAccountStrict\",\n  inherit = bankAccount,\n  public = list(\n    withdraw = function(amount) {\n      # use method from superclass\n      super$withdraw(amount)\n\n      if (self$balance < 0) {\n        invisible(self)\n        stop(\n          cat(\"\\nYou are trying to withdraw more that your balance.\\n\"),\n          cat(\"I'm sorry, \", self$name, \", I'm afraid I can't do that.\", sep = \"\"),\n          call. = FALSE\n        )\n      }\n    }\n  )\n)\n\n# create an instance of an object\nPritesh <- bankAccountStrict$new(name = \"Pritesh\", balance = 100)\n\nPritesh\n#> Dear Pritesh, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nPritesh$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nPritesh\n#> Dear Pritesh, your balance is: 120\n\nPritesh$withdraw(150)\n#> Current balance is: 120\n#> And you are withdrawing: 150\n#> \n#> You are trying to withdraw more that your balance.\n#> I'm sorry, Pritesh, I'm afraid I can't do that.\n#> Error:\n\nPritesh\n#> Dear Pritesh, your balance is: -30\n\n# make sure input validation checks work\nPritesh$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nPritesh$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nPritesh$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nPritesh <- bankAccountStrict$new(name = \"Pritesh\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE\nbankAccountFee <- R6::R6Class(\n  \"bankAccountFee\",\n  inherit = bankAccount,\n  public = list(\n    withdraw = function(amount) {\n      # use method from superclass\n      super$withdraw(amount)\n\n      if (self$balance < 0) {\n        cat(\"\\nI am charging you 10 euros for overdrawing.\\n\")\n        self$balance <- self$balance - 10\n        invisible(self)\n      }\n    }\n  )\n)\n\n# create an instance of an object\nMangesh <- bankAccountFee$new(name = \"Mangesh\", balance = 100)\n\nMangesh\n#> Dear Mangesh, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nMangesh$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nMangesh\n#> Dear Mangesh, your balance is: 120\n\nMangesh$withdraw(150)\n#> Current balance is: 120\n#> And you are withdrawing: 150\n#> \n#> I am charging you 10 euros for overdrawing.\n\nMangesh\n#> Dear Mangesh, your balance is: -40\n\n# make sure input validation checks work\nMangesh$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nMangesh$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nMangesh$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nMangesh <- bankAccountFee$new(name = \"Mangesh\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE"},{"path":"r6.html","id":"q2.-r6-class-for-carddeck","chapter":"5 R6","heading":"Q2. R6 class for carddeck","text":"","code":"\nsuit <- c(\"SPADE\", \"HEARTS\", \"DIAMOND\", \"CLUB\") # sigh, Windows encoding issues\nvalue <- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste(rep(value, 4), suit)\n\ndeck <- R6::R6Class(\n  \"deck\",\n  public = list(\n    # fields -----------------------\n\n    # methods -----------------------\n    draw = function(n) {\n      sample(self$cards, n)\n    },\n    reshuffle = function() {\n      sample(self$cards)\n      invisible(self)\n    },\n    print = function() {\n      \"Drawn cards are:\"\n      \"Number of remaining cards:\"\n    }\n  )\n)\n\n# create a new instance of this object\nmydeck <- deck$new()\n\n# draw cards\nmydeck$draw(4)\n\n# reshuffle"}]
