[{"path":"index.html","id":"about","chapter":"About","heading":"About","text":"solutions exercises Advanced R (2nd Edition) book.Note reading official solutions manual, detailed explanations guaranteed correct solutions original author also involved writing . provide guarantees. 😬solutionsMy solutionsOfficial solutionsOfficial solutions","code":""},{"path":"introduction.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"exercises.","code":""},{"path":"names-and-values.html","id":"names-and-values","chapter":"2 Names and values","heading":"2 Names and values","text":"","code":""},{"path":"names-and-values.html","id":"exercises","chapter":"2 Names and values","heading":"2.1 2.2.2 Exercises","text":"Q1. Explain relationship , b, c d following code:A1.names (, b, c) references object memory, can seen identical memory address:Except d, different object, even value:Q2. following code accesses mean function multiple ways. point underlying function object? Verify lobstr::obj_addr().A2.Following code verifies indeed calls point underlying function object.Q3. default, base R data import functions, like read.csv(), automatically convert non-syntactic names syntactic ones. might problematic? option allows suppress behaviour?A3.conversion non-syntactic names syntactic ones can sometimes corrupt data. datasets may require non-syntactic names.suppress behavior, one can set check.names = FALSE.Q4. rules make.names() use convert non-syntactic names syntactic ones?A4.just prepends X non-syntactic names invalid characters (like @) converted ..Q5. slightly simplified rules govern syntactic names. .123e1 syntactic name? Read ?make.names full details.A5.parsed number.docs mention (emphasis mine):syntactically valid name consists letters, numbers dot underline characters starts letter dot followed number.make.names() make syntactic:","code":"\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\nlibrary(lobstr)\n\nobj_addrs(list(a, b, c))\n#> [1] \"0x1303c48c0\" \"0x1303c48c0\" \"0x1303c48c0\"\nobj_addr(d)\n#> [1] \"0x1300e5a40\"\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")\nobj_addr(mean)\n#> [1] \"0x1302978d8\"\nobj_addr(base::mean)\n#> [1] \"0x1302978d8\"\nobj_addr(get(\"mean\"))\n#> [1] \"0x1302978d8\"\nobj_addr(evalq(mean))\n#> [1] \"0x1302978d8\"\nobj_addr(match.fun(\"mean\"))\n#> [1] \"0x1302978d8\"\nmake.names(c(\"123abc\", \"@me\", \"_yu\", \"  gh\", \"else\"))\n#> [1] \"X123abc\" \"X.me\"    \"X_yu\"    \"X..gh\"   \"else.\"\ntypeof(.123e1)\n#> [1] \"double\"\nmake.names(.123e1)\n#> [1] \"X1.23\""},{"path":"names-and-values.html","id":"exercises-1","chapter":"2 Names and values","heading":"2.2 2.3.6 Exercises","text":"Q1. tracemem(1:10) useful?A1.tracemem() traces copying objects R, since object created assigned name, nothing trace.Q2. Explain tracemem() shows two copies run code. Hint: carefully look difference code code shown earlier section.A2.4 double - integer (4L) - modified place.Try integer:still produces copy, Solutions manual:Please aware running code RStudio result additional copies reference environment pane.Q3. Sketch relationship following objects:A3.Q4. happens run code?Draw picture.A4.Figure official solution manual can found :\nhttps://advanced-r-solutions.rbind.io/images/names_values/copy_on_modify_fig2.png","code":"\ntracemem(1:10)\n#> [1] \"<0x11235d1d8>\"\nx <- c(1L, 2L, 3L)\ntracemem(x)\n\nx[[3]] <- 4\nx <- c(1L, 2L, 3L)\ntracemem(x)\n#> [1] \"<0x130865a08>\"\n\nx[[3]] <- 4\n#> tracemem[0x130865a08 -> 0x1308a37c8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local \n#> tracemem[0x1308a37c8 -> 0x110e04628]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\nx <- c(1L, 2L, 3L)\ntracemem(x)\n#> [1] \"<0x130487888>\"\n\nx[[3]] <- 4L\n#> tracemem[0x130487888 -> 0x130577408]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\n\nref(a)\n#> [1:0x111ec6710] <int>\n\nref(b)\n#> █ [1:0x110edce88] <list> \n#> ├─[2:0x111ec6710] <int> \n#> └─[2:0x111ec6710]\n\nref(c)\n#> █ [1:0x110b93258] <list> \n#> ├─█ [2:0x110edce88] <list> \n#> │ ├─[3:0x111ec6710] <int> \n#> │ └─[3:0x111ec6710] \n#> ├─[3:0x111ec6710] \n#> └─[4:0x1121f0858] <int>\nx <- list(1:10)\nx[[2]] <- x\nx <- list(1:10)\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nobj_addr(x)\n#> [1] \"0x112ebe3b8\"\n\nx[[2]] <- x\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> [[2]]\n#> [[2]][[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nobj_addr(x)\n#> [1] \"0x1304db148\"\n\nref(x)\n#> █ [1:0x1304db148] <list> \n#> ├─[2:0x1124a3e98] <int> \n#> └─█ [3:0x112ebe3b8] <list> \n#>   └─[2:0x1124a3e98]"},{"path":"names-and-values.html","id":"exercises-2","chapter":"2 Names and values","heading":"2.3 2.4.1 Exercises","text":"Q1. following example, object.size(y) obj_size(y) radically different? Consult documentation object.size().A1.function…detect elements list shared.Q2. Take following list. size somewhat misleading?A2.functions externally created objects R, always available, doesn’t make much sense measure size.Nevertheless, ’s still interesting addition size list objects.Q3. Predict output following code:A3. Correctly predicted 😉","code":"\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\nobj_size(y)\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#> 8005648 bytes\n\nobj_size(y)\n#> 80,896 B\nfuns <- list(mean, sd, var)\nobj_size(funs)\nfuns <- list(mean, sd, var)\nobj_size(funs)\n#> 17,608 B\nobj_size(mean)\n#> 1,184 B\nobj_size(sd)\n#> 4,480 B\nobj_size(var)\n#> 12,472 B\n\nobj_size(mean) + obj_size(sd) + obj_size(var)\n#> 18,136 B\na <- runif(1e6)\nobj_size(a)\n\nb <- list(a, a)\nobj_size(b)\nobj_size(a, b)\n\nb[[1]][[1]] <- 10\nobj_size(b)\nobj_size(a, b)\n\nb[[2]][[1]] <- 10\nobj_size(b)\nobj_size(a, b)\na <- runif(1e6)\nobj_size(a)\n#> 8,000,048 B\n\nb <- list(a, a)\nobj_size(b)\n#> 8,000,112 B\nobj_size(a, b)\n#> 8,000,112 B\n\nb[[1]][[1]] <- 10\nobj_size(b)\n#> 16,000,160 B\nobj_size(a, b)\n#> 16,000,160 B\n\nb[[2]][[1]] <- 10\nobj_size(b)\n#> 16,000,160 B\nobj_size(a, b)\n#> 24,000,208 B"},{"path":"names-and-values.html","id":"exercises-3","chapter":"2 Names and values","heading":"2.4 2.5.3 Exercises","text":"Q1. Explain following code doesn’t create circular list.A1.Copy--modify prevents creation circular list.Q2. Wrap two methods subtracting medians two functions, use ‘bench’ package carefully compare speeds. performance change number columns increase?A2.Let’s first microbenchmark functions create copies varying lengths number columns.Plotting benchmarks reveals performance gets increasingly worse number dataframes increases:Q3. happens attempt use tracemem() environment?A3.doesn’t work documentation makes clear :useful trace NULL, environments, promises, weak references, external pointer objects, duplicated","code":"\nx <- list()\nx[[1]] <- x\nx <- list()\n\nobj_addr(x)\n#> [1] \"0x11558cec0\"\n\ntracemem(x)\n#> [1] \"<0x11558cec0>\"\n\nx[[1]] <- x\n#> tracemem[0x11558cec0 -> 0x1156925c8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> do.call eval eval eval eval eval.parent local\n\nobj_addr(x[[1]])\n#> [1] \"0x11558cec0\"\nlibrary(bench)\nlibrary(tidyverse)\n\ngenerateDataFrame <- function(ncol) {\n  as.data.frame(matrix(runif(100 * ncol), nrow = 100))\n}\n\nwithCopy <- function(ncol) {\n  x <- generateDataFrame(ncol)\n  medians <- vapply(x, median, numeric(1))\n\n  for (i in seq_along(medians)) {\n    x[[i]] <- x[[i]] - medians[[i]]\n  }\n\n  return(x)\n}\n\nwithoutCopy <- function(ncol) {\n  x <- generateDataFrame(ncol)\n  medians <- vapply(x, median, numeric(1))\n\n  y <- as.list(x)\n\n  for (i in seq_along(medians)) {\n    y[[i]] <- y[[i]] - medians[[i]]\n  }\n\n  return(y)\n}\n\nbenchComparison <- function(ncol) {\n  bench::mark(\n    withCopy(ncol),\n    withoutCopy(ncol),\n    iterations = 100,\n    check = FALSE\n  ) %>%\n    dplyr::select(expression:total_time)\n}\n\nnColList <- list(1, 10, 50, 100, 250, 500, 1000)\n\nnames(nColList) <- as.character(nColList)\n\nbenchDf <- purrr::map_dfr(\n  .x = nColList,\n  .f = benchComparison,\n  .id = \"nColumns\"\n)\nggplot(\n  benchDf,\n  aes(\n    x = as.numeric(nColumns),\n    y = median,\n    group = as.character(expression),\n    color = as.character(expression)\n  )\n) +\n  geom_line() +\n  labs(\n    x = \"Number of Columns\",\n    y = \"Median Execution Time (ms)\",\n    colour = \"Type of function\"\n  )\ne <- rlang::env(a = 1, b = \"3\")\ntracemem(e)\n#> Error in tracemem(e): 'tracemem' is not useful for promise and environment objects"},{"path":"vectors.html","id":"vectors","chapter":"3 Vectors","heading":"3 Vectors","text":"","code":""},{"path":"vectors.html","id":"exercise-3.2.5","chapter":"3 Vectors","heading":"3.1 Exercise 3.2.5","text":"Q1. create raw complex scalars? (See ?raw ?complex.)A1.raw vectorsThe raw type holds raw bytes. example,can use also figure differences characters might look quite similar:complex vectorsComplex vectors can used represent (surprise!) complex numbers.Example complex scalar:Q2. Test knowledge vector coercion rules predicting output following uses c():A2. Usually, general type take precedence.Let’s try examples.Q3. 1 == \"1\" true? -1 < FALSE true? \"one\" < 2 false?A3. coercion rules vectors reveal comparisons return results .Q4. default missing value, NA, logical vector? ’s special logical vectors? (Hint: think c(FALSE, NA_character_).)A4. \"logical\" type lowest coercion hierarchy.NA defaulting type (e.g. \"numeric\") mean time missing element vector, rest elements converted type higher hierarchy, problematic types lower hierarchy.Q5. Precisely .atomic(), .numeric(), .vector() test ?A5..atomic()functions checks object atomic type (NULL), atomic vector.Quoting docs:.atomic true atomic types (“logical”, “integer”, “numeric”, “complex”, “character” “raw”) NULL..numeric()documentation says:.numeric return true base type class double integer values can reasonably regarded numericTherefore, function checks double integer base types types based top types (factor, Date, POSIXt, difftime)..vector()documentation function reveals:.vector returns TRUE x vector specified mode attributes names. returns FALSE otherwise.Thus, function can incorrect presence object attributes names.better way check vector:","code":"\nx <- \"A string\"\n\n(y <- charToRaw(x))\n#> [1] 41 20 73 74 72 69 6e 67\n\ntypeof(y)\n#> [1] \"raw\"\ncharToRaw(\"–\") # en-dash\n#> [1] e2 80 93\ncharToRaw(\"—\") # em-dash\n#> [1] e2 80 94\n(x <- complex(length.out = 1, real = 1, imaginary = 8))\n#> [1] 1+8i\n\ntypeof(x)\n#> [1] \"complex\"\nc(1, FALSE)\nc(\"a\", 1)\nc(TRUE, 1L)\nc(1, FALSE)\n#> [1] 1 0\n\nc(\"a\", 1)\n#> [1] \"a\" \"1\"\n\nc(TRUE, 1L)\n#> [1] 1 1\nc(1.0, 1L)\n#> [1] 1 1\n\nc(1.0, \"1.0\")\n#> [1] \"1\"   \"1.0\"\n\nc(TRUE, \"1.0\")\n#> [1] \"TRUE\" \"1.0\"\n1 == \"1\"\n#> [1] TRUE\n\nc(1, \"1\")\n#> [1] \"1\" \"1\"\n-1 < FALSE\n#> [1] TRUE\n\nc(-1, FALSE)\n#> [1] -1  0\n\"one\" < 2\n#> [1] FALSE\n\nc(\"one\", 2)\n#> [1] \"one\" \"2\"\n\nsort(c(\"one\", 2))\n#> [1] \"2\"   \"one\"\ntypeof(NA)\n#> [1] \"logical\"\n\nc(FALSE, NA_character_)\n#> [1] \"FALSE\" NA\nis.atomic(NULL)\n#> [1] TRUE\n\nis.vector(NULL)\n#> [1] FALSE\nx <- factor(c(1L, 2L))\n\nis.numeric(x)\n#> [1] FALSE\nx <- c(\"x\" = 1, \"y\" = 2)\n\nis.vector(x)\n#> [1] TRUE\n\nattr(x, \"m\") <- \"abcdef\"\n\nis.vector(x)\n#> [1] FALSE\nis.null(dim(x))\n#> [1] TRUE"},{"path":"vectors.html","id":"exercise-3.3.4","chapter":"3 Vectors","heading":"3.2 Exercise 3.3.4","text":"Q1. setNames() implemented? unname() implemented? Read source code.A1.Q2. dim() return applied 1-dimensional vector? might use NROW() NCOL()?A2. Dimensions 1-dimensional vector NULL.NROW() NCOL() helpful getting dimensions 1D vectors treating matrices dataframes.Q3. describe following three objects? makes different 1:5?A3.1:5 dimensionless vectorx1, x2, x3 one-dimensional arrayQ4. early draft used code illustrate structure():print object don’t see comment attribute. ? attribute missing, something else special ? (Hint: try using help.)A4. ?attributes (emphasis mine):Note attributes (namely class, comment, dim, dimnames, names, row.names tsp) treated specially restrictions values can set.","code":"\nsetNames\n#> function (object = nm, nm) \n#> {\n#>     names(object) <- nm\n#>     object\n#> }\n#> <bytecode: 0x1179f1e78>\n#> <environment: namespace:stats>\n\nsetNames(c(1, 2), c(\"a\", \"b\"))\n#> a b \n#> 1 2\nunname\n#> function (obj, force = FALSE) \n#> {\n#>     if (!is.null(names(obj))) \n#>         names(obj) <- NULL\n#>     if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n#>         dimnames(obj) <- NULL\n#>     obj\n#> }\n#> <bytecode: 0x1273b6de0>\n#> <environment: namespace:base>\n\nA <- provideDimnames(N <- array(1:24, dim = 2:4))\n\nunname(A, force = TRUE)\n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\n#> \n#> , , 3\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   13   15   17\n#> [2,]   14   16   18\n#> \n#> , , 4\n#> \n#>      [,1] [,2] [,3]\n#> [1,]   19   21   23\n#> [2,]   20   22   24\nx <- character(0)\n\ndim(x)\n#> NULL\n\nnrow(x)\n#> NULL\nNROW(x)\n#> [1] 0\n\nncol(x)\n#> NULL\nNCOL(x)\n#> [1] 1\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))\n(x <- 1:5)\n#> [1] 1 2 3 4 5\ndim(x)\n#> NULL\n\n(x1 <- array(1:5, c(1, 1, 5)))\n#> , , 1\n#> \n#>      [,1]\n#> [1,]    1\n#> \n#> , , 2\n#> \n#>      [,1]\n#> [1,]    2\n#> \n#> , , 3\n#> \n#>      [,1]\n#> [1,]    3\n#> \n#> , , 4\n#> \n#>      [,1]\n#> [1,]    4\n#> \n#> , , 5\n#> \n#>      [,1]\n#> [1,]    5\n(x2 <- array(1:5, c(1, 5, 1)))\n#> , , 1\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n(x3 <- array(1:5, c(5, 1, 1)))\n#> , , 1\n#> \n#>      [,1]\n#> [1,]    1\n#> [2,]    2\n#> [3,]    3\n#> [4,]    4\n#> [5,]    5\n\ndim(x1)\n#> [1] 1 1 5\ndim(x2)\n#> [1] 1 5 1\ndim(x3)\n#> [1] 5 1 1\nstructure(1:5, comment = \"my attribute\")\n#> [1] 1 2 3 4 5\nstructure(1:5, x = \"my attribute\")\n#> [1] 1 2 3 4 5\n#> attr(,\"x\")\n#> [1] \"my attribute\"\n\nstructure(1:5, comment = \"my attribute\")\n#> [1] 1 2 3 4 5"},{"path":"vectors.html","id":"exercise-3.4.5","chapter":"3 Vectors","heading":"3.3 Exercise 3.4.5","text":"Q1. sort object table() return? type? attributes ? dimensionality change tabulate variables?A1. table() returns array integer type dimensions scale number variables present.Q2. happens factor modify levels?A2. levels changes underlying integer values remain .Q3. code ? f2 f3 differ f1?A3. code:f2: underlying integers reversed, levels remain unchanged.\nf3: levels underlying integers reversed.","code":"\n(x <- table(mtcars$am))\n#> \n#>  0  1 \n#> 19 13\n(y <- table(mtcars$am, mtcars$cyl))\n#>    \n#>      4  6  8\n#>   0  3  4 12\n#>   1  8  3  2\n(z <- table(mtcars$am, mtcars$cyl, mtcars$vs))\n#> , ,  = 0\n#> \n#>    \n#>      4  6  8\n#>   0  0  0 12\n#>   1  1  3  2\n#> \n#> , ,  = 1\n#> \n#>    \n#>      4  6  8\n#>   0  3  4  0\n#>   1  7  0  0\n\n# type\npurrr::map(list(x, y, z), typeof)\n#> [[1]]\n#> [1] \"integer\"\n#> \n#> [[2]]\n#> [1] \"integer\"\n#> \n#> [[3]]\n#> [1] \"integer\"\n\n# attributes\npurrr::map(list(x, y, z), attributes)\n#> [[1]]\n#> [[1]]$dim\n#> [1] 2\n#> \n#> [[1]]$dimnames\n#> [[1]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> \n#> [[1]]$class\n#> [1] \"table\"\n#> \n#> \n#> [[2]]\n#> [[2]]$dim\n#> [1] 2 3\n#> \n#> [[2]]$dimnames\n#> [[2]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> [[2]]$dimnames[[2]]\n#> [1] \"4\" \"6\" \"8\"\n#> \n#> \n#> [[2]]$class\n#> [1] \"table\"\n#> \n#> \n#> [[3]]\n#> [[3]]$dim\n#> [1] 2 3 2\n#> \n#> [[3]]$dimnames\n#> [[3]]$dimnames[[1]]\n#> [1] \"0\" \"1\"\n#> \n#> [[3]]$dimnames[[2]]\n#> [1] \"4\" \"6\" \"8\"\n#> \n#> [[3]]$dimnames[[3]]\n#> [1] \"0\" \"1\"\n#> \n#> \n#> [[3]]$class\n#> [1] \"table\"\nf1 <- factor(letters)\nlevels(f1) <- rev(levels(f1))\nf1 <- factor(letters)\nf1\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> 26 Levels: a b c d e f g h i j k l m n o p q r s t u ... z\nas.integer(f1)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n#> [19] 19 20 21 22 23 24 25 26\n\nlevels(f1) <- rev(levels(f1))\nf1\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> 26 Levels: z y x w v u t s r q p o n m l k j i h g f ... a\nas.integer(f1)\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n#> [19] 19 20 21 22 23 24 25 26\nf2 <- rev(factor(letters))\nf3 <- factor(letters, levels = rev(letters))\nf2 <- rev(factor(letters))\nf2\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> 26 Levels: a b c d e f g h i j k l m n o p q r s t u ... z\nas.integer(f2)\n#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9\n#> [19]  8  7  6  5  4  3  2  1\n\nf3 <- factor(letters, levels = rev(letters))\nf3\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> 26 Levels: z y x w v u t s r q p o n m l k j i h g f ... a\nas.integer(f3)\n#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9\n#> [19]  8  7  6  5  4  3  2  1"},{"path":"vectors.html","id":"exercise-3.5.4","chapter":"3 Vectors","heading":"3.4 Exercise 3.5.4","text":"Q1. List ways list differs atomic vector.A1.Q2. need use unlist() convert list atomic vector? doesn’t .vector() work?A2. List already (generic) vector, .vector going change anything, .atomic.vector. Thus need use unlist().Q3. Compare contrast c() unlist() combining date date-time single vector.A3.Behavior c(): Works expected. odd thing strips tzone attribute.Behavior unlist(): Removes attributes left underlying double representations objects.","code":"\nx <- list(a = 1, b = 2)\n\nis.vector(x)\n#> [1] TRUE\nis.atomic(x)\n#> [1] FALSE\n\nas.vector(x)\n#> $a\n#> [1] 1\n#> \n#> $b\n#> [1] 2\n\nunlist(x)\n#> a b \n#> 1 2\n# creating a date and datetime\ndate <- as.Date(\"1947-08-15\")\ndatetime <- as.POSIXct(\"1950-01-26 00:01\", tz = \"UTC\")\n\n# check attributes\nattributes(date)\n#> $class\n#> [1] \"Date\"\nattributes(datetime)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\n\n# check their underlying double representation\nas.double(date) # number of days since the Unix epoch 1970-01-01\n#> [1] -8175\nas.double(datetime) # number of seconds since then\n#> [1] -628991940\nc(date, datetime)\n#> [1] \"1947-08-15\" \"1950-01-26\"\n\nattributes(c(date, datetime))\n#> $class\n#> [1] \"Date\"\n\nc(datetime, date)\n#> [1] \"1950-01-26 00:01:00 UTC\" \"1947-08-15 00:00:00 UTC\"\n\nattributes(c(datetime, date))\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\nunlist(list(date, datetime))\n#> [1]      -8175 -628991940\n\nunlist(list(datetime, date))\n#> [1] -628991940      -8175"},{"path":"vectors.html","id":"exercise-3.6.8","chapter":"3 Vectors","heading":"3.5 Exercise 3.6.8","text":"Q1. Can data frame zero rows? zero columns?A1. Data frame 0 rows possible. basically list vector length 0.Data frame 0 columns possible. empty list.one go:Q2. happens attempt set rownames unique?A2. attempt set rownames unique, work.Q3. df data frame, can say t(df), t(t(df))? Perform experiments, making sure try different column types.A3. Transposing dataframe transforms matrix coerces elements type.Q4. .matrix() applied data frame columns different types? differ data.matrix()?A4. return type .matrix() depends dataframe column types.documentation data.matrix():Return matrix obtained converting variables data frame numeric mode binding together columns matrix.data.matrix() always returns numeric matrix:","code":"\ndata.frame(x = numeric(0))\n#> [1] x\n#> <0 rows> (or 0-length row.names)\ndata.frame(row.names = 1)\n#> data frame with 0 columns and 1 row\ndata.frame()\n#> data frame with 0 columns and 0 rows\n\ndim(data.frame())\n#> [1] 0 0\ndata.frame(row.names = c(1, 1))\n#> Error in data.frame(row.names = c(1, 1)): duplicate row.names: 1\n# original\n(df <- head(iris))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n\n# transpose\nt(df)\n#>              1        2        3        4        5       \n#> Sepal.Length \"5.1\"    \"4.9\"    \"4.7\"    \"4.6\"    \"5.0\"   \n#> Sepal.Width  \"3.5\"    \"3.0\"    \"3.2\"    \"3.1\"    \"3.6\"   \n#> Petal.Length \"1.4\"    \"1.4\"    \"1.3\"    \"1.5\"    \"1.4\"   \n#> Petal.Width  \"0.2\"    \"0.2\"    \"0.2\"    \"0.2\"    \"0.2\"   \n#> Species      \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\"\n#>              6       \n#> Sepal.Length \"5.4\"   \n#> Sepal.Width  \"3.9\"   \n#> Petal.Length \"1.7\"   \n#> Petal.Width  \"0.4\"   \n#> Species      \"setosa\"\n\n# transpose of a transpose\nt(t(df))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1 \"5.1\"        \"3.5\"       \"1.4\"        \"0.2\"      \n#> 2 \"4.9\"        \"3.0\"       \"1.4\"        \"0.2\"      \n#> 3 \"4.7\"        \"3.2\"       \"1.3\"        \"0.2\"      \n#> 4 \"4.6\"        \"3.1\"       \"1.5\"        \"0.2\"      \n#> 5 \"5.0\"        \"3.6\"       \"1.4\"        \"0.2\"      \n#> 6 \"5.4\"        \"3.9\"       \"1.7\"        \"0.4\"      \n#>   Species \n#> 1 \"setosa\"\n#> 2 \"setosa\"\n#> 3 \"setosa\"\n#> 4 \"setosa\"\n#> 5 \"setosa\"\n#> 6 \"setosa\"\n\n# is it a dataframe?\nis.data.frame(df)\n#> [1] TRUE\nis.data.frame(t(df))\n#> [1] FALSE\nis.data.frame(t(t(df)))\n#> [1] FALSE\n\n# check type\ntypeof(df)\n#> [1] \"list\"\ntypeof(t(df))\n#> [1] \"character\"\ntypeof(t(t(df)))\n#> [1] \"character\"\n\n# check dimensions\ndim(df)\n#> [1] 6 5\ndim(t(df))\n#> [1] 5 6\ndim(t(t(df)))\n#> [1] 6 5\n# example with mixed types (coerced to character)\n(df <- head(iris))\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n\nas.matrix(df)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width\n#> 1 \"5.1\"        \"3.5\"       \"1.4\"        \"0.2\"      \n#> 2 \"4.9\"        \"3.0\"       \"1.4\"        \"0.2\"      \n#> 3 \"4.7\"        \"3.2\"       \"1.3\"        \"0.2\"      \n#> 4 \"4.6\"        \"3.1\"       \"1.5\"        \"0.2\"      \n#> 5 \"5.0\"        \"3.6\"       \"1.4\"        \"0.2\"      \n#> 6 \"5.4\"        \"3.9\"       \"1.7\"        \"0.4\"      \n#>   Species \n#> 1 \"setosa\"\n#> 2 \"setosa\"\n#> 3 \"setosa\"\n#> 4 \"setosa\"\n#> 5 \"setosa\"\n#> 6 \"setosa\"\n\nstr(as.matrix(df))\n#>  chr [1:6, 1:5] \"5.1\" \"4.9\" \"4.7\" \"4.6\" \"5.0\" \"5.4\" ...\n#>  - attr(*, \"dimnames\")=List of 2\n#>   ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ : chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ...\n\n# another example (no such coercion)\nBOD\n#>   Time demand\n#> 1    1    8.3\n#> 2    2   10.3\n#> 3    3   19.0\n#> 4    4   16.0\n#> 5    5   15.6\n#> 6    7   19.8\n\nas.matrix(BOD)\n#>      Time demand\n#> [1,]    1    8.3\n#> [2,]    2   10.3\n#> [3,]    3   19.0\n#> [4,]    4   16.0\n#> [5,]    5   15.6\n#> [6,]    7   19.8\ndata.matrix(df)\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2       1\n#> 2          4.9         3.0          1.4         0.2       1\n#> 3          4.7         3.2          1.3         0.2       1\n#> 4          4.6         3.1          1.5         0.2       1\n#> 5          5.0         3.6          1.4         0.2       1\n#> 6          5.4         3.9          1.7         0.4       1\n\nstr(data.matrix(df))\n#>  num [1:6, 1:5] 5.1 4.9 4.7 4.6 5 5.4 3.5 3 3.2 3.1 ...\n#>  - attr(*, \"dimnames\")=List of 2\n#>   ..$ : chr [1:6] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ : chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ..."},{"path":"subsetting.html","id":"subsetting","chapter":"4 Subsetting","heading":"4 Subsetting","text":"","code":""},{"path":"subsetting.html","id":"exercise-4.2.6","chapter":"4 Subsetting","heading":"4.1 Exercise 4.2.6","text":"Q1. Fix following common data frame subsetting errors:A1. Fixed versions commands:Q2. following code yield five missing values?A2. two reasons:default type NA R logical type.R recycles indexes match length vector.Q3. upper.tri() return? subsetting matrix work? need additional subsetting rules describe behaviour?A3. documentation upper.tri() states-Returns matrix logicals size given matrix entries TRUE upper triangleThat , upper.tri() return matrix logicals.used matrix subsetting, logical matrix returns vector:Q4. mtcars[1:20] return error? differ similar mtcars[1:20, ]?indexed like list, data frame columns given indices selected.mtcars[1:20] doesn’t work 11 columns mtcars dataset.hand, mtcars[1:20, ] indexes dataframe like matrix, indeed 20 rows mtcars, columns rows selected.Q5. Implement function extracts diagonal entries matrix (behave like diag(x) x matrix).A5. can combine existing functions advantage:Q6. df[.na(df)] <- 0 ? work?A6. command replaces every instance NA dataframe 0..na(df) produces matrix logical values, provides way select assign.","code":"mtcars[mtcars$cyl = 4, ]\nmtcars[-1:4, ]\nmtcars[mtcars$cyl <= 5]\nmtcars[mtcars$cyl == 4 | 6, ]\nmtcars[mtcars$cyl == 4, ]\nmtcars[-(1:4), ]\nmtcars[mtcars$cyl <= 5, ]\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\nx <- 1:5\nx[NA]\n#> [1] NA NA NA NA NA\ntypeof(NA)\n#> [1] \"logical\"\nx <- 1:5\nx[c(TRUE, FALSE)] # recycled to c(TRUE, FALSE, TRUE, FALSE, TRUE)\n#> [1] 1 3 5\nx <- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]\n(x <- outer(1:5, 1:5, FUN = \"*\"))\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]    2    4    6    8   10\n#> [3,]    3    6    9   12   15\n#> [4,]    4    8   12   16   20\n#> [5,]    5   10   15   20   25\n\nupper.tri(x)\n#>       [,1]  [,2]  [,3]  [,4]  [,5]\n#> [1,] FALSE  TRUE  TRUE  TRUE  TRUE\n#> [2,] FALSE FALSE  TRUE  TRUE  TRUE\n#> [3,] FALSE FALSE FALSE  TRUE  TRUE\n#> [4,] FALSE FALSE FALSE FALSE  TRUE\n#> [5,] FALSE FALSE FALSE FALSE FALSE\nx[upper.tri(x)]\n#>  [1]  2  3  6  4  8 12  5 10 15 20\nhead(mtcars[1:2])\n#>                    mpg cyl\n#> Mazda RX4         21.0   6\n#> Mazda RX4 Wag     21.0   6\n#> Datsun 710        22.8   4\n#> Hornet 4 Drive    21.4   6\n#> Hornet Sportabout 18.7   8\n#> Valiant           18.1   6\nnrow(mtcars[1:20, ])\n#> [1] 20\nx[!upper.tri(x) & !lower.tri(x)]\n#> [1]  1  4  9 16 25\n\ndiag(x)\n#> [1]  1  4  9 16 25\n(df <- tibble(x = c(1, 2, NA), y = c(NA, 5, NA)))\n#> # A tibble: 3 × 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     1    NA\n#> 2     2     5\n#> 3    NA    NA\n\nis.na(df)\n#>          x     y\n#> [1,] FALSE  TRUE\n#> [2,] FALSE FALSE\n#> [3,]  TRUE  TRUE\n\nclass(is.na(df))\n#> [1] \"matrix\" \"array\""},{"path":"subsetting.html","id":"exercise-4.3.5","chapter":"4 Subsetting","heading":"4.2 Exercise 4.3.5","text":"Q1. Brainstorm many ways possible extract third value cyl variable mtcars dataset.A1. Possible ways :Q2. Given linear model, e.g., mod <- lm(mpg ~ wt, data = mtcars), extract residual degrees freedom. extract R squared model summary (summary(mod))A2. Specified linear model:extracting residual degrees freedomextracting R squared model summary","code":"\nmtcars$cyl[[3]]\n#> [1] 4\nmtcars[, \"cyl\"][[3]]\n#> [1] 4\nmtcars[[\"cyl\"]][[3]]\n#> [1] 4\n\nmtcars[3, ]$cyl\n#> [1] 4\nmtcars[3, \"cyl\"]\n#> [1] 4\nmtcars[3, ][[\"cyl\"]]\n#> [1] 4\n\nmtcars[[c(2, 3)]]\n#> [1] 4\nmtcars[3, 2]\n#> [1] 4\nmod <- lm(mpg ~ wt, data = mtcars)\nmod$df.residual \n#> [1] 30\n\n# or \n\nmod[[\"df.residual\"]]\n#> [1] 30\nsummary(mod)$r.squared\n#> [1] 0.7528328"},{"path":"subsetting.html","id":"exercise-4.5.9","chapter":"4 Subsetting","heading":"4.3 Exercise 4.5.9","text":"Q1. randomly permute columns data frame? (important technique random forests.) Can simultaneously permute rows columns one step?Q2. select random sample m rows data frame? sample contiguous (.e., initial row, final row, every row )?Q3. put columns data frame alphabetical order?","code":""},{"path":"control-flow.html","id":"control-flow","chapter":"5 Control flow","heading":"5 Control flow","text":"","code":""},{"path":"control-flow.html","id":"exercise-5.2.4","chapter":"5 Control flow","heading":"5.1 Exercise 5.2.4","text":"Q1. type vector following calls ifelse() return?Read documentation write rules words.A1. da rulz:’s type unstable, .e. type return depend type condition (yes , .e.):works cases test argument evaluates logical type:test argument doesn’t resolve logical type, try coerce output logical type:quote docs function:vector length attributes (including dimensions \"class\") test data values values yes . mode answer coerced logical accommodate first values taken yes values taken .Q2. following code work?A2. code works conditions - even though numeric type - successfully coerced logical type.","code":"\nifelse(TRUE, 1, \"no\")\nifelse(FALSE, 1, \"no\")\nifelse(NA, 1, \"no\")\nifelse(TRUE, 1, \"no\") # `numeric` returned\n#> [1] 1\nifelse(FALSE, 1, \"no\") # `character` returned\n#> [1] \"no\"\nifelse(NA_real_, 1, \"no\")\n#> [1] NA\nifelse(NaN, 1, \"no\")\n#> [1] NA\n# will work\nifelse(\"TRUE\", 1, \"no\")\n#> [1] 1\nifelse(\"true\", 1, \"no\")\n#> [1] 1\n\n# won't work\nifelse(\"tRuE\", 1, \"no\")\n#> [1] NA\nifelse(NaN, 1, \"no\")\n#> [1] NA\nx <- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"not empty\"\n\nx <- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"empty\"\nas.logical(length(1:10))\n#> [1] TRUE\n\nas.logical(length(numeric()))\n#> [1] FALSE"},{"path":"control-flow.html","id":"exercise-5.3.3","chapter":"5 Control flow","heading":"5.2 Exercise 5.3.3","text":"Q1. code succeed without errors warnings?A1. works 1:length(x) goes ways; case, 1 0. , since --bound values atomic vectors NA, related operations also lead NA.way avoid unintended behavior :Q2. following code evaluated, can say vector iterated?A2. iterator variable x initially takes values vector xs. can check printing x iteration:worth noting x updated iteration, otherwise take increasingly bigger values xs, loop never end executing.Q3. following code tell index updated?A3. loop index updated beginning iteration. Otherwise, encounter infinite loop.Also, worth contrasting behavior loop loop:","code":"\nx <- numeric()\nout <- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] <- x[i]^2\n}\nout\nx <- numeric()\nout <- vector(\"list\", length(x))\n\nfor (i in 1:length(x)) {\n  print(paste(\"i:\", i, \", x[i]:\", x[i], \", out[i]:\", out[i]))\n\n  out[i] <- x[i]^2\n}\n#> [1] \"i: 1 , x[i]: NA , out[i]: NULL\"\n#> [1] \"i: 0 , x[i]:  , out[i]: \"\n\nout\n#> [[1]]\n#> [1] NA\nx <- numeric()\nout <- vector(\"list\", length(x))\n\nfor (i in 1:seq_along(x)) {\n  out[i] <- x[i]^2\n}\n#> Error in 1:seq_along(x): argument of length 0\n\nout\n#> list()\nxs <- c(1, 2, 3)\nfor (x in xs) {\n  xs <- c(xs, x * 2)\n}\nxs\n#> [1] 1 2 3 2 4 6\nxs <- c(1, 2, 3)\nfor (x in xs) {\n  print(x)\n  xs <- c(xs, x * 2)\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\nfor (i in 1:3) {\n  i <- i * 2\n  print(i)\n}\n#> [1] 2\n#> [1] 4\n#> [1] 6\nfor (i in 1:3) {\n  cat(\"before: \", i, \"\\n\")\n  i <- i * 2\n  cat(\"after:  \", i, \"\\n\")\n}\n#> before:  1 \n#> after:   2 \n#> before:  2 \n#> after:   4 \n#> before:  3 \n#> after:   6\ni <- 1\nwhile (i < 4) {\n  cat(\"before: \", i, \"\\n\")\n  i <- i * 2\n  cat(\"after:  \", i, \"\\n\")\n}\n#> before:  1 \n#> after:   2 \n#> before:  2 \n#> after:   4"},{"path":"functions.html","id":"functions","chapter":"6 Functions","heading":"6 Functions","text":"","code":""},{"path":"functions.html","id":"exercise-6.2.5","chapter":"6 Functions","heading":"6.1 Exercise 6.2.5","text":"Q1. Given name, like \"mean\", match.fun() lets find function. Given function, can find name? doesn’t make sense R?A1. Given name, match.fun() lets find function., given function, doesn’t make sense find name R can multiple names bound function.Q2. ’s possible (although typically useful) call anonymous function. two approaches correct? ?A2. correct since function evaluate 3(), syntactically allowed since literals can’t treated like functions.correct.Q3. good rule thumb anonymous function fit one line shouldn’t need use {}. Review code. used anonymous function instead named function? used named function instead anonymous function?A3. Self activity.Q4. function allows tell object function? function allows tell function primitive function?A4. Use .function() check object function:Use .primitive() check function primitive:Q5. code makes list functions base package.A5. provided code following:base function arguments?scan() function arguments.many base functions arguments? ’s special functions?time writing, 253 base functions arguments. primitive functionsHow adapt code find primitive functions?Q6. three important components function?A6. Except primitive functions, functions 3 important components:formals()body()environment()Q7. printing function show environment created ?A7. package functions print environment:two exceptions rule:primitive functionsfunctions created global environment","code":"\nmatch.fun(\"mean\")\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x10e488230>\n#> <environment: namespace:base>\nf1 <- function(x) mean(x)\nf2 <- f1\n\nmatch.fun(\"f1\")\n#> function(x) mean(x)\n\nmatch.fun(\"f2\")\n#> function(x) mean(x)\nfunction(x) 3()\n#> function(x) 3()\n(function(x) 3)()\n#> [1] 3\n(function(x) 3())()\n#> Error in (function(x) 3())(): attempt to apply non-function\n(function(x) 3)()\n#> [1] 3\n# these are functions\nf <- function(x) 3\nis.function(mean)\n#> [1] TRUE\nis.function(f)\n#> [1] TRUE\n\n# these aren't\nis.function(\"x\")\n#> [1] FALSE\nis.function(new.env())\n#> [1] FALSE\n# primitive\nis.primitive(sum)\n#> [1] TRUE\nis.primitive(`+`)\n#> [1] TRUE\n\n# not primitive\nis.primitive(mean)\n#> [1] FALSE\nis.primitive(read.csv)\n#> [1] FALSE\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)Use it to answer the following questions:\n\na. Which base function has the most arguments?\n\na. How many base functions have no arguments? What's special about those\n   functions?\n   \na. How could you adapt the code to find all primitive functions?\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\nlibrary(tidyverse)\n\ndf_formals <- purrr::map_df(funs, ~ length(formals(.))) %>%\n  tidyr::pivot_longer(\n    cols = dplyr::everything(),\n    names_to = \"function\",\n    values_to = \"argumentCount\"\n  ) %>%\n  dplyr::arrange(desc(argumentCount))\ndplyr::filter(df_formals, argumentCount == 0)\n#> # A tibble: 251 × 2\n#>    `function` argumentCount\n#>    <chr>              <int>\n#>  1 -                      0\n#>  2 :                      0\n#>  3 ::                     0\n#>  4 :::                    0\n#>  5 !                      0\n#>  6 !=                     0\n#>  7 ...elt                 0\n#>  8 ...length              0\n#>  9 ...names               0\n#> 10 .C                     0\n#> # … with 241 more rows\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\nprimitives <- Filter(is.primitive, funs)\n\nnames(primitives)\n#>   [1] \"-\"                    \":\"                   \n#>   [3] \"::\"                   \":::\"                 \n#>   [5] \"!\"                    \"!=\"                  \n#>   [7] \"...elt\"               \"...length\"           \n#>   [9] \"...names\"             \".C\"                  \n#>  [11] \".cache_class\"         \".Call\"               \n#>  [13] \".Call.graphics\"       \".class2\"             \n#>  [15] \".External\"            \".External.graphics\"  \n#>  [17] \".External2\"           \".Fortran\"            \n#>  [19] \".Internal\"            \".isMethodsDispatchOn\"\n#>  [21] \".Primitive\"           \".primTrace\"          \n#>  [23] \".primUntrace\"         \".subset\"             \n#>  [25] \".subset2\"             \"(\"                   \n#>  [27] \"[\"                    \"[[\"                  \n#>  [29] \"[[<-\"                 \"[<-\"                 \n#>  [31] \"{\"                    \"@\"                   \n#>  [33] \"@<-\"                  \"*\"                   \n#>  [35] \"/\"                    \"&\"                   \n#>  [37] \"&&\"                   \"%*%\"                 \n#>  [39] \"%/%\"                  \"%%\"                  \n#>  [41] \"^\"                    \"+\"                   \n#>  [43] \"<\"                    \"<-\"                  \n#>  [45] \"<<-\"                  \"<=\"                  \n#>  [47] \"=\"                    \"==\"                  \n#>  [49] \">\"                    \">=\"                  \n#>  [51] \"|\"                    \"||\"                  \n#>  [53] \"~\"                    \"$\"                   \n#>  [55] \"$<-\"                  \"abs\"                 \n#>  [57] \"acos\"                 \"acosh\"               \n#>  [59] \"all\"                  \"any\"                 \n#>  [61] \"anyNA\"                \"Arg\"                 \n#>  [63] \"as.call\"              \"as.character\"        \n#>  [65] \"as.complex\"           \"as.double\"           \n#>  [67] \"as.environment\"       \"as.integer\"          \n#>  [69] \"as.logical\"           \"as.numeric\"          \n#>  [71] \"as.raw\"               \"asin\"                \n#>  [73] \"asinh\"                \"atan\"                \n#>  [75] \"atanh\"                \"attr\"                \n#>  [77] \"attr<-\"               \"attributes\"          \n#>  [79] \"attributes<-\"         \"baseenv\"             \n#>  [81] \"break\"                \"browser\"             \n#>  [83] \"c\"                    \"call\"                \n#>  [85] \"ceiling\"              \"class\"               \n#>  [87] \"class<-\"              \"Conj\"                \n#>  [89] \"cos\"                  \"cosh\"                \n#>  [91] \"cospi\"                \"cummax\"              \n#>  [93] \"cummin\"               \"cumprod\"             \n#>  [95] \"cumsum\"               \"digamma\"             \n#>  [97] \"dim\"                  \"dim<-\"               \n#>  [99] \"dimnames\"             \"dimnames<-\"          \n#> [101] \"emptyenv\"             \"enc2native\"          \n#> [103] \"enc2utf8\"             \"environment<-\"       \n#> [105] \"exp\"                  \"expm1\"               \n#> [107] \"expression\"           \"floor\"               \n#> [109] \"for\"                  \"forceAndCall\"        \n#> [111] \"function\"             \"gamma\"               \n#> [113] \"gc.time\"              \"globalenv\"           \n#> [115] \"if\"                   \"Im\"                  \n#> [117] \"interactive\"          \"invisible\"           \n#> [119] \"is.array\"             \"is.atomic\"           \n#> [121] \"is.call\"              \"is.character\"        \n#> [123] \"is.complex\"           \"is.double\"           \n#> [125] \"is.environment\"       \"is.expression\"       \n#> [127] \"is.finite\"            \"is.function\"         \n#> [129] \"is.infinite\"          \"is.integer\"          \n#> [131] \"is.language\"          \"is.list\"             \n#> [133] \"is.logical\"           \"is.matrix\"           \n#> [135] \"is.na\"                \"is.name\"             \n#> [137] \"is.nan\"               \"is.null\"             \n#> [139] \"is.numeric\"           \"is.object\"           \n#> [141] \"is.pairlist\"          \"is.raw\"              \n#> [143] \"is.recursive\"         \"is.single\"           \n#> [145] \"is.symbol\"            \"isS4\"                \n#> [147] \"lazyLoadDBfetch\"      \"length\"              \n#> [149] \"length<-\"             \"levels<-\"            \n#> [151] \"lgamma\"               \"list\"                \n#> [153] \"log\"                  \"log10\"               \n#> [155] \"log1p\"                \"log2\"                \n#> [157] \"max\"                  \"min\"                 \n#> [159] \"missing\"              \"Mod\"                 \n#> [161] \"names\"                \"names<-\"             \n#> [163] \"nargs\"                \"next\"                \n#> [165] \"nzchar\"               \"oldClass\"            \n#> [167] \"oldClass<-\"           \"on.exit\"             \n#> [169] \"pos.to.env\"           \"proc.time\"           \n#> [171] \"prod\"                 \"quote\"               \n#> [173] \"range\"                \"Re\"                  \n#> [175] \"rep\"                  \"repeat\"              \n#> [177] \"retracemem\"           \"return\"              \n#> [179] \"round\"                \"seq_along\"           \n#> [181] \"seq_len\"              \"seq.int\"             \n#> [183] \"sign\"                 \"signif\"              \n#> [185] \"sin\"                  \"sinh\"                \n#> [187] \"sinpi\"                \"sqrt\"                \n#> [189] \"standardGeneric\"      \"storage.mode<-\"      \n#> [191] \"substitute\"           \"sum\"                 \n#> [193] \"switch\"               \"tan\"                 \n#> [195] \"tanh\"                 \"tanpi\"               \n#> [197] \"tracemem\"             \"trigamma\"            \n#> [199] \"trunc\"                \"unclass\"             \n#> [201] \"untracemem\"           \"UseMethod\"           \n#> [203] \"while\"                \"xtfrm\"\n# base\nmean\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x10e488230>\n#> <environment: namespace:base>\n\n# other package function\npurrr::map\n#> function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> }\n#> <bytecode: 0x108bb8aa0>\n#> <environment: namespace:purrr>\nsum\n#> function (..., na.rm = FALSE)  .Primitive(\"sum\")\nf <- function(x) mean(x)\nf\n#> function(x) mean(x)"},{"path":"functions.html","id":"exercise-6.4.5","chapter":"6 Functions","heading":"6.2 Exercise 6.4.5","text":"Q1. following code return? ? Describe three c’s interpreted.A1. c(c = c):first c interpreted function c()second c name vector elementthird c variable value 10Q2. four principles govern R looks values?A2. four principles:Name masking (names defined inside function mask names defined outside function)Name masking (names defined inside function mask names defined outside function)Functions vs. variables (rule also applies function names)Functions vs. variables (rule also applies function names)fresh start (every time function called new environment created host execution)fresh start (every time function called new environment created host execution)Dynamic look-(R looks values function run, function created)Dynamic look-(R looks values function run, function created)Q3. following function return? Make prediction \nrunning code .Correctly predicted 😉😉","code":"\nc <- 10\nc(c = c)\nc <- 10\nc(c = c)\n#>  c \n#> 10\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\n\nf(10)\n#> [1] 202"},{"path":"functions.html","id":"exercise-6.5.4","chapter":"6 Functions","heading":"6.3 Exercise 6.5.4","text":"Q1. important property && makes x_ok() work?different code? behaviour undesirable ?A1. && evaluates left right short-circuit evaluation, .e., first operand TRUE, R short-circuit even look second operand.Replacing && & undesirable performs element-wise logical comparisons returns vector values always useful decision (TRUE, FALSE, NA).Q2. function return? ? principle illustrate?A2. function returns 100, principle work lazy evaluation. function environment encounters x, evaluates argument x = z since name z already bound value 100, x also bound value.can check looking memory addresses:Q3. function return? ? principle illustrate?A3. TODO:Q4. hist(), default value xlim range(breaks), default value breaks \"Sturges\", andExplain hist() works get correct xlim value.Q5. Explain function works. confusing?Q6. many arguments required calling library()?","code":"\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\nx_ok(1)\nx_ok(1:3)\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\nx_ok(1)\nx_ok(1:3)\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\n\nx_ok(1)\n#> [1] TRUE\n\nx_ok(1:3)\n#> [1] FALSE\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\n\nx_ok(1)\n#> [1] TRUE\n\nx_ok(1:3)\n#> [1] FALSE FALSE FALSE\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()\nf2 <- function(x = z) {\n  z <- 100\n  print(x)\n\n  print(lobstr::obj_addrs(list(x, z)))\n}\n\nf2()\n#> [1] 100\n#> [1] \"0x11c1097e8\" \"0x11c1097e8\"\ny <- 10\nf1 <- function(x =\n                 {\n                   y <- 1\n                   2\n                 },\n               y = 0)\n{\n  c(x, y)\n}\nf1()\ny\ny <- 10\nf1 <- function(x =\n                 {\n                   y <- 1\n                   2\n                 },\n               y = 0)\n{\n  c(x, y)\n}\nf1()\n#> [1] 2 1\ny\n#> [1] 10\nrange(\"Sturges\")\n#> [1] \"Sturges\" \"Sturges\"\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#> [1] \"2022-03-27 20:30:23 CEST\""},{"path":"functions.html","id":"exercise-6.6.1","chapter":"6 Functions","heading":"6.4 Exercise 6.6.1","text":"Q1. Explain following results:A1. Let’s look arguments functions:can seen, sum() function doesn’t na.omit argument. , input na.omit = TRUE treated 1 (logical implicitly coerced numeric), thus results. , expression evaluates sum(1, 2, 3, 1).mean() function, one parameter (x) ’s matched first argument (1). , expression evaluates mean(1).Q2. Explain find documentation named arguments following function call:A2. First, check documentation plot():Since ... passed par(), can look documentation:docs parameters interest reside .Q3. plot(1:10, col = \"red\") colour points, axes labels? Read source code plot.default() find .A3. Source code can found .plot.default() passes ... localTitle(), passes title().title() four parts: main, sub, xlab, ylab.single argument col work ambiguous element apply argument .","code":"\nsum(1, 2, 3)\n#> [1] 6\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1\nstr(sum)\n#> function (..., na.rm = FALSE)\nstr(mean)\n#> function (x, ...)```r\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\n```\n\n<img src=\"Functions_files/figure-html/unnamed-chunk-33-1.png\" width=\"288\" />\nstr(plot)\n#> function (x, y, ...)\nstr(par)\n#> function (..., no.readonly = FALSE)\nlocalTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)\n\ntitle <- function(main = NULL, sub = NULL, xlab = NULL, ylab = NULL,\n                  line = NA, outer = FALSE, ...) {\n  main <- as.graphicsAnnot(main)\n  sub <- as.graphicsAnnot(sub)\n  xlab <- as.graphicsAnnot(xlab)\n  ylab <- as.graphicsAnnot(ylab)\n  .External.graphics(C_title, main, sub, xlab, ylab, line, outer, ...)\n  invisible()\n}"},{"path":"environments.html","id":"environments","chapter":"7 Environments","heading":"7 Environments","text":"","code":""},{"path":"environments.html","id":"exercises-7.2.7","chapter":"7 Environments","heading":"7.0.1 Exercises 7.2.7","text":"Q1. List three ways environment differs list.Q2. Create environment illustrated picture.Q3. Create pair environments illustrated picture.Q4. Explain e[[1]] e[c(\"\", \"b\")] don’t make sense e environment.Q5. Create version env_poke() bind new names, never re-bind old names. programming languages , known [single assignment languages][https://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment].Q6. function ? differ <<- might prefer ?","code":"\nrebind <- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"a\", 10)\n#> Error: Can't find `a`\na <- 5\nrebind(\"a\", 10)\na\n#> [1] 10"},{"path":"environments.html","id":"exercises-7.3.1","chapter":"7 Environments","heading":"7.0.2 Exercises 7.3.1","text":"Q1. Modify () return environments contain binding name. Carefully think type object function need return.Q2. Write function called fget() finds function objects. two arguments, name env, obey regular scoping rules functions: ’s object matching name ’s function, look parent. added challenge, also add inherits argument controls whether function recurses parents looks one environment.","code":""},{"path":"environments.html","id":"exercises-7.4.5","chapter":"7 Environments","heading":"7.0.3 Exercises 7.4.5","text":"Q1. search_envs() different env_parents(global_env())?Q2. Draw diagram shows enclosing environments function:Q3. Write enhanced version str() provides information functions. Show function found environment defined .","code":"\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)"},{"path":"environments.html","id":"exercises-7.5.5","chapter":"7 Environments","heading":"7.0.4 Exercises 7.5.5","text":"Q1. Write function lists variables defined environment called. return results ls().","code":""},{"path":"conditions.html","id":"conditions","chapter":"8 Conditions","heading":"8 Conditions","text":"","code":""},{"path":"conditions.html","id":"exercises-8.2.4","chapter":"8 Conditions","heading":"8.0.1 Exercises 8.2.4","text":"Q1. Write wrapper around file.remove() throws error file deleted exist.A1. Let’s first create wrapper function around file.remove() throws error file deleted exist.Let’s first create file can delete immediately.function fail files provided don’t exist:work expected file exists:Q2. appendLF argument message() ? related cat()?","code":"\nfileRemove <- function(...) {\n  existing_files <- fs::file_exists(...)\n\n  if (!all(existing_files)) {\n    stop(\n      cat(\n        \"The following files to be deleted don't exist:\",\n        names(existing_files[!existing_files]),\n        sep = \"\\n\"\n      )\n    )\n  }\n\n  file.remove(...)\n}\nfs::file_create(\"random.R\")\nfileRemove(c(\"random.R\", \"XYZ.csv\"))\n#> The following files to be deleted don't exist:\n#> XYZ.csv\n#> Error in fileRemove(c(\"random.R\", \"XYZ.csv\")):\nfileRemove(\"random.R\")\n#> [1] TRUE"},{"path":"conditions.html","id":"exercises-8.4.5","chapter":"8 Conditions","heading":"8.0.2 Exercises 8.4.5","text":"Q1. extra information condition generated abort() contain compared condition generated stop() .e. ’s difference two objects? Read help ?abort learn .Q2. Predict results evaluating following codeQ3. Explain results running code:Q4. Read source code catch_cnd() explain works.Q5. rewrite show_condition() use single handler?","code":"\ncatch_cnd(stop(\"An error\"))\ncatch_cnd(abort(\"An error\"))\nshow_condition <- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\"))\nshow_condition(10)\nshow_condition(warning(\"?!\"))\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\nwithCallingHandlers(\n  message = function(cnd) message(\"b\"),\n  withCallingHandlers(\n    message = function(cnd) message(\"a\"),\n    message(\"c\")\n  )\n)\n#> b\n#> a\n#> b\n#> c"},{"path":"conditions.html","id":"exercises-8.5.4","chapter":"8 Conditions","heading":"8.0.3 Exercises 8.5.4","text":"Q1. Inside package, ’s occasionally useful check package installed using . Write function checks package installed (requireNamespace(\"pkg\", quietly = FALSE)) , throws custom condition includes package name metadata.Q2. Inside package often need stop error something right. packages depend package might tempted check errors unit tests. help packages avoid relying error message part user interface rather API might change without notice?","code":""},{"path":"conditions.html","id":"exercises-8.6.6","chapter":"8 Conditions","heading":"8.0.4 Exercises 8.6.6","text":"Q1. Create suppressConditions() works like suppressMessages() suppressWarnings() suppresses everything. Think carefully handle errors.Q2. Compare following two implementations message2error(). main advantage withCallingHandlers() scenario? (Hint: look carefully traceback.)Q3. modify catch_cnds() definition wanted recreate original intermingling warnings messages?Q4. catching interrupts dangerous? Run code find .","code":"\nmessage2error <- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\nmessage2error <- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\nbottles_of_beer <- function(i = 99) {\n  message(\n    \"There are \", i, \" bottles of beer on the wall, \",\n    i, \" bottles of beer.\"\n  )\n  while (i > 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i <<- i - 1\n        if (i > 0) {\n          message(\n            \"Take one down, pass it around, \", i,\n            \" bottle\", if (i > 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \",\n    \"no more bottles of beer.\"\n  )\n}"},{"path":"functionals.html","id":"functionals","chapter":"9 Functionals","heading":"9 Functionals","text":"","code":""},{"path":"functionals.html","id":"exercise-9.2.6","chapter":"9 Functionals","heading":"9.1 Exercise 9.2.6","text":"Q1. Use as_mapper() explore purrr generates anonymous functions integer, character, list helpers. helper allows extract attributes? Read documentation find .A1.Experiments purrr:can extract attributes using purrr::attr_getter():Q2. map(1:3, ~ runif(2)) useful pattern generating random numbers, map(1:3, runif(2)) . ? Can explain returns result ?A2.shown as_mapper() outputs , second call appropriate generating random numbers translates pluck() function indices plucking taken randomly generated numbers.Q3. Use appropriate map() function :A3.Compute standard deviation every column numeric data frame:Compute standard deviation every numeric column mixed data frame:Compute number levels every factor data frame:Q4. following code simulates performance t-test non-normal data. Extract p-value test, visualise.A4.Extract p-value test:Visualise extracted p-values:Q5. following code uses map nested inside another map apply function every element nested list. fail, need make work?A5. fixed version:Q6. Use map() fit linear models mtcars dataset using formulas stored list:A6. Fitting linear models mtcars dataset using provided formulas:Q7. Fit model mpg ~ disp bootstrap replicates mtcars list , extract \\(R^2\\) model fit (Hint: can compute \\(R^2\\) summary().)A7. can done using map_dbl():","code":"\nlibrary(purrr)\n\n# mapping by position -----------------------\n\nx <- list(1, list(2, 3, list(1, 2)))\n\nmap(x, 1)\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\nas_mapper(1)\n#> function (x, ...) \n#> pluck(x, 1, .default = NULL)\n#> <environment: 0x11a938f78>\n\nmap(x, list(2, 1))\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> [1] 3\nas_mapper(list(2, 1))\n#> function (x, ...) \n#> pluck(x, 2, 1, .default = NULL)\n#> <environment: 0x15a5e9840>\n\n# mapping by name -----------------------\n\ny <- list(\n  list(m = \"a\", list(1, m = \"mo\")),\n  list(n = \"b\", list(2, n = \"no\"))\n)\n\nmap(y, \"m\")\n#> [[1]]\n#> [1] \"a\"\n#> \n#> [[2]]\n#> NULL\nas_mapper(\"m\")\n#> function (x, ...) \n#> pluck(x, \"m\", .default = NULL)\n#> <environment: 0x12bbac718>\n\n# mixing position and name\nmap(y, list(2, \"m\"))\n#> [[1]]\n#> [1] \"mo\"\n#> \n#> [[2]]\n#> NULL\nas_mapper(list(2, \"m\"))\n#> function (x, ...) \n#> pluck(x, 2, \"m\", .default = NULL)\n#> <environment: 0x12bec9400>\n\n# compact functions ----------------------------\n\nmap(y, ~ length(.x))\n#> [[1]]\n#> [1] 2\n#> \n#> [[2]]\n#> [1] 2\nas_mapper(~ length(.x))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> length(.x)\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\npluck(Titanic, attr_getter(\"class\"))\n#> [1] \"table\"\nlibrary(purrr)\n\nmap(1:3, ~ runif(2))\n#> [[1]]\n#> [1] 0.2180892 0.9876342\n#> \n#> [[2]]\n#> [1] 0.3484619 0.3810470\n#> \n#> [[3]]\n#> [1] 0.02098596 0.74972687\nas_mapper(~ runif(2))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> runif(2)\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\n\nmap(1:3, runif(2))\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> NULL\n#> \n#> [[3]]\n#> NULL\nas_mapper(runif(2))\n#> function (x, ...) \n#> pluck(x, 0.597890264587477, 0.587997315218672, .default = NULL)\n#> <environment: 0x11d37e2e0>a) Compute the standard deviation of every column in a numeric data frame.\n\na) Compute the standard deviation of every numeric column in a mixed data frame. (Hint: you'll need to do it in two steps.)\n\na) Compute the number of levels for every factor in a data frame.\nmap_dbl(mtcars, sd)\n#>         mpg         cyl        disp          hp        drat \n#>   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787 \n#>          wt        qsec          vs          am        gear \n#>   0.9784574   1.7869432   0.5040161   0.4989909   0.7378041 \n#>        carb \n#>   1.6152000\nkeep(iris, is.numeric) %>%\n  map_dbl(sd)\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#>    0.8280661    0.4358663    1.7652982    0.7622377\nmodify_if(dplyr::starwars, is.character, as.factor) %>%\n  keep(is.factor) %>%\n  map_int(~ length(levels(.)))\n#>       name hair_color skin_color  eye_color        sex \n#>         87         12         31         15          4 \n#>     gender  homeworld    species \n#>          2         48         37\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\n\n(p <- map_dbl(trials, \"p.value\"))\n#>   [1] 0.81695628 0.53177360 0.94750819 0.41026769 0.34655294\n#>   [6] 0.05300287 0.56479901 0.85936864 0.77517391 0.64321161\n#>  [11] 0.84462914 0.54144946 0.63070476 0.20325827 0.39824435\n#>  [16] 0.67052432 0.39932663 0.44437632 0.51645941 0.96578745\n#>  [21] 0.70219557 0.69931716 0.23946786 0.55100566 0.76028958\n#>  [26] 0.38105366 0.64544126 0.15379307 0.86945196 0.09965658\n#>  [31] 0.96425489 0.54239108 0.38985789 0.59019282 0.96247907\n#>  [36] 0.54997487 0.66111391 0.30961551 0.10897334 0.55049635\n#>  [41] 0.93882405 0.14836866 0.44307287 0.61583610 0.37284284\n#>  [46] 0.38559622 0.42935767 0.26059293 0.07831619 0.93768396\n#>  [51] 0.48459268 0.73571291 0.30288560 0.68521609 0.06374636\n#>  [56] 0.11007808 0.98758443 0.17831882 0.94471538 0.19711729\n#>  [61] 0.02094185 0.12370745 0.23247837 0.93842382 0.19160550\n#>  [66] 0.49005550 0.98146240 0.09034183 0.94912080 0.55857523\n#>  [71] 0.24692070 0.63658206 0.14290966 0.10309770 0.89516449\n#>  [76] 0.25660092 0.16943034 0.41199780 0.82721280 0.74017418\n#>  [81] 0.43724631 0.55944024 0.93615100 0.68788872 0.01416627\n#>  [86] 0.60120497 0.54125910 0.91581929 0.78949327 0.57887371\n#>  [91] 0.83217542 0.90108906 0.97474727 0.99129282 0.54436155\n#>  [96] 0.74159859 0.06534957 0.10834529 0.19737786 0.93750342\nplot(p)\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error in .f(.x[[i]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, .f = ~ map(., ~ triple(.)))\n#> [[1]]\n#> [[1]][[1]]\n#> [1] 3\n#> \n#> [[1]][[2]]\n#> [1]  9 27\n#> \n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1]  9 18\n#> \n#> [[2]][[2]]\n#> [1] 21\n#> \n#> [[2]][[3]]\n#> [1] 12 21 18\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\n\nmap(formulas, ~ lm(formula = ., data = mtcars))\n#> [[1]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)         disp  \n#>    29.59985     -0.04122  \n#> \n#> \n#> [[2]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)    I(1/disp)  \n#>       10.75      1557.67  \n#> \n#> \n#> [[3]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)         disp           wt  \n#>    34.96055     -0.01772     -3.35083  \n#> \n#> \n#> [[4]]\n#> \n#> Call:\n#> lm(formula = ., data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)    I(1/disp)           wt  \n#>      19.024     1142.560       -1.798\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))\n\nmap_dbl(\n  bootstraps,\n  ~ summary(lm(formula = mpg ~ disp, data = .))$r.squared\n)\n#>  [1] 0.7864562 0.8110818 0.7956331 0.7632399 0.7967824\n#>  [6] 0.7364226 0.7203027 0.6653252 0.7732780 0.6753329"},{"path":"functionals.html","id":"exercise-9.4.6","chapter":"9 Functionals","heading":"9.2 Exercise 9.4.6","text":"Q1. Explain results modify(mtcars, 1).A1. modify() returns object type input. Since input data frame certain dimensions .f = 1 translates plucking first element column, returns data frames dimensions plucked element recycled across rows.Q2. Rewrite following code use iwalk() instead walk2(). advantages disadvantages?A2. Rewritten versions :walk2()iwalk()Q3. Explain following code transforms data frame using functions stored list.Compare contrast map2() approach map() approach:A3. map2() supplies functions defined .x = trans f anonymous functions, names columns defined .y = mtcars[nm] picked var anonymous function. Note function iterating indices vectors transformations column names.map() approach, function iterating indices vectors column names.Q4. write.csv() return, .e. happens use map2() instead walk2()?A4. use map2(), work, print NULLs terminal every list element.","code":"\nhead(modify(mtcars, 1))\n#>                   mpg cyl disp  hp drat   wt  qsec vs am\n#> Mazda RX4          21   6  160 110  3.9 2.62 16.46  0  1\n#> Mazda RX4 Wag      21   6  160 110  3.9 2.62 16.46  0  1\n#> Datsun 710         21   6  160 110  3.9 2.62 16.46  0  1\n#> Hornet 4 Drive     21   6  160 110  3.9 2.62 16.46  0  1\n#> Hornet Sportabout  21   6  160 110  3.9 2.62 16.46  0  1\n#> Valiant            21   6  160 110  3.9 2.62 16.46  0  1\n#>                   gear carb\n#> Mazda RX4            4    4\n#> Mazda RX4 Wag        4    4\n#> Datsun 710           4    4\n#> Hornet 4 Drive       4    4\n#> Hornet Sportabout    4    4\n#> Valiant              4    4\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(.x = cyls, .y = paths, .f = write.csv)\ncyls <- split(mtcars, mtcars$cyl)\nnames(cyls) <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\niwalk(cyls, ~ write.csv(.x, .y))\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))\nbods <- split(BOD, BOD$Time)\nnm <- names(bods)\nmap2(bods, nm, write.csv)"},{"path":"functionals.html","id":"exercise-9.6.3","chapter":"9 Functionals","heading":"9.3 Exercise 9.6.3","text":"Q1. isn’t .na() predicate function? base R function closest predicate version .na()?A1. mentioned docs:predicate function returns single TRUE FALSE..na() function return logical scalar, instead returns vector thus isn’t predicate function.closest equivalent predicate function base-R anyNA() function.Q2. simple_reduce() problem x length 0 length 1. Describe source problem might go fixing .A2. Supplied function:function struggles inputs length 0 1 function tries access --bound values.problem can solved adding init argument, supplies default initial value function operate :Let’s try :different kind function:another one:Q3. Implement span() function Haskell: given list x predicate function f, span(x, f) returns location longest sequential run elements predicate true. (Hint: might find rle() helpful.)Q4. Implement arg_max(). take function vector inputs, return elements input function returns highest value. example, arg_max(-10:5, function(x) x ^ 2) return -10. arg_max(-5:5, function(x) x ^ 2) return c(-5, 5). Also implement matching arg_min() function.Q5. function scales vector falls range [0, 1]. apply every column data frame? apply every numeric column data frame?","code":"\n# contrast the following behavior of predicate functions\nis.character(c(\"x\", 2))\n#> [1] TRUE\nis.null(c(3, NULL))\n#> [1] FALSE\n\n# with this behavior\nis.na(c(NA, 1))\n#> [1]  TRUE FALSE\nanyNA(c(NA, 1))\n#> [1] TRUE\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nsimple_reduce(numeric(), sum)\n#> Error in x[[1]]: subscript out of bounds\nsimple_reduce(1, sum)\n#> Error in x[[i]]: subscript out of bounds\nsimple_reduce(1:3, sum)\n#> [1] 6\nsimple_reduce2 <- function(x, f, init = 0) {\n  # initializer will become the first value\n  if (length(x) == 0L) {\n    return(init)\n  }\n\n  if (length(x) == 1L) {\n    return(x[[1L]])\n  }\n\n  out <- x[[1]]\n\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nsimple_reduce2(numeric(), sum)\n#> [1] 0\nsimple_reduce2(1, sum)\n#> [1] 1\nsimple_reduce2(1:3, sum)\n#> [1] 6\nsimple_reduce2(numeric(), `*`, init = 1)\n#> [1] 1\nsimple_reduce2(1, `*`, init = 1)\n#> [1] 1\nsimple_reduce2(1:3, `*`, init = 1)\n#> [1] 6\nsimple_reduce2(numeric(), `%/%`)\n#> [1] 0\nsimple_reduce2(1, `%/%`)\n#> [1] 1\nsimple_reduce2(1:3, `%/%`)\n#> [1] 0\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}"},{"path":"functionals.html","id":"exercise-9.7.3","chapter":"9 Functionals","heading":"9.4 Exercise 9.7.3","text":"Q1. apply() arrange output? Read documentation perform experiments.Q2. eapply() rapply() ? purrr equivalents?A2. mentioned documentation:eapply()eapply() applies FUN named values environment returns results list.example:purrr doesn’t function iterate environments.rapply()rapply() recursive version lapply flexibility result structured (= “..”).example:purrr something similar modify_depth().Q3. Challenge: read fixed point algorithm. Complete exercises using R.","code":"\nlibrary(rlang)\n\ne <- env(\"x\" = 1, \"y\" = 2)\nrlang::env_print(e)\n#> <environment: 0x10a8f07d0>\n#> Parent: <environment: global>\n#> Bindings:\n#> • x: <dbl>\n#> • y: <dbl>\n\neapply(e, as.character)\n#> $x\n#> [1] \"1\"\n#> \n#> $y\n#> [1] \"2\"\nX <- list(list(a = TRUE, b = list(c = c(4L, 3.2))), d = 9.0)\n\nrapply(X, as.character, classes = \"numeric\", how = \"replace\")\n#> [[1]]\n#> [[1]]$a\n#> [1] TRUE\n#> \n#> [[1]]$b\n#> [[1]]$b$c\n#> [1] \"4\"   \"3.2\"\n#> \n#> \n#> \n#> $d\n#> [1] \"9\"\nX <- list(list(a = TRUE, b = list(c = c(4L, 3.2))), d = 9.0)\n\npurrr::modify_depth(X, .depth = 2L, .f = length)\n#> [[1]]\n#> [[1]]$a\n#> [1] 1\n#> \n#> [[1]]$b\n#> [1] 1\n#> \n#> \n#> $d\n#> [1] 1"},{"path":"function-factories.html","id":"function-factories","chapter":"10 Function factories","heading":"10 Function factories","text":"","code":""},{"path":"function-factories.html","id":"exercises-10.2.6","chapter":"10 Function factories","heading":"10.0.1 Exercises 10.2.6","text":"Q1. definition force() simple:better force(x) instead just x?A1. lazy evaluation, argument function won’t evaluated value needed, sometimes may want eager evaluation.Using force() makes intent clearer.Q2. Base R contains two function factories, approxfun() ecdf(). Read documentation experiment figure functions return.Q3. Create function pick() takes index, , argument returns function argument x subsets x .Q4. Create function creates functions compute ithcentral moment numeric vector. can test running following code:Q5. happens don’t use closure? Make predictions, verify code .Q6. happens use <- instead <<-? Make predictions, verify code .","code":"\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x128144470>\n#> <environment: namespace:base>\npick(1)(x)\n# should be equivalent to\nx[[1]]\n\nlapply(mtcars, pick(5))\n# should be equivalent to\nlapply(mtcars, function(x) x[[5]])\nm1 <- moment(1)\nm2 <- moment(2)\nx <- runif(100)\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\ni <- 0\nnew_counter2 <- function() {\n  i <<- i + 1\n  i\n}\nnew_counter3 <- function() {\n  i <- 0\n  function() {\n    i <- i + 1\n    i\n  }\n}"},{"path":"function-factories.html","id":"exercises-10.3.4","chapter":"10 Function factories","heading":"10.0.2 Exercises 10.3.4","text":"Q1. Compare contrast ggplot2::label_bquote() scales::number_format().","code":""},{"path":"function-factories.html","id":"exercises-10.4.4","chapter":"10 Function factories","heading":"10.0.3 Exercises 10.4.4","text":"Q1. boot_model(), don’t need force evaluation df model?Q2. might formulate Box-Cox transformation like ?Q3. don’t need worry boot_permute() stores copy data inside function generates?Q4. much time ll_poisson2() save compared ll_poisson1()? Use bench::mark() see much faster optimisation occurs. changing length x change results?","code":"\nboxcox3 <- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x^lambda - 1) / lambda\n    }\n  }\n}"},{"path":"function-factories.html","id":"exercises-10.5.1","chapter":"10 Function factories","heading":"10.0.4 Exercises 10.5.1","text":"Q1. following commands equivalent (x, f(z))?Q2. Compare contrast effects env_bind() vs. attach() \nfollowing code.","code":"(a) `x$f(x$z)`.\n(b) `f(x$z)`.\n(c) `x$f(z)`.\n(d) `f(z)`.\n(e) It depends.\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> The following objects are masked from package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\")\nenv_unbind(globalenv(), names(funs))"},{"path":"function-operators.html","id":"function-operators","chapter":"11 Function operators","heading":"11 Function operators","text":"","code":""},{"path":"function-operators.html","id":"exercises-11.2.3","chapter":"11 Function operators","heading":"11.0.1 Exercises 11.2.3","text":"Q1. Base R provides function operator form Vectorize(). ? might use ?Q2. Read source code possibly(). work?Q3. Read source code safely(). work?","code":""},{"path":"function-operators.html","id":"exercises-11.3.1","chapter":"11 Function operators","heading":"11.0.2 Exercises 11.3.1","text":"Q1. Weigh pros cons download.file %>% dot_every(10) %>% delay_by(0.1) versus download.file %>% delay_by(0.1) %>% dot_every(10).Q2. memoise file.download()? ?Q3. Create function operator reports whenever file created deleted working directory, using dir() setdiff(). global function effects might want track?Q4. Write function operator logs timestamp message file every time function run.Q5. Modify delay_by() instead delaying fixed amount time, ensures certain amount time elapsed since function last called. , called g <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn’t extra delay.","code":""},{"path":"base-types.html","id":"base-types","chapter":"12 Base Types","heading":"12 Base Types","text":"exercises.","code":""},{"path":"s3.html","id":"s3","chapter":"13 S3","heading":"13 S3","text":"","code":""},{"path":"s3.html","id":"exercise-13.2.1","chapter":"13 S3","heading":"13.1 Exercise 13.2.1","text":"Q1. Describe difference t.test() t.data.frame(). function called?A1.t.test() generic function perform t-test.t.test() generic function perform t-test.t.data.frame method generic t() (matrix transform function) dispatched data.frame class objects/instances need transformed.t.data.frame method generic t() (matrix transform function) dispatched data.frame class objects/instances need transformed.Q2. Make list commonly used base R functions contain . name S3 methods.A2. common R functions . S3 methods:.equal().* functions (like .data.frame(), .numeric(), etc.)install.packages().exit()\netc.full list, :example,Q3. .data.frame.data.frame() method ? confusing? avoid confusion code?A3. ’s S3 method generic .data.frame().can seen methods supported generic:Q4. Describe difference behaviour two calls.A4.unclassing, mean generic dispatches .Date method:unclassing, mean generic dispatches .numeric method:Q5. class object following code return? base type built ? attributes use?A5. object based base type closure7, type function.class ecdf, superclasses.Apart class, following attributes:Q6. class object following code return? base type built ? attributes use?A6. object based base type integer.class table.Apart class, following attributes:","code":"\nlibrary(sloop)\n\n# function type\nftype(t.test)\n#> [1] \"S3\"      \"generic\"\nftype(t.data.frame)\n#> [1] \"S3\"     \"method\"\nbase_functions <- getNamespaceExports(\"base\")\n\nbase_functions[grepl(\"(\\\\w+)(\\\\.)(\\\\w+)\", base_functions)]\nftype(as.data.frame)\n#> [1] \"S3\"      \"generic\"\nftype(on.exit)\n#> [1] \"primitive\"\nftype(as.data.frame.data.frame)\n#> [1] \"S3\"     \"method\"\ns3_methods_generic(\"as.data.frame\") %>%\n  dplyr::filter(class == \"data.frame\")\n#> # A tibble: 1 × 4\n#>   generic       class      visible source\n#>   <chr>         <chr>      <lgl>   <chr> \n#> 1 as.data.frame data.frame TRUE    base\nset.seed(1014)\nsome_days <- as.Date(\"2017-01-31\") + sample(10, 5)\nmean(some_days)\n#> [1] \"2017-02-06\"\nmean(unclass(some_days))\n#> [1] 17203.4\nsome_days <- as.Date(\"2017-01-31\") + sample(10, 5)\n\nsome_days\n#> [1] \"2017-02-06\" \"2017-02-09\" \"2017-02-05\" \"2017-02-08\"\n#> [5] \"2017-02-07\"\n\ns3_dispatch(mean(some_days))\n#> => mean.Date\n#>  * mean.default\n\nmean(some_days)\n#> [1] \"2017-02-07\"\nunclass(some_days)\n#> [1] 17203 17206 17202 17205 17204\n\nmean(unclass(some_days))\n#> [1] 17204\n\ns3_dispatch(mean(unclass(some_days)))\n#>    mean.double\n#>    mean.numeric\n#> => mean.default\nx <- ecdf(rpois(100, 10))\nx\nx <- ecdf(rpois(100, 10))\nx\n#> Empirical CDF \n#> Call: ecdf(rpois(100, 10))\n#>  x[1:18] =      2,      3,      4,  ...,     18,     19\n\notype(x)\n#> [1] \"S3\"\ntypeof(x)\n#> [1] \"closure\"\ns3_class(x)\n#> [1] \"ecdf\"     \"stepfun\"  \"function\"\nattributes(x)\n#> $class\n#> [1] \"ecdf\"     \"stepfun\"  \"function\"\n#> \n#> $call\n#> ecdf(rpois(100, 10))\nx <- table(rpois(100, 5))\nx\nx <- table(rpois(100, 5))\nx\n#> \n#>  1  2  3  4  5  6  7  8  9 10 \n#>  7  7 18 13 14 14 16  4  4  3\n\notype(x)\n#> [1] \"S3\"\ntypeof(x)\n#> [1] \"integer\"\ns3_class(x)\n#> [1] \"table\"\nattributes(x)\n#> $dim\n#> [1] 10\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n#> \n#> \n#> $class\n#> [1] \"table\""},{"path":"s3.html","id":"exercise-13.3.4","chapter":"13 S3","heading":"13.2 Exercise 13.3.4","text":"Q1. Write constructor data.frame objects. base type data frame built ? attributes use? restrictions placed individual elements? names?A1.Q2. Enhance factor() helper better behaviour one values found levels. base::factor() situation?Q3. Carefully read source code factor(). constructor ?Q4. Factors optional “contrasts” attribute. Read help C(), briefly describe purpose attribute. type ? Rewrite new_factor() constructor include attribute.Q5. Read documentation utils::.roman(). write constructor class? need validator? might helper ?","code":"\nmy_data_frame <- function(...,\n                          row.names = NULL,\n                          check.rows = FALSE,\n                          check.names = TRUE,\n                          fix.empty.names = TRUE,\n                          stringsAsFactors = FALSE) {\n  structure(\n    df,\n    class = \"data.frame\"\n  )\n}"},{"path":"r6.html","id":"r6","chapter":"14 R6","heading":"14 R6","text":"","code":""},{"path":"r6.html","id":"exercise-14.2.6","chapter":"14 R6","heading":"14.1 Exercise 14.2.6","text":"Q1. Create bank account R6 class stores balance allows deposit withdraw money. Create subclass throws error attempt go overdraft. Create another subclass allows go overdraft, charges fee. Create superclass make sure works expected.A1.Create subclass errors attempt overdrawCreate subclass charges fee overdrawQ2. Create R6 class represents shuffled deck cards. able draw cards deck $draw(n), return cards deck reshuffle $reshuffle(). Use following code make vector cards.A2.Q3. can’t model bank account deck cards S3 class?Q4. Create R6 class allows get set current time zone. can access current time zone Sys.timezone() set Sys.setenv(TZ = \"newtimezone\"). setting time zone, make sure new time zone list provided OlsonNames().Q5. Create R6 class manages current working directory. $get() $set() methods.Q6. can’t model time zone current working directory S3 class?Q7. base type R6 objects built top ? attributes ?","code":"\nlibrary(R6)\n\n# define the needed class\nbankAccount <- R6::R6Class(\n  \"bankAccount\",\n  public = list(\n    # fields -----------------------\n    balance = NA,\n    name = NA,\n\n    # methods ----------------------\n    initialize = function(name = NULL, balance) {\n      self$validate(balance)\n\n      self$name <- name\n      self$balance <- balance\n    },\n    deposit = function(amount) {\n      self$validate(amount)\n      cat(\"Current balance is: \", self$balance, \"\\n\", sep = \"\")\n      cat(\"And you are depositing: \", amount)\n      self$balance <- self$balance + amount\n      invisible(self)\n    },\n    withdraw = function(amount) {\n      self$validate(amount)\n      cat(\"Current balance is: \", self$balance, \"\\n\", sep = \"\")\n      cat(\"And you are withdrawing: \", amount, \"\\n\", sep = \"\")\n      self$balance <- self$balance - amount\n      invisible(self)\n    },\n    validate = function(amount) {\n      stopifnot(is.numeric(amount), amount >= 0)\n    },\n    print = function() {\n      cat(\"Dear \", self$name, \", your balance is: \", self$balance, sep = \"\")\n      invisible(self)\n    }\n  )\n)\n\n# create an instance of an object\nindra <- bankAccount$new(name = \"Indra\", balance = 100)\n\nindra\n#> Dear Indra, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nindra$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nindra\n#> Dear Indra, your balance is: 120\n\nindra$withdraw(10)\n#> Current balance is: 120\n#> And you are withdrawing: 10\n\nindra\n#> Dear Indra, your balance is: 110\n\n# make sure input validation checks work\nindra$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nindra$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nindra$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nAnne <- bankAccount$new(name = \"Anne\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE\nbankAccountStrict <- R6::R6Class(\n  \"bankAccountStrict\",\n  inherit = bankAccount,\n  public = list(\n    withdraw = function(amount) {\n      # use method from superclass\n      super$withdraw(amount)\n\n      if (self$balance < 0) {\n        invisible(self)\n        stop(\n          cat(\"\\nYou are trying to withdraw more that your balance.\\n\"),\n          cat(\"I'm sorry, \", self$name, \", I'm afraid I can't do that.\", sep = \"\"),\n          call. = FALSE\n        )\n      }\n    }\n  )\n)\n\n# create an instance of an object\nPritesh <- bankAccountStrict$new(name = \"Pritesh\", balance = 100)\n\nPritesh\n#> Dear Pritesh, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nPritesh$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nPritesh\n#> Dear Pritesh, your balance is: 120\n\nPritesh$withdraw(150)\n#> Current balance is: 120\n#> And you are withdrawing: 150\n#> \n#> You are trying to withdraw more that your balance.\n#> I'm sorry, Pritesh, I'm afraid I can't do that.\n#> Error:\n\nPritesh\n#> Dear Pritesh, your balance is: -30\n\n# make sure input validation checks work\nPritesh$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nPritesh$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nPritesh$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nPritesh <- bankAccountStrict$new(name = \"Pritesh\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE\nbankAccountFee <- R6::R6Class(\n  \"bankAccountFee\",\n  inherit = bankAccount,\n  public = list(\n    withdraw = function(amount) {\n      # use method from superclass\n      super$withdraw(amount)\n\n      if (self$balance < 0) {\n        cat(\"\\nI am charging you 10 euros for overdrawing.\\n\")\n        self$balance <- self$balance - 10\n        invisible(self)\n      }\n    }\n  )\n)\n\n# create an instance of an object\nMangesh <- bankAccountFee$new(name = \"Mangesh\", balance = 100)\n\nMangesh\n#> Dear Mangesh, your balance is: 100\n\n# do deposits and withdrawals to see if the balance changes\nMangesh$deposit(20)\n#> Current balance is: 100\n#> And you are depositing:  20\n\nMangesh\n#> Dear Mangesh, your balance is: 120\n\nMangesh$withdraw(150)\n#> Current balance is: 120\n#> And you are withdrawing: 150\n#> \n#> I am charging you 10 euros for overdrawing.\n\nMangesh\n#> Dear Mangesh, your balance is: -40\n\n# make sure input validation checks work\nMangesh$deposit(-20)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nMangesh$deposit(\"pizza\")\n#> Error in self$validate(amount): is.numeric(amount) is not TRUE\nMangesh$withdraw(-54)\n#> Error in self$validate(amount): amount >= 0 is not TRUE\nMangesh <- bankAccountFee$new(name = \"Mangesh\", balance = -45)\n#> Error in self$validate(balance): amount >= 0 is not TRUE\nsuit <- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue <- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste0(rep(value, 4), suit)\nsuit <- c(\"SPADE\", \"HEARTS\", \"DIAMOND\", \"CLUB\") # sigh, Windows encoding issues\nvalue <- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste(rep(value, 4), suit)\n\ndeck <- R6::R6Class(\n  \"deck\",\n  public = list(\n    # fields -----------------------\n\n    # methods -----------------------\n    draw = function(n) {\n      sample(self$cards, n)\n    },\n    reshuffle = function() {\n      sample(self$cards)\n      invisible(self)\n    },\n    print = function() {\n      \"Drawn cards are:\"\n      \"Number of remaining cards:\"\n    }\n  )\n)\n\n# create a new instance of this object\nmydeck <- deck$new()\n\n# draw cards\nmydeck$draw(4)\n\n# reshuffle"},{"path":"r6.html","id":"exercise-14.3.3","chapter":"14 R6","heading":"14.2 Exercise 14.3.3","text":"Q1. Create bank account class prevents directly setting account balance, can still withdraw deposit . Throw error attempt go overdraft.Q2. Create class write-$password field. $check_password(password) method returns TRUE FALSE, way view complete password.A2., course, everything possible:Q3. Extend Rando class another active binding allows access previous random value. Ensure active binding way access value.Q4. Can subclasses access private fields/methods parent? Perform experiment find .A4. Unlike classical OOP languages (e.g. C++), R6 subclasses also access private methods superclass (base class).instance, following example, Duck class private method $quack(), subclass Mallard can access using super$quack().","code":"\nlibrary(R6)\n\ncheckCredentials <- R6Class(\n  \"checkCredentials\",\n  public = list(\n    # setter\n    set_password = function(password) {\n      private$.password <- password\n    },\n\n    # checker\n    check_password = function(password) {\n      if (is.null(private$.password)) {\n        stop(\"No password set to check against.\")\n      }\n\n      identical(password, private$.password)\n    },\n\n    # the default print method prints the private fields as well\n    print = function() {\n      \"Password: XXXX\"\n\n      # for method chaining\n      invisible(self)\n    }\n  ),\n  private = list(\n    .password = NULL\n  )\n)\n\nmyCheck <- checkCredentials$new()\nmyCheck\n\nmyCheck$set_password(\"1234\")\n\nmyCheck$check_password(\"abcd\")\n#> [1] FALSE\nmyCheck$check_password(\"1234\")\n#> [1] TRUE\nmyCheck$.__enclos_env__$private$.password\n#> [1] \"1234\"\nDuck <- R6Class(\"Duck\",\n  private = list(quack = function() print(\"Quack Quack\"))\n)\n\nMallard <- R6Class(\"Mallard\",\n  inherit = Duck,\n  public = list(quack = function() super$quack())\n)\n\nmyMallard <- Mallard$new()\nmyMallard$quack()\n#> [1] \"Quack Quack\""},{"path":"r6.html","id":"exercise-14.4.4","chapter":"14 R6","heading":"14.3 Exercise 14.4.4","text":"Q1. Create class allows write line specified file. open connection file $initialize(), append line using cat() $append_line(), close connection $finalize().Let’s check works expected:","code":"\nlibrary(R6)\n\nfileEditor <- R6Class(\n  \"fileEditor\",\n  public = list(\n    initialize = function(filePath) {\n      private$.connection <- file(filePath, open = \"wt\")\n    },\n    append_line = function(text) {\n      cat(\n        text,\n        file = private$.connection,\n        sep = \"\\n\",\n        append = TRUE\n      )\n    }\n  ),\n  private = list(\n    .connection = NULL,\n    # according to R6 docs, the destructor method should be private\n    finalize = function() {\n      print(\"Closing the file connection!\")\n      close(private$.connection)\n    }\n  )\n)\ngreetMom <- function() {\n  f <- tempfile()\n  myfileEditor <- fileEditor$new(f)\n\n  readLines(f)\n\n  myfileEditor$append_line(\"Hi mom!\")\n  myfileEditor$append_line(\"It's a beautiful day!\")\n\n  readLines(f)\n}\n\ngreetMom()\n#> [1] \"Hi mom!\"               \"It's a beautiful day!\"\n\n# force garbage collection\ngc()\n#> [1] \"Closing the file connection!\"\n#>           used (Mb) gc trigger  (Mb) limit (Mb) max used\n#> Ncells 1144865 61.2    2389604 127.7         NA  1873928\n#> Vcells 1989834 15.2    8388608  64.0      16384  2941031\n#>         (Mb)\n#> Ncells 100.1\n#> Vcells  22.5"},{"path":"s4.html","id":"s4","chapter":"15 S4","heading":"15 S4","text":"","code":""},{"path":"s4.html","id":"exercises-15.2.1","chapter":"15 S4","heading":"15.0.1 Exercises 15.2.1","text":"Q1. lubridate::period() returns S4 class. slots ? class slot? accessors provide?Q2. ways can find help method? Read ?\"?\" summarise details.","code":""},{"path":"s4.html","id":"exercises-15.3.6","chapter":"15 S4","heading":"15.0.2 Exercises 15.3.6","text":"Q1. Extend Person class fields match utils::person(). Think slots need, class slot , ’ll need check validity method.Q2. happens define new S4 class doesn’t slots? (Hint: read virtual classes ?setClass.)Q3. Imagine going reimplement factors, dates, data frames S4. Sketch setClass() calls use define classes. Think appropriate slots prototype.","code":""},{"path":"s4.html","id":"exercises-15.4.5","chapter":"15 S4","heading":"15.0.3 Exercises 15.4.5","text":"Q1. Add age() accessors Person class.Q2. definition generic, necessary repeat name generic twice?Q3. show() method defined Section Show method use (object)[[1]]? (Hint: try printing employee subclass.)Q4. happens define method different argument names generic?","code":""},{"path":"s4.html","id":"exercises-15.5.5","chapter":"15 S4","heading":"15.0.4 Exercises 15.5.5","text":"Q1. Draw method graph f(😅, 😽).Q2. Draw method graph f(😃, 😉, 😙).Q3. Take last example shows multiple dispatch two classes use multiple inheritance. happens define method terminal classes? method dispatch save us much work ?","code":""},{"path":"s4.html","id":"exercises-15.6.3","chapter":"15 S4","heading":"15.0.5 Exercises 15.6.3","text":"Q1. full setOldClass() definition look like ordered factor (.e. add slots prototype definition )?Q2. Define length method Person class.","code":""},{"path":"trade-offs.html","id":"trade-offs","chapter":"16 Trade-offs","heading":"16 Trade-offs","text":"exercises.","code":""},{"path":"big-picture.html","id":"big-picture","chapter":"17 Big Picture","heading":"17 Big Picture","text":"exercises.","code":""},{"path":"expressions.html","id":"expressions","chapter":"18 Expressions","heading":"18 Expressions","text":"","code":""},{"path":"expressions.html","id":"exercises-18.2.4","chapter":"18 Expressions","heading":"18.0.1 Exercises 18.2.4","text":"Q1. Reconstruct code represented trees :Q2. Draw following trees hand check answers lobstr::ast().Q3. ’s happening ASTs ? (Hint: carefully read ?\"^\".)Q4. special AST ?Q5. call tree statement multiple else conditions look like? ?","code":"#> █─f \n#> └─█─g \n#>   └─█─h\n#> █─`+` \n#> ├─█─`+` \n#> │ ├─1 \n#> │ └─2 \n#> └─3\n#> █─`*` \n#> ├─█─`(` \n#> │ └─█─`+` \n#> │   ├─x \n#> │   └─y \n#> └─z\nf(g(h(i(1, 2, 3))))\nf(1, g(2, h(3, i())))\nf(g(1, 2), h(3, i(4, 5)))\nlobstr::ast(`x` + `y`)\n#> █─`+` \n#> ├─x \n#> └─y\nlobstr::ast(x**y)\n#> █─`^` \n#> ├─x \n#> └─y\nlobstr::ast(1 -> x)\n#> █─`<-` \n#> ├─x \n#> └─1\nlobstr::ast(function(x = 1, y = 2) {})\n#> █─`function` \n#> ├─█─x = 1 \n#> │ └─y = 2 \n#> ├─█─`{` \n#> └─<inline srcref>"},{"path":"expressions.html","id":"exercises-18.3.5","chapter":"18 Expressions","heading":"18.0.2 Exercises 18.3.5","text":"Q1. two six types atomic vector can’t appear expression? ? Similarly, can’t create expression contains atomic vector length greater one?Q2. happens subset call object remove first element? e.g. expr(read.csv(\"foo.csv\", header = TRUE))[-1]. ?Q3. Describe differences following call objects.Q4. rlang::call_standardise() doesn’t work well following calls. ? makes mean() special?Q5. code make sense?Q6. Construct expression (x > 1) \"\" else \"b\" using multiple calls call2(). code structure reflect structure AST?","code":"\nx <- 1:10\ncall2(median, x, na.rm = TRUE)\ncall2(expr(median), x, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\ncall2(expr(median), expr(x), na.rm = TRUE)\ncall_standardise(quote(mean(1:10, na.rm = TRUE)))\n#> mean(x = 1:10, na.rm = TRUE)\ncall_standardise(quote(mean(n = T, 1:10)))\n#> mean(x = 1:10, n = T)\ncall_standardise(quote(mean(x = 1:10, , TRUE)))\n#> mean(x = 1:10, , TRUE)\nx <- expr(foo(x = 1))\nnames(x) <- c(\"x\", \"y\")"},{"path":"expressions.html","id":"exercises-18.4.4","chapter":"18 Expressions","heading":"18.0.3 Exercises 18.4.4","text":"Q1. R uses parentheses two slightly different ways illustrated two calls:Compare contrast two uses referencing AST.Q2. = can also used two ways. Construct simple example shows uses.Q3. -2^2 yield 4 -4? ?Q4. !1 + !1 return? ?Q5. x1 <- x2 <- x3 <- 0 work? Describe two reasons.Q6. Compare ASTs x + y %+% z x ^ y %+% z. learned precedence custom infix functions?Q7. happens call parse_expr() string generates multiple expressions? e.g. parse_expr(\"x + 1; y + 1\")Q8. happens attempt parse invalid expression? e.g. \"+\" \"f())\".Q9. deparse() produces vectors input long. example, following call produces vector length two:expr_text() instead?Q10. pairwise.t.test() assumes deparse() always returns length one character vector. Can construct input violates expectation? happens?","code":"\nf((1))\n`(`(1 + 1)\nexpr <- expr(g(a + b + c + d + e + f + g + h + i + j + k + l +\n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\ndeparse(expr)"},{"path":"expressions.html","id":"exercises-18.5.3","chapter":"18 Expressions","heading":"18.0.4 Exercises 18.5.3","text":"Q1. logical_abbr() returns TRUE T(1, 2, 3). modify logical_abbr_rec() ignores function calls use T F?Q2. logical_abbr() works expressions. currently fails give function. ? modify logical_abbr() make work? components function need recurse ?Q3. Modify find_assign also detect assignment using replacement functions, .e. names(x) <- y.Q4. Write function extracts calls specified function.","code":"\nlogical_abbr(function(x = TRUE) {\n  g(x + T)\n})"},{"path":"quotation.html","id":"quotation","chapter":"19 Quotation","heading":"19 Quotation","text":"","code":""},{"path":"quotation.html","id":"exercises-4","chapter":"19 Quotation","heading":"19.0.1 Exercises","text":"Q1. function following base R code, identify arguments quoted evaluated.Q2. function following tidyverse code, identify arguments quoted evaluated.","code":"\nlibrary(MASS)\n#> \n#> Attaching package: 'MASS'\n#> The following object is masked from 'package:dplyr':\n#> \n#>     select\n\nmtcars2 <- subset(mtcars, cyl == 4)\n\nwith(mtcars2, sum(vs))\nsum(mtcars2$am)\n\nrm(mtcars2)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_cyl <- mtcars %>%\n  group_by(cyl) %>%\n  summarise(mean = mean(mpg))\n\nggplot(by_cyl, aes(cyl, mean)) +\n  geom_point()"},{"path":"quotation.html","id":"exercises-5","chapter":"19 Quotation","heading":"19.0.2 Exercises","text":"Q1. expr() implemented? Look source code.Q2. Compare contrast following two functions. Can predict output running ?Q3. happens try use enexpr() expression (.e. enexpr(x + y)? happens enexpr() passed missing argument?Q4. exprs() exprs(= ) different? Think input output.Q5. differences exprs() alist()? Read documentation named arguments exprs() find .Q6. documentation substitute() says:Create examples illustrate cases.","code":"\nf1 <- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 <- function(x, y) {\n  enexprs(x = x, y = y)\n}\nf1(a + b, c + d)\nf2(a + b, c + d)> Substitution takes place by examining each component of the parse tree \n> as follows: \n> \n> * If it is not a bound symbol in `env`, it is unchanged. \n> * If it is a promise object (i.e., a formal argument to a function) \n>   the expression slot of the promise replaces the symbol. \n> * If it is an ordinary variable, its value is substituted, unless \n> `env` is .GlobalEnv in which case the symbol is left unchanged."},{"path":"quotation.html","id":"exercises-6","chapter":"19 Quotation","heading":"19.0.3 Exercises","text":"Q1. Given following components:Use quasiquotation construct following calls:Q2. following two calls print , actually different:’s difference? one natural?","code":"\nxy <- expr(x + y)\nxz <- expr(x + z)\nyz <- expr(y + z)\nabc <- exprs(a, b, c)\n(x + y) / (y + z)\n-(x + z)^(y + z)\n(x + y) + (y + z) - (x + y)\natan2(x + y, y + z)\nsum(x + y, x + y, y + z)\nsum(a, b, c)\nmean(c(a, b, c), na.rm = TRUE)\nfoo(a = x + y, b = y + z)\n(a <- expr(mean(1:10)))\n#> mean(1:10)\n(b <- expr(mean(!!(1:10))))\n#> mean(1:10)\nidentical(a, b)\n#> [1] FALSE"},{"path":"quotation.html","id":"exercises-7","chapter":"19 Quotation","heading":"19.0.4 Exercises","text":"Q1. One way implement exec() shown . Describe works. key ideas?Q2. Carefully read source code interaction(), expand.grid(), par(). Compare contrast techniques use switching dots list behaviour.Q3. Explain problem definition set_attr()","code":"\nexec <- function(f, ..., .env = caller_env()) {\n  args <- list2(...)\n  do.call(f, args, envir = .env)\n}\nset_attr <- function(x, ...) {\n  attr <- rlang::list2(...)\n  attributes(x) <- attr\n  x\n}\nset_attr(1:10, x = 10)\n#> Error in attributes(x) <- attr: attributes must be named"},{"path":"quotation.html","id":"exercises-8","chapter":"19 Quotation","heading":"19.0.5 Exercises","text":"Q1. linear-model example, replace expr() reduce(summands, ~ expr(!!.x + !!.y)) call2(): reduce(summands, call2, \"+\"). Compare contrast two approaches. think easier read?Q2. Re-implement Box-Cox transform defined using unquoting new_function():Q3. Re-implement simple compose() defined using quasiquotation new_function():","code":"\nbc <- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x^lambda - 1) / lambda\n  }\n}\ncompose <- function(f, g) {\n  function(...) f(g(...))\n}"},{"path":"debugging.html","id":"debugging","chapter":"20 Debugging","heading":"20 Debugging","text":"exercises.","code":""},{"path":"measuring-performance.html","id":"measuring-performance","chapter":"21 Measuring performance","heading":"21 Measuring performance","text":"","code":""},{"path":"measuring-performance.html","id":"exercise-23.2.4","chapter":"21 Measuring performance","heading":"21.1 Exercise 23.2.4","text":"Q1. Profile following function torture = TRUE. surprising? Read source code rm() figure ’s going .A1.Let’s first source functions mentioned exercises.First, try without torture = TRUE: returns meaningful results.Maybe function runs fast?mentioned docs, setting torture = TRUETriggers garbage collection every torture memory allocation call.process somehow never seems finish crashes RStudio session stops!question says documentation rm() may provide clues:still couldn’t figure . recommend checking official answer.","code":"\nf <- function(n = 1e5) {\n  x <- rep(1, n)\n  rm(x)\n}\nlibrary(profvis)\n\nsource(\"profiling-exercises.R\")\nprofvis(f())\n#> Error in parse_rprof(prof_output, expr_source): No parsing data available. Maybe your function was too fast?\nbench::mark(f(), check = FALSE, iterations = 1000)\n#> # A tibble: 1 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 f()          99.5µs    138µs     6906.     792KB     105.\nprofvis(f(), torture = TRUE)\nrm\n#> function (..., list = character(), pos = -1, envir = as.environment(pos), \n#>     inherits = FALSE) \n#> {\n#>     dots <- match.call(expand.dots = FALSE)$...\n#>     if (length(dots) && !all(vapply(dots, function(x) is.symbol(x) || \n#>         is.character(x), NA, USE.NAMES = FALSE))) \n#>         stop(\"... must contain names or character strings\")\n#>     names <- vapply(dots, as.character, \"\")\n#>     if (length(names) == 0L) \n#>         names <- character()\n#>     list <- .Primitive(\"c\")(list, names)\n#>     .Internal(remove(list, envir, inherits))\n#> }\n#> <bytecode: 0x140c2e570>\n#> <environment: namespace:base>"},{"path":"measuring-performance.html","id":"exercise-23.3.3","chapter":"21 Measuring performance","heading":"21.2 Exercise 23.3.3","text":"Q1. Instead using bench::mark(), use built-function system.time(). system.time() much less precise, ’ll need repeat operation many times loop, divide find average time operation, code .estimates system.time() compare bench::mark()? different?A1.Compare results alternatives:comparison reveals two approaches yield quite similar results.Q2. two ways compute square root vector. think fastest? slowest? Use microbenchmarking test answers.A2.Microbenchmarking ways compute square root vector mentioned chapter.specialized primitive function sqrt() (written C) fastest way compute square root.","code":"\nn <- 1e6\nsystem.time(for (i in 1:n) sqrt(x)) / n\nsystem.time(for (i in 1:n) x^0.5) / n\nlibrary(dplyr)\n\nn <- 1e6\nx <- runif(100)\n\n# bench -------------------\n\nbench_df <- bench::mark(\n  sqrt(x),\n  x^0.5,\n  iterations = n\n)\n\nt_bench_df <- bench_df %>%\n  dplyr::select(expression, time) %>%\n  dplyr::rowwise() %>%\n  dplyr::mutate(mean = mean(unlist(time))) %>%\n  dplyr::ungroup() %>%\n  dplyr::select(-time)\n\n# system.time -------------------\n\n# garbage collection performed immediately before the timing\nt1_systime_gc <- system.time(for (i in 1:n) sqrt(x), gcFirst = TRUE) / n\nt2_systime_gc <- system.time(for (i in 1:n) x^0.5, gcFirst = TRUE) / n\n\n# garbage collection not performed immediately before the timing\nt1_systime_nogc <- system.time(for (i in 1:n) sqrt(x), gcFirst = FALSE) / n\nt2_systime_nogc <- system.time(for (i in 1:n) x^0.5, gcFirst = FALSE) / n\n\nt_systime_df <- tibble(\n  \"expression\" = bench_df$expression,\n  \"systime_with_gc_us\" = c(t1_systime_gc[\"elapsed\"], t2_systime_gc[\"elapsed\"]),\n  \"systime_with_nogc_us\" = c(t1_systime_nogc[\"elapsed\"], t2_systime_nogc[\"elapsed\"])\n) %>%\n  dplyr::mutate(\n    systime_with_gc_us = systime_with_gc_us * 1e6,\n    systime_with_nogc_us = systime_with_nogc_us * 1e6\n  )\nt_bench_df\n#> # A tibble: 2 × 2\n#>   expression     mean\n#>   <bch:expr> <bch:tm>\n#> 1 sqrt(x)    414.47ns\n#> 2 x^0.5        1.32µs\n\nt_systime_df\n#> # A tibble: 2 × 3\n#>   expression systime_with_gc_us systime_with_nogc_us\n#>   <bch:expr>              <dbl>                <dbl>\n#> 1 sqrt(x)                 0.403                0.409\n#> 2 x^0.5                   1.23                 1.28\nx^(1 / 2)\nexp(log(x) / 2)\nx <- runif(1000)\n\nbench::mark(\n  sqrt(x),\n  x^0.5,\n  x^(1 / 2),\n  exp(log(x) / 2),\n  iterations = 1000\n) %>%\n  dplyr::arrange(median)\n#> # A tibble: 4 × 6\n#>   expression         min   median `itr/sec` mem_alloc\n#>   <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 sqrt(x)         1.02µs   1.52µs   561463.    7.86KB\n#> 2 exp(log(x)/2)   6.11µs   7.09µs   139583.    7.86KB\n#> 3 x^0.5           9.14µs  10.13µs    99173.    7.86KB\n#> 4 x^(1/2)         9.22µs  10.17µs    99515.    7.86KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0\n#> 3        0\n#> 4        0"},{"path":"improving-performance.html","id":"improving-performance","chapter":"22 Improving performance","heading":"22 Improving performance","text":"","code":""},{"path":"improving-performance.html","id":"exercises-24.3.1","chapter":"22 Improving performance","heading":"22.0.1 Exercises 24.3.1","text":"Q1. faster alternatives lm()? specifically designed work larger datasets?A1. Faster alternatives lm() can found visiting CRAN Task View: High-Performance Parallel Computing R page.available options:speedglm::speedlm() (large datasets)speedglm::speedlm() (large datasets)biglm::biglm() (specifically designed data large fit memory)biglm::biglm() (specifically designed data large fit memory)RcppEigen::fastLm() (using Eigen linear algebra library)RcppEigen::fastLm() (using Eigen linear algebra library)High performances can obtained packages especially R linked optimized BLAS, ATLAS. can check information using sessionInfo():Comparing performance different alternatives:results might change depending size dataset, experiment different algorithms find one fits needs dataset best.Q2. package implements version match() ’s faster repeated look ups? much faster ?A2. package (respective function) fastmatch::fmatch()8.documentation function notes:slightly faster built-version uses specialized code, addition retains hash table within table object can re-used, dramatically reducing look-time especially large table.Let’s try.small vector, fmatch() slightly faster, order magnitude., larger vector, fmatch() orders magnitude faster! ⚡can also look hash table:Additionally, fastmatch also provides similar infix operator:Q3. List four functions (just base R) convert string date time object. strengths weaknesses?Q4. packages provide ability compute rolling mean?A4. packages respective functions provide way compute rolling mean:RcppRoll::roll_mean()data.table::frollmean()roll::roll_mean()zoo::rollmean()slider::slide_dbl()Q5. alternatives optim()?","code":"\nsessInfo <- sessionInfo()\nsessInfo$matprod\n#> [1] \"default\"\nsessInfo$LAPACK\n#> [1] \"/Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/lib/libRlapack.dylib\"\nlibrary(gapminder)\n\n# having a look at the data\ndplyr::glimpse(gapminder)\n#> Rows: 1,704\n#> Columns: 6\n#> $ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanist…\n#> $ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia…\n#> $ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982…\n#> $ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, …\n#> $ pop       <int> 8425333, 9240934, 10267083, 11537966, 13…\n#> $ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, …\n\nbench::mark(\n  \"lm\"       = stats::lm(lifeExp ~ continent * gdpPercap, gapminder),\n  \"speedglm\" = speedglm::speedlm(lifeExp ~ continent * gdpPercap, gapminder),\n  \"biglm\"    = biglm::biglm(lifeExp ~ continent * gdpPercap, gapminder),\n  \"fastLm\"   = RcppEigen::fastLm(lifeExp ~ continent * gdpPercap, gapminder),\n  check      = FALSE,\n  iterations = 1000\n)[1:5]\n#> # A tibble: 4 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 lm            574µs    616µs     1563.    1.25MB\n#> 2 speedglm      595µs    638µs     1504.   61.51MB\n#> 3 biglm         470µs    519µs     1827.  934.81KB\n#> 4 fastLm        540µs    569µs     1724.  982.41KB\nlibrary(fastmatch, warn.conflicts = FALSE)\n\nsmall_vec <- c(\"a\", \"b\", \"x\", \"m\", \"n\", \"y\")\n\nlength(small_vec)\n#> [1] 6\n\nbench::mark(\n  \"base\" = match(c(\"x\", \"y\"), small_vec),\n  \"fastmatch\" = fmatch(c(\"x\", \"y\"), small_vec)\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base          492ns    533ns  1701668.    2.77KB\n#> 2 fastmatch     369ns    451ns  2054516.    2.66KB\nlarge_vec <- c(rep(c(\"a\", \"b\"), 1e4), \"x\", rep(c(\"m\", \"n\"), 1e6), \"y\")\n\nlength(large_vec)\n#> [1] 2020002\n\nbench::mark(\n  \"base\" = match(c(\"x\", \"y\"), large_vec),\n  \"fastmatch\" = fmatch(c(\"x\", \"y\"), large_vec)\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base         14.2ms   14.3ms      69.3    31.4MB\n#> 2 fastmatch     369ns  451.1ns 2084060.         0B\nfmatch.hash(c(\"x\", \"y\"), small_vec)\n#> [1] \"a\" \"b\" \"x\" \"m\" \"n\" \"y\"\n#> attr(,\".match.hash\")\n#> <hash table>\nlibrary(fastmatch)\n\nsmall_vec <- c(\"a\", \"b\", \"x\", \"m\", \"n\", \"y\")\n\nc(\"x\", \"y\") %in% small_vec\n#> [1] TRUE TRUE\n\nc(\"x\", \"y\") %fin% small_vec\n#> [1] TRUE TRUE"},{"path":"improving-performance.html","id":"exercises-24.4.3","chapter":"22 Improving performance","heading":"22.0.2 Exercises 24.4.3","text":"Q1. ’s difference rowSums() .rowSums()?A1. documentation functions state:versions initial dot name (.colSums() etc) ‘bare-bones’ versions use programming: apply numeric (like) matrices name result.Looking source code,rowSums() function number checks validate arguments acceptable.rowSums() directly proceeds computation using internal code built R interpreterBut comparable performance:Q2. Make faster version chisq.test() computes chi-square test statistic input two numeric vectors missing values. can try simplifying chisq.test() coding mathematical definition.A2. function supposed accept two numeric vectors without missing values, can make chisq.test() less work removing code corresponding following :checks data frame matrix inputsgoodness--fit testsimulating p-valueschecking missing valuesThis leaves us much simpler, bare bones implementation:, indeed, custom function performs slightly better9 base equivalent:Q3. Can make faster version table() case input two integer vectors missing values? Can use speed chi-square test?A3. order make leaner version table(), can take similar approach trim unnecessary fat light new API accepting just two vectors without missing values. can remove following components code:extracting data objects entered ... argumentdealing missing valuesother input validation checksIn addition removal, can also use fastmatch::fmatch() instead match():custom perform slightly better:can also use function custom chi-squared test function see performance improves :, indeed, new version custom function performs even better previously :","code":"\nrowSums\n#> function (x, na.rm = FALSE, dims = 1L) \n#> {\n#>     if (is.data.frame(x)) \n#>         x <- as.matrix(x)\n#>     if (!is.array(x) || length(dn <- dim(x)) < 2L) \n#>         stop(\"'x' must be an array of at least two dimensions\")\n#>     if (dims < 1L || dims > length(dn) - 1L) \n#>         stop(\"invalid 'dims'\")\n#>     p <- prod(dn[-(id <- seq_len(dims))])\n#>     dn <- dn[id]\n#>     z <- if (is.complex(x)) \n#>         .Internal(rowSums(Re(x), prod(dn), p, na.rm)) + (0+1i) * \n#>             .Internal(rowSums(Im(x), prod(dn), p, na.rm))\n#>     else .Internal(rowSums(x, prod(dn), p, na.rm))\n#>     if (length(dn) > 1L) {\n#>         dim(z) <- dn\n#>         dimnames(z) <- dimnames(x)[id]\n#>     }\n#>     else names(z) <- dimnames(x)[[1L]]\n#>     z\n#> }\n#> <bytecode: 0x10539f558>\n#> <environment: namespace:base>\n.rowSums\n#> function (x, m, n, na.rm = FALSE) \n#> .Internal(rowSums(x, m, n, na.rm))\n#> <bytecode: 0x11c943850>\n#> <environment: namespace:base>\nx <- cbind(x1 = 3, x2 = c(4:1e4, 2:1e5))\n\nbench::mark(\n  rowSums(x),\n  .rowSums(x, dim(x)[[1]], dim(x)[[2]])\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression                                 min   median\n#>   <bch:expr>                            <bch:tm> <bch:tm>\n#> 1 rowSums(x)                              94.8µs    136µs\n#> 2 .rowSums(x, dim(x)[[1]], dim(x)[[2]])   93.9µs    133µs\n#>   `itr/sec` mem_alloc\n#>       <dbl> <bch:byt>\n#> 1     7153.     859KB\n#> 2     7522.     859KB\nmy_chisq_test <- function(x, y) {\n  x <- table(x, y)\n  n <- sum(x)\n\n  nr <- as.integer(nrow(x))\n  nc <- as.integer(ncol(x))\n\n  sr <- rowSums(x)\n  sc <- colSums(x)\n  E <- outer(sr, sc, \"*\") / n\n  v <- function(r, c, n) c * r * (n - r) * (n - c) / n^3\n  V <- outer(sr, sc, v, n)\n  dimnames(E) <- dimnames(x)\n\n  STATISTIC <- sum((abs(x - E))^2 / E)\n  PARAMETER <- (nr - 1L) * (nc - 1L)\n  PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)\n\n  names(STATISTIC) <- \"X-squared\"\n  names(PARAMETER) <- \"df\"\n\n  structure(\n    list(\n      statistic = STATISTIC,\n      parameter = PARAMETER,\n      p.value = PVAL,\n      method = \"Pearson's Chi-squared test\",\n      observed = x,\n      expected = E,\n      residuals = (x - E) / sqrt(E),\n      stdres = (x - E) / sqrt(V)\n    ),\n    class = \"htest\"\n  )\n}\nm <- c(rep(\"a\", 1000), rep(\"b\", 9000))\nn <- c(rep(c(\"x\", \"y\"), 5000))\n\nbench::mark(\n  \"base\" = chisq.test(m, n)$statistic[[1]],\n  \"custom\" = my_chisq_test(m, n)$statistic[[1]]\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base          629µs    709µs     1399.    1.47MB\n#> 2 custom        491µs    561µs     1770.    1.12MB\nmy_table <- function(x, y) {\n  x_sorted <- sort(unique(x))\n  y_sorted <- sort(unique(y))\n\n  x_length <- length(x_sorted)\n  y_length <- length(y_sorted)\n\n  bin <- fastmatch::fmatch(x, x_sorted) + x_length * fastmatch::fmatch(y, y_sorted) - x_length\n\n  y <- tabulate(bin, x_length * y_length)\n\n  y <- array(\n    y,\n    dim = c(x_length, y_length),\n    dimnames = list(x = x_sorted, y = y_sorted)\n  )\n\n  class(y) <- \"table\"\n  y\n}\nx <- c(rep(\"a\", 1000), rep(\"b\", 9000))\ny <- c(rep(c(\"x\", \"y\"), 5000))\n\n# check is set to FALSE because the custom function has an additional attribute: `'.match.hash'`\nbench::mark(\n  \"base\" = table(x, y),\n  \"custom\" = my_table(x, y),\n  check = FALSE\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base          465µs    539µs     1840.     960KB\n#> 2 custom        262µs    291µs     3409.     475KB\nmy_chisq_test2 <- function(x, y) {\n  x <- my_table(x, y)\n  n <- sum(x)\n\n  nr <- as.integer(nrow(x))\n  nc <- as.integer(ncol(x))\n\n  sr <- rowSums(x)\n  sc <- colSums(x)\n  E <- outer(sr, sc, \"*\") / n\n  v <- function(r, c, n) c * r * (n - r) * (n - c) / n^3\n  V <- outer(sr, sc, v, n)\n  dimnames(E) <- dimnames(x)\n\n  STATISTIC <- sum((abs(x - E))^2 / E)\n  PARAMETER <- (nr - 1L) * (nc - 1L)\n  PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)\n\n  names(STATISTIC) <- \"X-squared\"\n  names(PARAMETER) <- \"df\"\n\n  structure(\n    list(\n      statistic = STATISTIC,\n      parameter = PARAMETER,\n      p.value = PVAL,\n      method = \"Pearson's Chi-squared test\",\n      observed = x,\n      expected = E,\n      residuals = (x - E) / sqrt(E),\n      stdres = (x - E) / sqrt(V)\n    ),\n    class = \"htest\"\n  )\n}\nm <- c(rep(\"a\", 1000), rep(\"b\", 9000))\nn <- c(rep(c(\"x\", \"y\"), 5000))\n\nbench::mark(\n  \"base\" = chisq.test(m, n)$statistic[[1]],\n  \"custom\" = my_chisq_test2(m, n)$statistic[[1]]\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression      min   median `itr/sec` mem_alloc\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 base          628µs    707µs     1416.    1.28MB\n#> 2 custom        287µs    311µs     3205.  594.98KB"},{"path":"improving-performance.html","id":"exercises-24.5.1","chapter":"22 Improving performance","heading":"22.0.3 Exercises 24.5.1","text":"Q1. density functions, e.g., dnorm(), common interface. arguments vectorised ? rnorm(10, mean = 10:1) ?A1. density function family following interface:Reading documentation reveals following parameters vectorized:\nx, q, p, mean, sd.means something like following work:, functions don’t multiple vectorized parameters, won’t. example,following function call generates 10 random numbers (since n = 10) 10 different distributions means supplied vector 10:1.Q2. Compare speed apply(x, 1, sum) rowSums(x) varying sizes x.A2. can write custom function vary number rows matrix extract data frame comparing performance two functions.Plotting data reveals rowSums(x) O(1) behavior, O(n) (?) behavior.Q3. can use crossprod() compute weighted sum? much faster naive sum(x * w)?A3. functions provide way compute weighted sum:benchmarking performance reveals latter almost twice fast former!","code":"\ndnorm(x, mean = 0, sd = 1, log = FALSE)\npnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)\nqnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)\nrnorm(n, mean = 0, sd = 1)\nrnorm(c(1, 2, 3), mean = c(0, -1, 5))\n#> [1] 1.124335 0.930398 3.844935\ntrimws(c(\"  a \", \" bc\", \"  abc  \"), which = c(\"left\", \"right\"))\n#> Error in match.arg(which): 'arg' must be of length 1\nrnorm(n = 10, mean = 10:1)\n#>  [1]  8.2421770  9.3920474  7.1362118  7.5789906  5.2551688\n#>  [6]  6.0143714  4.6147891  1.1096247  2.8759129 -0.6756857\nbenchPerform <- function(nRow, nCol = 100) {\n  x <- matrix(data = rnorm(nRow * nCol), nrow = nRow, ncol = nCol)\n\n  bench::mark(\n    rowSums(x),\n    apply(x, 1, sum)\n  )[1:5]\n}\n\nnRowList <- list(10, 100, 500, 1000, 5000, 10000, 50000, 100000)\n\nnames(nRowList) <- as.character(nRowList)\n\nbenchDF <- purrr::map_dfr(\n  .x = nRowList,\n  .f = ~ benchPerform(.x),\n  .id = \"nRows\"\n) %>%\n  dplyr::mutate(nRows = as.numeric(nRows))\n#> Warning: Some expressions had a GC in every iteration; so\n#> filtering is disabled.\n\n#> Warning: Some expressions had a GC in every iteration; so\n#> filtering is disabled.\nggplot(\n  benchDF,\n  aes(\n    x = as.numeric(nRows),\n    y = median,\n    group = as.character(expression),\n    color = as.character(expression)\n  )\n) +\n  geom_point() +\n  geom_line() +\n  labs(\n    x = \"Number of Rows\",\n    y = \"Median Execution Time\",\n    colour = \"Function used\"\n  )\nx <- c(1:6, 2, 3)\nw <- rnorm(length(x))\n\ncrossprod(x, w)[[1]]\n#> [1] 15.94691\nsum(x * w)[[1]]\n#> [1] 15.94691\nbench::mark(\n  crossprod(x, w)[[1]],\n  sum(x * w)[[1]],\n  iterations = 1e6\n)[1:5]\n#> # A tibble: 2 × 5\n#>   expression                min   median `itr/sec` mem_alloc\n#>   <bch:expr>           <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 crossprod(x, w)[[1]]    246ns    369ns  2337155.        0B\n#> 2 sum(x * w)[[1]]          82ns    205ns  4571288.        0B"},{"path":"rewriting-r-code-in-c.html","id":"rewriting-r-code-in-c","chapter":"23 Rewriting R code in C++","heading":"23 Rewriting R code in C++","text":"","code":""},{"path":"rewriting-r-code-in-c.html","id":"exercise-25.2.6","chapter":"23 Rewriting R code in C++","heading":"23.1 Exercise 25.2.6","text":"Q1. basics C++ hand, ’s now great time practice reading writing simple C++ functions. ofthe following functions, read code figure corresponding base R function . might understand every part code yet, able figure basics function .A1.f1() mean():f2() cumsum():f3() ():f4() Position():f5() pmin():Q2. practice function writing skills, convert following functions C++. now, assume inputs missing values.A2. performance benefits going observed function primitive since already tuned max R performance. , expect performance gain diff() var().()cumprod()diff()TODOrange()var()","code":"\nlibrary(Rcpp)#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble f1(NumericVector x) {\n  int n = x.size();\n  double y = 0;\n\n  for(int i = 0; i < n; ++i) {\n    y += x[i] / n;\n  }\n  return y;\n}\n\n// [[Rcpp::export]]\nNumericVector f2(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  out[0] = x[0];\n  for(int i = 1; i < n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nbool f3(LogicalVector x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    if (x[i]) return true;\n  }\n  return false;\n}\n\n// [[Rcpp::export]]\nint f4(Function pred, List x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    LogicalVector res = pred(x[i]);\n    if (res[0]) return i + 1;\n  }\n  return 0;\n}\n\n// [[Rcpp::export]]\nNumericVector f5(NumericVector x, NumericVector y) {\n  int n = std::max(x.size(), y.size());\n  NumericVector x1 = rep_len(x, n);\n  NumericVector y1 = rep_len(y, n);\n\n  NumericVector out(n);\n\n  for (int i = 0; i < n; ++i) {\n    out[i] = std::min(x1[i], y1[i]);\n  }\n\n  return out;\n}\nx <- c(1, 2, 3, 4, 5, 6)\n\nf1(x)\n#> [1] 3.5\nmean(x)\n#> [1] 3.5\nx <- c(1, 3, 5, 6)\n\nf2(x)\n#> [1]  1  4  9 15\ncumsum(x)\n#> [1]  1  4  9 15\nx1 <- c(TRUE, FALSE, FALSE, TRUE)\nx2 <- c(FALSE, FALSE)\n\nf3(x1)\n#> [1] TRUE\nany(x1)\n#> [1] TRUE\n\nf3(x2)\n#> [1] FALSE\nany(x2)\n#> [1] FALSE\nx <- list(\"a\", TRUE, \"m\", 2)\n\nf4(is.numeric, x)\n#> [1] 4\nPosition(is.numeric, x)\n#> [1] 4\nv1 <- c(1, 3, 4, 5, 6, 7)\nv2 <- c(1, 2, 7, 2, 8, 1)\n\nf5(v1, v2)\n#> [1] 1 2 4 2 6 1\npmin(v1, v2)\n#> [1] 1 2 4 2 6 11. `all()`.\n\n2. `cumprod()`, `cummin()`, `cummax()`.\n\n3. `diff()`. Start by assuming lag 1, and then generalise for lag `n`.\n\n4. `range()`.\n\n5. `var()`. Read about the approaches you can take on \n   [Wikipedia](http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance).\n   Whenever implementing a numerical algorithm, it's always good to check \n   what is already known about the problem.\nis.primitive(all)\n#> [1] TRUE\nis.primitive(cumprod)\n#> [1] TRUE\nis.primitive(diff)\n#> [1] FALSE\nis.primitive(range)\n#> [1] TRUE\nis.primitive(var)\n#> [1] FALSE#include <vector>\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nbool allC(std::vector<bool> x)\n{\n    for (const auto& xElement : x)\n    {\n        if (!xElement) return false;\n    }\n\n    return true;\n}\nv1 <- rep(TRUE, 10)\nv2 <- c(rep(TRUE, 5), rep(FALSE, 5))\n\nall(v1)\n#> [1] TRUE\nallC(v1)\n#> [1] TRUE\n\nall(v2)\n#> [1] FALSE\nallC(v2)\n#> [1] FALSE\n\n# performance benefits?\nbench::mark(\n  all(c(rep(TRUE, 1000), rep(FALSE, 1000))),\n  allC(c(rep(TRUE, 1000), rep(FALSE, 1000))),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression                                      min\n#>   <bch:expr>                                 <bch:tm>\n#> 1 all(c(rep(TRUE, 1000), rep(FALSE, 1000)))    5.58µs\n#> 2 allC(c(rep(TRUE, 1000), rep(FALSE, 1000)))  11.15µs\n#>     median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1   6.56µs   151765.    15.8KB        0\n#> 2   11.6µs    85676.    18.3KB        0#include <vector>\n\n// [[Rcpp::export]]\nstd::vector<double> cumulativeProduct(std::vector<double> x)\n{\n    std::vector<double> out = x;\n\n    for (size_t i = 1; i < x.size(); i++)\n    {\n        out[i] = out[i - 1] * x[i];\n    }\n\n    return out;\n}\nv1 <- c(10, 4, 6, 8)\n\ncumprod(v1)\n#> [1]   10   40  240 1920\ncumulativeProduct(v1)\n#> [1]   10   40  240 1920\n\n# performance benefits?\nbench::mark(\n  cumprod(v1),\n  cumulativeProduct(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression                 min   median `itr/sec`\n#>   <bch:expr>            <bch:tm> <bch:tm>     <dbl>\n#> 1 cumprod(v1)            40.98ns  82.02ns  9793061.\n#> 2 cumulativeProduct(v1)   1.07µs   1.15µs   712332.\n#>   mem_alloc `gc/sec`\n#>   <bch:byt>    <dbl>\n#> 1        0B        0\n#> 2    7.07KB        0#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// [[Rcpp::export]]\nstd::vector<double> rangeC(std::vector<double> x)\n{\n    std::vector<double> rangeVec{0.0, 0.0};\n\n    rangeVec.at(0) = *std::min_element(x.begin(), x.end());\n    rangeVec.at(1) = *std::max_element(x.begin(), x.end());\n\n    return rangeVec;\n}\nv1 <- c(10, 4, 6, 8)\n\nrange(v1)\n#> [1]  4 10\nrangeC(v1)\n#> [1]  4 10\n\n# performance benefits?\nbench::mark(\n  range(v1),\n  rangeC(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 range(v1)    1.39µs   1.48µs   518383.        0B        0\n#> 2 rangeC(v1)   1.27µs   1.35µs   539363.    7.07KB        0#include <vector>\n#include <cmath>\n#include <numeric>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\ndouble variance(std::vector<double> x)\n{\n    double sumSquared{0};\n\n    double mean = std::accumulate(x.begin(), x.end(), 0.0) / x.size();\n\n    for (const auto& xElement : x)\n    {\n        sumSquared += pow(xElement - mean, 2.0);\n    }\n\n    return sumSquared / (x.size() - 1);\n}\nv1 <- c(1, 4, 7, 8)\n\nvar(v1)\n#> [1] 10\nvariance(v1)\n#> [1] 10\n\n# performance benefits?\nbench::mark(\n  var(v1),\n  variance(v1),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression        min   median `itr/sec` mem_alloc\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 var(v1)        5.45µs   6.21µs   139476.        0B\n#> 2 variance(v1) 943.02ns 984.06ns   765529.    7.07KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0"},{"path":"rewriting-r-code-in-c.html","id":"exercise-25.4.5","chapter":"23 Rewriting R code in C++","heading":"23.2 Exercise 25.4.5","text":"Q1. Rewrite functions Exercise 25.2.6 deal missing values. na.rm true, ignore missing values. na.rm false, return missing value input contains missing values. good functions practice min(), max(), range(), mean(), var().A1.Q2. Rewrite cumsum() diff() can handle missing values. Note functions slightly complicated behaviour.","code":"#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <Rcpp.h>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\nstd::vector<double> rangeC_NA(std::vector<double> x, bool removeNA = true)\n{\n    std::vector<double> rangeVec{0.0, 0.0};\n\n    bool naPresent = std::any_of(\n        x.begin(),\n        x.end(),\n        [](double d)\n        { return isnan(d); });\n\n    if (naPresent)\n    {\n        if (removeNA)\n        {\n            std::remove(x.begin(), x.end(), NAN);\n        }\n        else\n        {\n            rangeVec.at(0) = NA_REAL; // NAN;\n            rangeVec.at(1) = NA_REAL; // NAN;\n\n            return rangeVec;\n        }\n    }\n\n    rangeVec.at(0) = *std::min_element(x.begin(), x.end());\n    rangeVec.at(1) = *std::max_element(x.begin(), x.end());\n\n    return rangeVec;\n}\nv1 <- c(10, 4, NA, 6, 8)\n\nrange(v1, na.rm = FALSE)\n#> [1] NA NA\nrangeC_NA(v1, FALSE)\n#> [1] NA NA\n\nrange(v1, na.rm = TRUE)\n#> [1]  4 10\nrangeC_NA(v1, TRUE)\n#> [1]  4 10"},{"path":"rewriting-r-code-in-c.html","id":"exercise-25.5.7","chapter":"23 Rewriting R code in C++","heading":"23.3 Exercise 25.5.7","text":"Q1. practice using STL algorithms data structures, implement following using R functions C++, using hints provided:A1. much possible, following functions templated, .e., function agnostic data type might entered. example, uniqueC function can work integers, doubles, strings, floats, etc.Unfortunately, R doesn’t understand concept templates, way make work box10.recommend running code directly C++ instead.median.default() using partial_sort.%% using unordered_set find() count() methods.%% using unordered_set find() count() methods.unique() using unordered_set (challenge: one line!).unique() using unordered_set (challenge: one line!).min() using std::min(), max() using std::max()..min() using min_element, .max() using max_element..min() using min_element, .max() using max_element.setdiff(), union(), intersect() integers using sorted ranges set_union, set_intersection set_difference.setdiff(), union(), intersect() integers using sorted ranges set_union, set_intersection set_difference.","code":"#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]]\ndouble medianC(std::vector<double> &x)\n{\n    int middleIndex = static_cast<int>(x.size() / 2);\n\n    std::partial_sort(x.begin(), x.begin() + middleIndex, x.end());\n\n    // for even number of observations\n    if (x.size() % 2 == 0)\n    {\n        return (x[middleIndex - 1] + x[middleIndex]) / 2;\n    }\n\n    return x[middleIndex];\n}\nv1 <- c(1, 3, 3, 6, 7, 8, 9)\nv2 <- c(1, 2, 3, 4, 5, 6, 8, 9)\n\nmedian.default(v1)\n#> [1] 6\nmedianC(v1)\n#> [1] 6\n\nmedian.default(v2)\n#> [1] 4.5\nmedianC(v2)\n#> [1] 4.5\n\n# performance benefits?\nbench::mark(\n  median.default(v2),\n  medianC(v2),\n  iterations = 100\n)\n#> # A tibble: 2 × 6\n#>   expression              min   median `itr/sec` mem_alloc\n#>   <bch:expr>         <bch:tm> <bch:tm>     <dbl> <bch:byt>\n#> 1 median.default(v2)  17.34µs     19µs    51027.        0B\n#> 2 medianC(v2)          1.44µs    1.8µs   537223.    2.49KB\n#>   `gc/sec`\n#>      <dbl>\n#> 1        0\n#> 2        0#include <unordered_set>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nstd::vector<T> uniqueC(const std::vector<T> &x)\n{\n    std::unordered_set<T> xSet(x.begin(), x.end());\n    std::vector<T> xUnique;\n    xUnique.insert(xUnique.end(), xSet.begin(), xSet.end());\n\n    return xUnique;\n}#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntemplate <typename T>\nT minC(const std::vector<T> &x)\n{\n     return *std::min_element(x.begin(), x.end());\n}\n\ntemplate <typename T>\nT maxC(std::vector<T> x)\n{\n     return *std::max_element(x.begin(), x.end());\n}"}]
