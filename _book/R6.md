# R6



## Exercises 14.2.6 

**Q1.** Create a bank account R6 class that stores a balance and allows you to deposit and withdraw money. Create a subclass that throws an error if you attempt to go into overdraft. Create another subclass that allows you to go into overdraft, but charges you a fee. Create the superclass and make sure it works as expected.

**A1.** 


```r
library(R6)

# define the needed class
bankAccount <- R6::R6Class(
  "bankAccount",
  public = list(
    # fields -----------------------
    balance = NA,
    name = NA,

    # methods ----------------------
    initialize = function(name = NULL, balance) {
      self$validate(balance)

      self$name <- name
      self$balance <- balance
    },
    deposit = function(amount) {
      self$validate(amount)
      cat("Current balance is: ", self$balance, "\n", sep = "")
      cat("And you are depositing: ", amount)
      self$balance <- self$balance + amount
      invisible(self)
    },
    withdraw = function(amount) {
      self$validate(amount)
      cat("Current balance is: ", self$balance, "\n", sep = "")
      cat("And you are withdrawing: ", amount, "\n", sep = "")
      self$balance <- self$balance - amount
      invisible(self)
    },
    validate = function(amount) {
      stopifnot(is.numeric(amount), amount >= 0)
    },
    print = function() {
      cat("Dear ", self$name, ", your balance is: ", self$balance, sep = "")
      invisible(self)
    }
  )
)

# create an instance of an object
indra <- bankAccount$new(name = "Indra", balance = 100)

indra
#> Dear Indra, your balance is: 100

# do deposits and withdrawals to see if the balance changes
indra$deposit(20)
#> Current balance is: 100
#> And you are depositing:  20

indra
#> Dear Indra, your balance is: 120

indra$withdraw(10)
#> Current balance is: 120
#> And you are withdrawing: 10

indra
#> Dear Indra, your balance is: 110

# make sure input validation checks work
indra$deposit(-20)
#> Error in self$validate(amount): amount >= 0 is not TRUE
indra$deposit("pizza")
#> Error in self$validate(amount): is.numeric(amount) is not TRUE
indra$withdraw(-54)
#> Error in self$validate(amount): amount >= 0 is not TRUE
Anne <- bankAccount$new(name = "Anne", balance = -45)
#> Error in self$validate(balance): amount >= 0 is not TRUE
```

Create a subclass that errors if you attempt to overdraw


```r
bankAccountStrict <- R6::R6Class(
  "bankAccountStrict",
  inherit = bankAccount,
  public = list(
    withdraw = function(amount) {
      # use method from superclass
      super$withdraw(amount)

      if (self$balance < 0) {
        invisible(self)
        stop(
          cat("\nYou are trying to withdraw more that your balance.\n"),
          cat("I'm sorry, ", self$name, ", I'm afraid I can't do that.", sep = ""),
          call. = FALSE
        )
      }
    }
  )
)

# create an instance of an object
Pritesh <- bankAccountStrict$new(name = "Pritesh", balance = 100)

Pritesh
#> Dear Pritesh, your balance is: 100

# do deposits and withdrawals to see if the balance changes
Pritesh$deposit(20)
#> Current balance is: 100
#> And you are depositing:  20

Pritesh
#> Dear Pritesh, your balance is: 120

Pritesh$withdraw(150)
#> Current balance is: 120
#> And you are withdrawing: 150
#> 
#> You are trying to withdraw more that your balance.
#> I'm sorry, Pritesh, I'm afraid I can't do that.
#> Error:

Pritesh
#> Dear Pritesh, your balance is: -30

# make sure input validation checks work
Pritesh$deposit(-20)
#> Error in self$validate(amount): amount >= 0 is not TRUE
Pritesh$deposit("pizza")
#> Error in self$validate(amount): is.numeric(amount) is not TRUE
Pritesh$withdraw(-54)
#> Error in self$validate(amount): amount >= 0 is not TRUE
Pritesh <- bankAccountStrict$new(name = "Pritesh", balance = -45)
#> Error in self$validate(balance): amount >= 0 is not TRUE
```

Create a subclass that charges a fee if overdraw


```r
bankAccountFee <- R6::R6Class(
  "bankAccountFee",
  inherit = bankAccount,
  public = list(
    withdraw = function(amount) {
      # use method from superclass
      super$withdraw(amount)

      if (self$balance < 0) {
        cat("\nI am charging you 10 euros for overdrawing.\n")
        self$balance <- self$balance - 10
        invisible(self)
      }
    }
  )
)

# create an instance of an object
Mangesh <- bankAccountFee$new(name = "Mangesh", balance = 100)

Mangesh
#> Dear Mangesh, your balance is: 100

# do deposits and withdrawals to see if the balance changes
Mangesh$deposit(20)
#> Current balance is: 100
#> And you are depositing:  20

Mangesh
#> Dear Mangesh, your balance is: 120

Mangesh$withdraw(150)
#> Current balance is: 120
#> And you are withdrawing: 150
#> 
#> I am charging you 10 euros for overdrawing.

Mangesh
#> Dear Mangesh, your balance is: -40

# make sure input validation checks work
Mangesh$deposit(-20)
#> Error in self$validate(amount): amount >= 0 is not TRUE
Mangesh$deposit("pizza")
#> Error in self$validate(amount): is.numeric(amount) is not TRUE
Mangesh$withdraw(-54)
#> Error in self$validate(amount): amount >= 0 is not TRUE
Mangesh <- bankAccountFee$new(name = "Mangesh", balance = -45)
#> Error in self$validate(balance): amount >= 0 is not TRUE
```

**Q2.** Create an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with `$draw(n)`, and return all cards to the deck and reshuffle with `$reshuffle()`. Use the following code to make a vector of cards.
    

```r
suit <- c("♠", "♥", "♦", "♣")
value <- c("A", 2:10, "J", "Q", "K")
cards <- paste0(rep(value, 4), suit)
```

**A2.** 


```r
suit <- c("SPADE", "HEARTS", "DIAMOND", "CLUB") # sigh, Windows encoding issues
value <- c("A", 2:10, "J", "Q", "K")
cards <- paste(rep(value, 4), suit)

deck <- R6::R6Class(
  "deck",
  public = list(
    # fields -----------------------

    # methods -----------------------
    draw = function(n) {
      sample(self$cards, n)
    },
    reshuffle = function() {
      sample(self$cards)
      invisible(self)
    },
    print = function() {
      "Drawn cards are:"
      "Number of remaining cards:"
    }
  )
)

# create a new instance of this object
mydeck <- deck$new()

# draw cards
mydeck$draw(4)

# reshuffle
```

**Q3.** Why can't you model a bank account or a deck of cards with an S3 class?

**Q4.** Create an R6 class that allows you to get and set the current time zone. You can access the current time zone with `Sys.timezone()` and set it with `Sys.setenv(TZ = "newtimezone")`. When setting the time zone, make sure the new time zone is in the list provided by `OlsonNames()`.

**Q5.** Create an R6 class that manages the current working directory. It should have `$get()` and `$set()` methods.

**A5.** Here is an R6 class that manages the current working directory:


```r
manageDirectory <- R6::R6Class("manageDirectory",
  public = list(
    setWorkingDirectory = function(dir) {
      setwd(dir)
    },
    getWorkingDirectory = function() {
      getwd()
    }
  )
)
```

Let's create an instance of this class and check if the methods work as expected:


```r
myDirManager <- manageDirectory$new()

# current working directory
myDirManager$getWorkingDirectory()

# change and check if that worked
myDirManager$setWorkingDirectory("..")
myDirManager$getWorkingDirectory()

# revert this change
myDirManager$setWorkingDirectory("/Advanced-R-exercises")
```

**Q6.**  Why can't you model the time zone or current working directory with an S3 class?

**Q7.** What base type are R6 objects built on top of? What attributes do they have?

**A7.** Let's create an example class and create instance of that class:


```r
Example <- R6::R6Class("Example")
myExample <- Example$new()
```

The `R6` objects are built on top of environment:


```r
typeof(myExample)
#> [1] "environment"

rlang::env_print(myExample)
#> <environment: 0x11a05d040> [L]
#> Parent: <environment: empty>
#> Class: Example, R6
#> Bindings:
#> • .__enclos_env__: <env>
#> • clone: <fn> [L]
```

And it has only `class` attribute, which is a character vector with the `"R6"` being the last element and the superclasses being other elements:


```r
attributes(myExample)
#> $class
#> [1] "Example" "R6"
```

## Exercises 14.3.3

**Q1.** Create a bank account class that prevents you from directly setting the  account balance, but you can still withdraw from and deposit to. Throw an error if you attempt to go into overdraft.

**Q2.** Create a class with a write-only `$password` field. It should have `$check_password(password)` method that returns `TRUE` or `FALSE`, but there should be no way to view the complete password.

**A2.** Here is an implementation of the class with the needed properties:


```r
library(R6)

checkCredentials <- R6Class(
  "checkCredentials",
  public = list(
    # setter
    set_password = function(password) {
      private$.password <- password
    },

    # checker
    check_password = function(password) {
      if (is.null(private$.password)) {
        stop("No password set to check against.")
      }

      identical(password, private$.password)
    },

    # the default print method prints the private fields as well
    print = function() {
      "Password: XXXX"

      # for method chaining
      invisible(self)
    }
  ),
  private = list(
    .password = NULL
  )
)

myCheck <- checkCredentials$new()
myCheck

myCheck$set_password("1234")

myCheck$check_password("abcd")
#> [1] FALSE
myCheck$check_password("1234")
#> [1] TRUE
```

But, of course, everything is possible:


```r
myCheck$.__enclos_env__$private$.password
#> [1] "1234"
```

**Q3.** Extend the `Rando` class with another active binding that allows you to access the previous random value. Ensure that active binding is the only way to access the value.

**A3.** Here is a modified version of the `Rando` class to meet the specified requirements:


```r
Rando <- R6::R6Class("Rando",
  active = list(
    random = function(value) {
      if (missing(value)) {
        newValue <- runif(1)
        private$.previousRandom <- private$.currentRandom
        private$.currentRandom <- newValue
        return(private$.currentRandom)
      } else {
        stop("Can't set `$random`", call. = FALSE)
      }
    },
    previousRandom = function(value) {
      if (missing(value)) {
        if (is.null(private$.previousRandom)) {
          message("No random value has been generated yet.")
        } else {
          return(private$.previousRandom)
        }
      } else {
        stop("Can't set `$previousRandom`", call. = FALSE)
      }
    }
  ),
  private = list(
    .currentRandom = NULL,
    .previousRandom = NULL
  )
)
```

Let's try it out:


```r
myRando <- Rando$new()

# first time
myRando$random
#> [1] 0.2180892
myRando$previousRandom
#> No random value has been generated yet.
#> NULL

# second time
myRando$random
#> [1] 0.9876342
myRando$previousRandom
#> [1] 0.2180892

# third time
myRando$random
#> [1] 0.3484619
myRando$previousRandom
#> [1] 0.9876342
```

**Q4.** Can subclasses access private fields/methods from their parent? Perform an experiment to find out.

**A4.** Unlike classical OOP in other languages (e.g. C++), R6 subclasses (or derived classes) also have access to the private methods in superclass (or base class).

For instance, in the following example, the `Duck` class has a private method `$quack()`, but its subclass `Mallard` can access it using `super$quack()`.


```r
Duck <- R6Class("Duck",
  private = list(quack = function() print("Quack Quack"))
)

Mallard <- R6Class("Mallard",
  inherit = Duck,
  public = list(quack = function() super$quack())
)

myMallard <- Mallard$new()
myMallard$quack()
#> [1] "Quack Quack"
```

## Exercises 14.4.4

**Q1.** Create a class that allows you to write a line to a specified file. You should open a connection to the file in `$initialize()`, append a line using `cat()` in `$append_line()`, and close the connection in `$finalize()`.

**A1.** Here is a class that allows you to write a line to a specified file:


```r
library(R6)

fileEditor <- R6Class(
  "fileEditor",
  public = list(
    initialize = function(filePath) {
      private$.connection <- file(filePath, open = "wt")
    },
    append_line = function(text) {
      cat(
        text,
        file = private$.connection,
        sep = "\n",
        append = TRUE
      )
    }
  ),
  private = list(
    .connection = NULL,
    # according to R6 docs, the destructor method should be private
    finalize = function() {
      print("Closing the file connection!")
      close(private$.connection)
    }
  )
)
```

Let's check if it works as expected:


```r
greetMom <- function() {
  f <- tempfile()
  myfileEditor <- fileEditor$new(f)

  readLines(f)

  myfileEditor$append_line("Hi mom!")
  myfileEditor$append_line("It's a beautiful day!")

  readLines(f)
}

greetMom()
#> [1] "Hi mom!"               "It's a beautiful day!"

# force garbage collection
gc()
#> [1] "Closing the file connection!"
#>           used (Mb) gc trigger  (Mb) limit (Mb) max used
#> Ncells 1185967 63.4    2271562 121.4         NA  2271562
#> Vcells 2074248 15.9    8388608  64.0      16384  3308718
#>         (Mb)
#> Ncells 121.4
#> Vcells  25.3
```
