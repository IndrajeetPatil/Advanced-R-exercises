# S3



## Exercise 13.2.1 

**Q1.** Describe the difference between `t.test()` and `t.data.frame()`. When is each function called?

**A1.** 

- `t.test()` is a **generic** function to perform a *t*-test.

- `t.data.frame` is a **method** for generic `t()` (a matrix transform function) and will be dispatched for `data.frame` class objects/instances that need to be transformed.


```r
library(sloop)

# function type
ftype(t.test)
#> [1] "S3"      "generic"
ftype(t.data.frame)
#> [1] "S3"     "method"
```

**Q2.** Make a list of commonly used base R functions that contain `.` in their name but are not `S3` methods.

**A2.** Here are a few common R functions with `.` but that are not `S3` methods:

- `all.equal()`
- Most of `as.*` functions (like `as.data.frame()`, `as.numeric()`, etc.)
- `install.packages()`
- `on.exit()`
etc.

For full list, you could do:


```r
base_functions <- getNamespaceExports("base")

base_functions[grepl("(\\w+)(\\.)(\\w+)", base_functions)]
```

For example,


```r
ftype(as.data.frame)
#> [1] "S3"      "generic"
ftype(on.exit)
#> [1] "primitive"
```

**Q3.** What does the `as.data.frame.data.frame()` method do? Why is it confusing? How could you avoid this confusion in your own code?
 
**A3.** It's an `S3` **method** for **generic** `as.data.frame()`.


```r
ftype(as.data.frame.data.frame)
#> [1] "S3"     "method"
```

It can be seen in all methods supported by this generic:


```r
s3_methods_generic("as.data.frame") %>%
  dplyr::filter(class == "data.frame")
#> # A tibble: 1 x 4
#>   generic       class      visible source
#>   <chr>         <chr>      <lgl>   <chr> 
#> 1 as.data.frame data.frame TRUE    base
```


**Q4.** Describe the difference in behaviour in these two calls.


```r
set.seed(1014)
some_days <- as.Date("2017-01-31") + sample(10, 5)
mean(some_days)
#> [1] "2017-02-06"
mean(unclass(some_days))
#> [1] 17203.4
```

**A4.** 

- Before unclassing, the `mean` generic dispatches `.Date` method:


```r
some_days <- as.Date("2017-01-31") + sample(10, 5)

some_days
#> [1] "2017-02-06" "2017-02-09" "2017-02-05" "2017-02-08"
#> [5] "2017-02-07"

s3_dispatch(mean(some_days))
#> => mean.Date
#>  * mean.default

mean(some_days)
#> [1] "2017-02-07"
```

- After unclassing, the `mean` generic dispatches `.numeric` method:


```r
unclass(some_days)
#> [1] 17203 17206 17202 17205 17204

mean(unclass(some_days))
#> [1] 17204

s3_dispatch(mean(unclass(some_days)))
#>    mean.double
#>    mean.numeric
#> => mean.default
```

**Q5.** What class of object does the following code return? What base type is it built on? What attributes does it use?


```r
x <- ecdf(rpois(100, 10))
x
```

**A5.** The object is based on base type `closure`^[of "object of type 'closure' is not subsettable" fame], which is a type of function.


```r
x <- ecdf(rpois(100, 10))
x
#> Empirical CDF 
#> Call: ecdf(rpois(100, 10))
#>  x[1:18] =      2,      3,      4,  ...,     18,     19

otype(x)
#> [1] "S3"
typeof(x)
#> [1] "closure"
```

Its class is `ecdf`, which has other superclasses.


```r
s3_class(x)
#> [1] "ecdf"     "stepfun"  "function"
```

Apart from `class`, it has the following attributes:


```r
attributes(x)
#> $class
#> [1] "ecdf"     "stepfun"  "function"
#> 
#> $call
#> ecdf(rpois(100, 10))
```

**Q6.** What class of object does the following code return? What base type is it built on? What attributes does it use?


```r
x <- table(rpois(100, 5))
x
```

**A6.** The object is based on base type `integer`.


```r
x <- table(rpois(100, 5))
x
#> 
#>  1  2  3  4  5  6  7  8  9 10 
#>  7  7 18 13 14 14 16  4  4  3

otype(x)
#> [1] "S3"
typeof(x)
#> [1] "integer"
```

Its class is `table`.


```r
s3_class(x)
#> [1] "table"
```

Apart from `class`, it has the following attributes:


```r
attributes(x)
#> $dim
#> [1] 10
#> 
#> $dimnames
#> $dimnames[[1]]
#>  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
#> 
#> 
#> $class
#> [1] "table"
```

## Exercise 13.3.4

**Q1.** Write a constructor for `data.frame` objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?

**A1.** 


```r
my_data_frame <- function(...,
                          row.names = NULL,
                          check.rows = FALSE,
                          check.names = TRUE,
                          fix.empty.names = TRUE,
                          stringsAsFactors = FALSE) {
  structure(
    df,
    class = "data.frame"
  )
}
```


**Q2.** Enhance my `factor()` helper to have better behaviour when one or more `values` is not found in `levels`. What does `base::factor()` do in this situation?

**Q3.** Carefully read the source code of `factor()`. What does it do that my constructor does not?
    
**Q4.** Factors have an optional "contrasts" attribute. Read the help for `C()`, and briefly describe the purpose of the attribute. What type should it have? Rewrite the `new_factor()` constructor to include this attribute.

**Q5.** Read the documentation for `utils::as.roman()`. How would you write a constructor for this class? Does it need a validator? What might a helper do?
