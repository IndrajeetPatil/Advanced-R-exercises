# S3



## Exercises 13.2.1 

**Q1.** Describe the difference between `t.test()` and `t.data.frame()`. When is each function called?

**A1.** 

- `t.test()` is a **generic** function to perform a *t*-test.

- `t.data.frame` is a **method** for generic `t()` (a matrix transform function) and will be dispatched for `data.frame` class objects/instances that need to be transformed.


```r
library(sloop)

# function type
ftype(t.test)
#> [1] "S3"      "generic"
ftype(t.data.frame)
#> [1] "S3"     "method"
```

**Q2.** Make a list of commonly used base R functions that contain `.` in their name but are not `S3` methods.

**A2.** Here are a few common R functions with `.` but that are not `S3` methods:

- `all.equal()`
- Most of `as.*` functions (like `as.data.frame()`, `as.numeric()`, etc.)
- `install.packages()`
- `on.exit()`
etc.

For full list, you could do:


```r
base_functions <- getNamespaceExports("base")

base_functions[grepl("(\\w+)(\\.)(\\w+)", base_functions)]
```

For example,


```r
ftype(as.data.frame)
#> [1] "S3"      "generic"
ftype(on.exit)
#> [1] "primitive"
```

**Q3.** What does the `as.data.frame.data.frame()` method do? Why is it confusing? How could you avoid this confusion in your own code?
 
**A3.** It's an `S3` **method** for **generic** `as.data.frame()`.


```r
ftype(as.data.frame.data.frame)
#> [1] "S3"     "method"
```

It can be seen in all methods supported by this generic:


```r
s3_methods_generic("as.data.frame") %>%
  dplyr::filter(class == "data.frame")
#> # A tibble: 1 × 4
#>   generic       class      visible source
#>   <chr>         <chr>      <lgl>   <chr> 
#> 1 as.data.frame data.frame TRUE    base
```


**Q4.** Describe the difference in behaviour in these two calls.


```r
set.seed(1014)
some_days <- as.Date("2017-01-31") + sample(10, 5)
mean(some_days)
#> [1] "2017-02-06"
mean(unclass(some_days))
#> [1] 17203.4
```

**A4.** 

- Before unclassing, the `mean` generic dispatches `.Date` method:


```r
some_days <- as.Date("2017-01-31") + sample(10, 5)

some_days
#> [1] "2017-02-06" "2017-02-09" "2017-02-05" "2017-02-08"
#> [5] "2017-02-07"

s3_dispatch(mean(some_days))
#> => mean.Date
#>  * mean.default

mean(some_days)
#> [1] "2017-02-07"
```

- After unclassing, the `mean` generic dispatches `.numeric` method:


```r
unclass(some_days)
#> [1] 17203 17206 17202 17205 17204

mean(unclass(some_days))
#> [1] 17204

s3_dispatch(mean(unclass(some_days)))
#>    mean.double
#>    mean.numeric
#> => mean.default
```

**Q5.** What class of object does the following code return? What base type is it built on? What attributes does it use?


```r
x <- ecdf(rpois(100, 10))
x
```

**A5.** The object is based on base type `closure`^[of "object of type 'closure' is not subsettable" fame], which is a type of function.


```r
x <- ecdf(rpois(100, 10))
x
#> Empirical CDF 
#> Call: ecdf(rpois(100, 10))
#>  x[1:18] =      2,      3,      4,  ...,     18,     19

otype(x)
#> [1] "S3"
typeof(x)
#> [1] "closure"
```

Its class is `ecdf`, which has other superclasses.


```r
s3_class(x)
#> [1] "ecdf"     "stepfun"  "function"
```

Apart from `class`, it has the following attributes:


```r
attributes(x)
#> $class
#> [1] "ecdf"     "stepfun"  "function"
#> 
#> $call
#> ecdf(rpois(100, 10))
```

**Q6.** What class of object does the following code return? What base type is it built on? What attributes does it use?


```r
x <- table(rpois(100, 5))
x
```

**A6.** The object is based on base type `integer`.


```r
x <- table(rpois(100, 5))
x
#> 
#>  1  2  3  4  5  6  7  8  9 10 
#>  7  7 18 13 14 14 16  4  4  3

otype(x)
#> [1] "S3"
typeof(x)
#> [1] "integer"
```

Its class is `table`.


```r
s3_class(x)
#> [1] "table"
```

Apart from `class`, it has the following attributes:


```r
attributes(x)
#> $dim
#> [1] 10
#> 
#> $dimnames
#> $dimnames[[1]]
#>  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
#> 
#> 
#> $class
#> [1] "table"
```

## Exercises 13.3.4

**Q1.** Write a constructor for `data.frame` objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?

**A1.** 


```r
my_data_frame <- function(...,
                          row.names = NULL,
                          check.rows = FALSE,
                          check.names = TRUE,
                          fix.empty.names = TRUE,
                          stringsAsFactors = FALSE) {
  structure(
    df,
    class = "data.frame"
  )
}
```


**Q2.** Enhance my `factor()` helper to have better behaviour when one or more `values` is not found in `levels`. What does `base::factor()` do in this situation?

**Q3.** Carefully read the source code of `factor()`. What does it do that my constructor does not?
    
**Q4.** Factors have an optional "contrasts" attribute. Read the help for `C()`, and briefly describe the purpose of the attribute. What type should it have? Rewrite the `new_factor()` constructor to include this attribute.

**Q5.** Read the documentation for `utils::as.roman()`. How would you write a constructor for this class? Does it need a validator? What might a helper do?


## Exercises 13.4.4

**Q1.** Read the source code for `t()` and `t.test()` and confirm that `t.test()` is an S3 generic and not an S3 method. What happens if you create an object with class `test` and call `t()` with it? Why?


```r
x <- structure(1:10, class = "test")
t(x)
```

**A1.** Looking at source code of these functions, we can see that both of these are generic, and we can confirm the same using `{sloop}`:


```r
t
#> function (x) 
#> UseMethod("t")
#> <bytecode: 0x12c95bba0>
#> <environment: namespace:base>
sloop::is_s3_generic("t")
#> [1] TRUE

t.test
#> function (x, ...) 
#> UseMethod("t.test")
#> <bytecode: 0x15c46d338>
#> <environment: namespace:stats>
sloop::is_s3_generic("t.test")
#> [1] TRUE
```

Looking at the `S3` dispatch, we can see that since R can't find `S3` method for `test` class for generic function `t()`, it dispatches the default method, which converts the structure to a matrix:


```r
x <- structure(1:10, class = "test")
t(x)
#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
#> [1,]    1    2    3    4    5    6    7    8    9    10
#> attr(,"class")
#> [1] "test"
s3_dispatch(t(x))
#> => t.test
#>  * t.default
```

The same behaviour can be observed with a vector:


```r
t(1:10)
#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
#> [1,]    1    2    3    4    5    6    7    8    9    10
```

**Q2.** What generics does the `table` class have methods for?

**A2.** The `table` class have methods for the following generics:


```r
s3_methods_class("table")
#> # A tibble: 11 × 4
#>    generic       class visible source             
#>    <chr>         <chr> <lgl>   <chr>              
#>  1 [             table TRUE    base               
#>  2 aperm         table TRUE    base               
#>  3 as_tibble     table FALSE   registered S3method
#>  4 as.data.frame table TRUE    base               
#>  5 Axis          table FALSE   registered S3method
#>  6 lines         table FALSE   registered S3method
#>  7 plot          table FALSE   registered S3method
#>  8 points        table FALSE   registered S3method
#>  9 print         table TRUE    base               
#> 10 summary       table TRUE    base               
#> 11 tail          table FALSE   registered S3method
```

**Q3.** What generics does the `ecdf` class have methods for?

**A3.** The `ecdf` class have methods for the following generics:


```r
s3_methods_class("ecdf")
#> # A tibble: 4 × 4
#>   generic  class visible source             
#>   <chr>    <chr> <lgl>   <chr>              
#> 1 plot     ecdf  TRUE    stats              
#> 2 print    ecdf  FALSE   registered S3method
#> 3 quantile ecdf  FALSE   registered S3method
#> 4 summary  ecdf  FALSE   registered S3method
```

**Q4.** Which base generic has the greatest number of defined methods?

**A4.** To answer this question, first, let's list all functions base has and only retain the generics.


```r
library(purrr)
library(dplyr)

# getting all functions names
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)

# extracting only generics
genFuns <- names(funs) %>%
  purrr::keep(~ sloop::is_s3_generic(.x))
```

Now it's a simple matter of counting number of methods per generic and ordering the data frame in descending order of this count:


```r
purrr::map_dfr(
  genFuns,
  ~ s3_methods_generic(.)
) %>%
  dplyr::group_by(generic) %>%
  dplyr::tally() %>%
  dplyr::arrange(desc(n))
#> # A tibble: 122 × 2
#>    generic           n
#>    <chr>         <int>
#>  1 print           346
#>  2 format          147
#>  3 [                65
#>  4 as.character     50
#>  5 summary          45
#>  6 as.data.frame    37
#>  7 plot             34
#>  8 [[               32
#>  9 [<-              21
#> 10 c                20
#> # … with 112 more rows
```

This reveals that the base generic function with most methods is `print()`.

**Q5.** Carefully read the documentation for `UseMethod()` and explain why the following code returns the results that it does. What two usual rules of function evaluation does `UseMethod()` violate?


```r
g <- function(x) {
  x <- 10
  y <- 10
  UseMethod("g")
}
g.default <- function(x) c(x = x, y = y)
x <- 1
y <- 1
g(x)
#>  x  y 
#>  1 10
```

**Q6.** What are the arguments to `[`? Why is this a hard question to answer?

## Exercises 13.5.1

**Q1.** Categorise the objects returned by `lm()`, `factor()`, `table()`, `as.Date()`, `as.POSIXct()` `ecdf()`, `ordered()`, `I()` into the styles described above.

**Q2.** What would a constructor function for `lm` objects, `new_lm()`, look like? Use `?lm` and experimentation to figure out the required fields and their types.

## Exercises 13.6.3

**Q1.** How does `[.Date` support subclasses? How does it fail to support subclasses?

**Q2.** R has two classes for representing date time data, `POSIXct` and `POSIXlt`, which both inherit from `POSIXt`. Which generics have different behaviours for the two classes? Which generics share the same behaviour?

**Q3.** What do you expect this code to return? What does it actually return? Why?


```r
generic2 <- function(x) UseMethod("generic2")
generic2.a1 <- function(x) "a1"
generic2.a2 <- function(x) "a2"
generic2.b <- function(x) {
  class(x) <- "a1"
  NextMethod()
}
generic2(structure(list(), class = c("b", "a2")))
```

## Exercises 13.7.5

**Q1.** Explain the differences in dispatch below:


```r
length.integer <- function(x) 10

x1 <- 1:5
class(x1)
#> [1] "integer"
s3_dispatch(length(x1))
#>  * length.integer
#>    length.numeric
#>    length.default
#> => length (internal)

x2 <- structure(x1, class = "integer")
class(x2)
#> [1] "integer"
s3_dispatch(length(x2))
#> => length.integer
#>    length.default
#>  * length (internal)
```

**Q2.** What classes have a method for the `Math` group generic in base R? Read the source code. How do the methods work?

**Q3.** `Math.difftime()` is more complicated than I described. Why?
