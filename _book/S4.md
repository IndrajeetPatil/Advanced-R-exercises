# S4



### Exercises 15.2.1

---

**Q1.** `lubridate::period()` returns an S4 class. What slots does it have? What class is each slot? What accessors does it provide?

**A1.** Let's first create an instance of `Period` class:


```r
library(lubridate)
#> 
#> Attaching package: 'lubridate'
#> The following objects are masked from 'package:base':
#> 
#>     date, intersect, setdiff, union
x <- lubridate::period(c(2, 43, 6), c("hour", "second", "minute"))
x
#> [1] "2H 6M 43S"
```

It has the following slots:


```r
slotNames(x)
#> [1] ".Data"  "year"   "month"  "day"    "hour"   "minute"
```

Additionally, the base type of each slot (`numeric`) can be seen in `str()` output:


```r
str(x)
#> Formal class 'Period' [package "lubridate"] with 6 slots
#>   ..@ .Data : num 43
#>   ..@ year  : num 0
#>   ..@ month : num 0
#>   ..@ day   : num 0
#>   ..@ hour  : num 2
#>   ..@ minute: num 6
```

The `{lubridate}` package provides accessors to access all of these slots:


```r
year(x)
#> [1] 0
month(x)
#> [1] 0
day(x)
#> [1] 0
hour(x)
#> [1] 2
minute(x)
#> [1] 6
second(x)
#> [1] 43
```

---

**Q2.** What other ways can you find help for a method? Read `?"?"` and summarise the details.

**A2.** The `"?"` operator allows access to this documentation in three ways. To demonstrate different ways to access documentation, let's define a new `S4` class.


```r
pow <- function(x, exp) c(x, exp)
setGeneric("pow")
#> [1] "pow"
setMethod("pow", c("numeric", "numeric"), function(x, exp) x^exp)
```

Ways to access documentation:

- The general documentation for a generic can be found with `?topic`:


```r
?pow
```

- The expression `type?topic` will look for the overall documentation methods for the function `f`.


```r
?pow # produces the function documentation

methods?pow # looks for the overall methods documentation
```

---

### Exercises 15.3.6

---

**Q1.** Extend the Person class with fields to match `utils::person()`. Think about what slots you will need, what class each slot should have, and what you'll need to check in your validity method.

**A1.** The code below extends the `Person` class described in the book to match more closely with `utils::person()`.


```r
setClass("Person",
  slots = c(
    age     = "numeric",
    given   = "character",
    family  = "character",
    middle  = "character",
    email   = "character",
    role    = "character",
    comment = "character"
  ),
  prototype = list(
    age     = NA_real_,
    given   = NA_character_,
    family  = NA_character_,
    middle  = NA_character_,
    email   = NA_character_,
    role    = NA_character_,
    comment = NA_character_
  )
)

# Helper function to create an instance of the `Person` class
Person <- function(given,
                   family,
                   middle = NA_character_,
                   age = NA_real_,
                   email = NA_character_,
                   role = NA_character_,
                   comment = NA_character_) {
  age <- as.double(age)

  new("Person",
    age     = age,
    given   = given,
    family  = family,
    middle  = middle,
    email   = email,
    role    = role,
    comment = comment
  )
}

# Validator to ensure that each slot is of length one and that the specified
# role is one of the possible roles
setValidity("Person", function(object) {
  invalid_length <- NULL
  slot_lengths <- c(
    length(object@age),
    length(object@given),
    length(object@middle),
    length(object@family),
    length(object@email),
    length(object@comment)
  )
  
  if (any(slot_lengths != 1L)) {
    invalid_length <- "Slots @age, @given, @family, @middle, @email, @comment must be of length 1."
  }

  possible_roles <- c(
    NA_character_, "aut", "com", "cph", "cre", "ctb", "ctr", "dtc", "fnd", "rev", "ths", "trl"
  )

  if (any(!object@role %in% possible_roles)) {
    invalid_length <- paste(
      invalid_length, "\n",
      "@role(s) must be one of",
      paste(possible_roles, collapse = ", ")
    )
  }

  if (!is.null(invalid_length)) {
    return(invalid_length)
  } else {
    return(TRUE)
  }
})
#> Class "Person" [in ".GlobalEnv"]
#> 
#> Slots:
#>                                                         
#> Name:        age     given    family    middle     email
#> Class:   numeric character character character character
#>                           
#> Name:       role   comment
#> Class: character character
```

Let's make sure that validation works as expected:


```r
Person(c("Indrajeet", "Surendra"), "Patil")
#> Error in validObject(.Object): invalid class "Person" object: Slots @age, @given, @family, @middle, @email, @comment must be of length 1.
Person("Indrajeet", "Patil", role = "xyz")
#> Error in validObject(.Object): invalid class "Person" object:  
#>  @role(s) must be one of NA, aut, com, cph, cre, ctb, ctr, dtc, fnd, rev, ths, trl
Person("Indrajeet", "Patil", role = c("aut", "cph"))
#> An object of class "Person"
#> Slot "age":
#> [1] NA
#> 
#> Slot "given":
#> [1] "Indrajeet"
#> 
#> Slot "family":
#> [1] "Patil"
#> 
#> Slot "middle":
#> [1] NA
#> 
#> Slot "email":
#> [1] NA
#> 
#> Slot "role":
#> [1] "aut" "cph"
#> 
#> Slot "comment":
#> [1] NA
```



---

**Q2.** What happens if you define a new S4 class that doesn't have any slots? (Hint: read about virtual classes in `?setClass`.)

---

**Q3.** Imagine you were going to reimplement factors, dates, and data frames in S4. Sketch out the `setClass()` calls that you would use to define the classes. Think about appropriate `slots` and `prototype`.

---

### Exercises 15.4.5

**Q1.** Add `age()` accessors for the `Person` class.

**Q2.** In the definition of the generic, why is it necessary to repeat the name of the generic twice?

**Q3.** Why does the `show()` method defined in Section [Show method](https://adv-r.hadley.nz/s4.html#show-method) use `is(object)[[1]]`? (Hint: try printing the employee subclass.)

**Q4.** What happens if you define a method with different argument names to the generic?

### Exercises 15.5.5

**Q1.** Draw the method graph for `f(`ðŸ˜…, ðŸ˜½`)`.

**Q2.** Draw the method graph for `f(`ðŸ˜ƒ, ðŸ˜‰, ðŸ˜™`)`.

**Q3.** Take the last example which shows multiple dispatch over two classes that use multiple inheritance. What happens if you define a method for all terminal classes? Why does method dispatch not save us much work here?

### Exercises 15.6.3

**Q1.** What would a full `setOldClass()` definition look like for an ordered factor (i.e. add `slots` and `prototype` the definition above)?

**Q2.** Define a `length` method for the `Person` class.
