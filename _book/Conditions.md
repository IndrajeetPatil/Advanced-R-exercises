# Conditions



### Exercises 8.2.4

**Q1.** Write a wrapper around `file.remove()` that throws an error if the file to be deleted does not exist.

**A1.** Let's first create a wrapper function around `file.remove()` that throws an error if the file to be deleted does not exist.


```r
fileRemove <- function(...) {
  existing_files <- fs::file_exists(...)

  if (!all(existing_files)) {
    stop(
      cat(
        "The following files to be deleted don't exist:",
        names(existing_files[!existing_files]),
        sep = "\n"
      )
    )
  }

  file.remove(...)
}
```

Let's first create a file that we can delete immediately.


```r
fs::file_create("random.R")
```

The function should fail if there are any other files provided that don't exist:


```r
fileRemove(c("random.R", "XYZ.csv"))
#> The following files to be deleted don't exist:
#> XYZ.csv
#> Error in fileRemove(c("random.R", "XYZ.csv")):
```

But does work as expected when the file exists:


```r
fileRemove("random.R")
#> [1] TRUE
```

**Q2.** What does the `appendLF` argument to `message()` do? How is it related to `cat()`?

**A2.** As mentioned in the docs for `message()`, `appendLF` argument decides:

> should messages given as a character string have a newline appended?

- If `TRUE`, a final newline is regarded as part of the message:


```r
message("Beetle", appendLF = TRUE)
#> Beetle
message("Juice", appendLF = TRUE)
#> Juice
```

- If `FALSE`, messages will be concatenated:


```r
message("Beetle", appendLF = FALSE)
#> Beetle
message("Juice", appendLF = FALSE)
#> Juice
```

On the other hand, `cat()` converts its arguments to character vectors and concatenates them to a single character vector by default:


```r
cat("Beetle")
#> Beetle
cat("Juice")
#> Juice
```

In order to get output `message()`-like default behavior, we can set `sep = "\n"`:


```r
cat("Beetle", sep = "\n")
#> Beetle
cat("Juice", sep = "\n")
#> Juice
```

### Exercises 8.4.5

**Q1.** What extra information does the condition generated by `abort()` contain compared to the condition generated by `stop()` i.e. what's the difference between these two objects? Read the help for `?abort` to learn more.


```r
catch_cnd(stop("An error"))
catch_cnd(abort("An error"))
```

**A1.** Contrasting these two lists, we can see that `rlang::abort()` contains two additional pieces of information:

- `trace`: A traceback capturing the sequence of calls that lead to the current function 
- `parent`: Information about another condition used as a parent to create a chained condition.


```r
library(rlang)
#> 
#> Attaching package: 'rlang'
#> The following object is masked from 'package:magrittr':
#> 
#>     set_names

stopInfo <- catch_cnd(stop("An error"))
abortInfo <- catch_cnd(abort("An error"))

str(stopInfo)
#> List of 2
#>  $ message: chr "An error"
#>  $ call   : language force(expr)
#>  - attr(*, "class")= chr [1:3] "simpleError" "error" "condition"

str(abortInfo)
#> List of 4
#>  $ message: chr "An error"
#>  $ trace  :Classes 'rlang_trace', 'rlib_trace', 'tbl' and 'data.frame':	8 obs. of  6 variables:
#>   ..$ call       :List of 8
#>   .. ..$ : language catch_cnd(abort("An error"))
#>   .. ..$ : language eval_bare(rlang::expr(tryCatch(!!!handlers, {     force(expr) ...
#>   .. ..$ : language tryCatch(condition = `<fn>`, {     force(expr) ...
#>   .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
#>   .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
#>   .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
#>   .. ..$ : language force(expr)
#>   .. ..$ : language abort("An error")
#>   ..$ parent     : int [1:8] 0 1 1 3 4 5 1 0
#>   ..$ visible    : logi [1:8] FALSE FALSE FALSE FALSE FALSE FALSE ...
#>   ..$ namespace  : chr [1:8] "rlang" "rlang" "base" "base" ...
#>   ..$ scope      : chr [1:8] "::" "::" "::" "local" ...
#>   ..$ error_frame: logi [1:8] FALSE FALSE FALSE FALSE FALSE FALSE ...
#>   ..- attr(*, "version")= int 2
#>  $ parent : NULL
#>  $ call   : NULL
#>  - attr(*, "class")= chr [1:3] "rlang_error" "error" "condition"
```

**Q2.** Predict the results of evaluating the following code


```r
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
show_condition({
  10
  message("?")
  warning("?!")
})
```

**A2.** Correctly predicted ðŸ˜‰


```r
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!"))
#> [1] "error"
show_condition(10)
#> NULL
show_condition(warning("?!"))
#> [1] "warning"
show_condition({
  10
  message("?")
  warning("?!")
})
#> [1] "message"
```

The last piece of code is the challenging one and it illustrates how `tryCatch()` works. From its docs:

> When several handlers are supplied in a single tryCatch then the first one is considered more recent than the second.

**Q3.** Explain the results of running this code:


```r
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
#> b
#> a
#> b
#> c
```

**A3.** The surprising part of this output is the `b` before the last `c`.

This happens because the inner calling handler doesn't handle the message, so it bubbles up to the outer calling handler.

**Q4.** Read the source code for `catch_cnd()` and explain how it works.

**A4.** Let's look at the source code for `catch_cnd()`:


```r
rlang::catch_cnd
#> function (expr, classes = "condition") 
#> {
#>     stopifnot(is_character(classes))
#>     handlers <- rep_named(classes, list(identity))
#>     eval_bare(rlang::expr(tryCatch(!!!handlers, {
#>         force(expr)
#>         return(NULL)
#>     })))
#> }
#> <bytecode: 0x11b4c6be8>
#> <environment: namespace:rlang>
```

As mentioned in the function docs:

> This is a small wrapper around `tryCatch()` that captures any condition signalled while evaluating its argument.

The `classes` argument allows a character vector of condition classes to catch, and the complex tidy evaluation generates the necessary condition (if there is any; otherwise `NULL`).


```r
catch_cnd(10)
#> NULL

catch_cnd(abort(message = "an error", class = "my class"))
#> <error/my class>
#> Error:
#> ! an error
#> ---
#> Backtrace:

catch_cnd(abort("an error"), classes = "message")
#> Error:
#> ! an error
```

**Q5.** How could you rewrite `show_condition()` to use a single handler?

**A5.** The source code for `rlang::catch_cond()` gives us a clue as to how we can do this.

Conditions also have a `class` attribute, and we can use it to determine which handler will match the condition.


```r
show_condition2 <- function(code) {
  tryCatch(
    condition = function(cnd) {
      if (inherits(cnd, "error")) return("error")
      if (inherits(cnd, "warning")) return("warning")
      if (inherits(cnd, "message")) return("message")
    },
    {
      code
      NULL
    }
  )
}
```

Let's try this new version with the examples from original version:


```r
show_condition2(stop("!"))
#> [1] "error"
show_condition2(10)
#> NULL
show_condition2(warning("?!"))
#> [1] "warning"
show_condition2({
  10
  message("?")
  warning("?!")
})
#> [1] "message"
```

### Exercises 8.5.4

**Q1.** Inside a package, it's occasionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with `requireNamespace("pkg", quietly = FALSE))` and if not, throws a custom condition that includes the package name in the metadata.

**Q2.** Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?

### Exercises 8.6.6

**Q1.** Create `suppressConditions()` that works like `suppressMessages()` and  `suppressWarnings()` but suppresses everything. Think carefully about how you should handle errors.

**Q2.** Compare the following two implementations of `message2error()`. What is the main advantage of `withCallingHandlers()` in this scenario? (Hint: look carefully at the traceback.)


```r
message2error <- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}
message2error <- function(code) {
  tryCatch(code, message = function(e) stop(e))
}
```

**Q3.** How would you modify the `catch_cnds()` definition if you wanted to recreate the original intermingling of warnings and messages?

**Q4.**  Why is catching interrupts dangerous? Run this code to find out.


```r
bottles_of_beer <- function(i = 99) {
  message(
    "There are ", i, " bottles of beer on the wall, ",
    i, " bottles of beer."
  )
  while (i > 0) {
    tryCatch(
      Sys.sleep(1),
      interrupt = function(err) {
        i <<- i - 1
        if (i > 0) {
          message(
            "Take one down, pass it around, ", i,
            " bottle", if (i > 1) "s", " of beer on the wall."
          )
        }
      }
    )
  }
  message(
    "No more bottles of beer on the wall, ",
    "no more bottles of beer."
  )
}
```
