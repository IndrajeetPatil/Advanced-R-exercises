# R6

```{r, include = FALSE}
source("common.R")
```

## Exercises 14.2.6 

**Q1.** Create a bank account R6 class that stores a balance and allows you to deposit and withdraw money. Create a subclass that throws an error if you attempt to go into overdraft. Create another subclass that allows you to go into overdraft, but charges you a fee. Create the superclass and make sure it works as expected.

**A1.** 

```{r, error=TRUE}
library(R6)

# define the needed class
bankAccount <- R6::R6Class(
  "bankAccount",
  public = list(
    # fields -----------------------
    balance = NA,
    name = NA,

    # methods ----------------------
    initialize = function(name = NULL, balance) {
      self$validate(balance)

      self$name <- name
      self$balance <- balance
    },
    deposit = function(amount) {
      self$validate(amount)
      cat("Current balance is: ", self$balance, "\n", sep = "")
      cat("And you are depositing: ", amount)
      self$balance <- self$balance + amount
      invisible(self)
    },
    withdraw = function(amount) {
      self$validate(amount)
      cat("Current balance is: ", self$balance, "\n", sep = "")
      cat("And you are withdrawing: ", amount, "\n", sep = "")
      self$balance <- self$balance - amount
      invisible(self)
    },
    validate = function(amount) {
      stopifnot(is.numeric(amount), amount >= 0)
    },
    print = function() {
      cat("Dear ", self$name, ", your balance is: ", self$balance, sep = "")
      invisible(self)
    }
  )
)

# create an instance of an object
indra <- bankAccount$new(name = "Indra", balance = 100)

indra

# do deposits and withdrawals to see if the balance changes
indra$deposit(20)

indra

indra$withdraw(10)

indra

# make sure input validation checks work
indra$deposit(-20)
indra$deposit("pizza")
indra$withdraw(-54)
Anne <- bankAccount$new(name = "Anne", balance = -45)
```

Create a subclass that errors if you attempt to overdraw

```{r, error=TRUE}
bankAccountStrict <- R6::R6Class(
  "bankAccountStrict",
  inherit = bankAccount,
  public = list(
    withdraw = function(amount) {
      # use method from superclass
      super$withdraw(amount)

      if (self$balance < 0) {
        invisible(self)
        stop(
          cat("\nYou are trying to withdraw more that your balance.\n"),
          cat("I'm sorry, ", self$name, ", I'm afraid I can't do that.", sep = ""),
          call. = FALSE
        )
      }
    }
  )
)

# create an instance of an object
Pritesh <- bankAccountStrict$new(name = "Pritesh", balance = 100)

Pritesh

# do deposits and withdrawals to see if the balance changes
Pritesh$deposit(20)

Pritesh

Pritesh$withdraw(150)

Pritesh

# make sure input validation checks work
Pritesh$deposit(-20)
Pritesh$deposit("pizza")
Pritesh$withdraw(-54)
Pritesh <- bankAccountStrict$new(name = "Pritesh", balance = -45)
```

Create a subclass that charges a fee if overdraw

```{r, error=TRUE}
bankAccountFee <- R6::R6Class(
  "bankAccountFee",
  inherit = bankAccount,
  public = list(
    withdraw = function(amount) {
      # use method from superclass
      super$withdraw(amount)

      if (self$balance < 0) {
        cat("\nI am charging you 10 euros for overdrawing.\n")
        self$balance <- self$balance - 10
        invisible(self)
      }
    }
  )
)

# create an instance of an object
Mangesh <- bankAccountFee$new(name = "Mangesh", balance = 100)

Mangesh

# do deposits and withdrawals to see if the balance changes
Mangesh$deposit(20)

Mangesh

Mangesh$withdraw(150)

Mangesh

# make sure input validation checks work
Mangesh$deposit(-20)
Mangesh$deposit("pizza")
Mangesh$withdraw(-54)
Mangesh <- bankAccountFee$new(name = "Mangesh", balance = -45)
```

**Q2.** Create an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with `$draw(n)`, and return all cards to the deck and reshuffle with `$reshuffle()`. Use the following code to make a vector of cards.
    
```{r}
suit <- c("♠", "♥", "♦", "♣")
value <- c("A", 2:10, "J", "Q", "K")
cards <- paste0(rep(value, 4), suit)
```

**A2.** 

```{r, eval=FALSE}
suit <- c("SPADE", "HEARTS", "DIAMOND", "CLUB") # sigh, Windows encoding issues
value <- c("A", 2:10, "J", "Q", "K")
cards <- paste(rep(value, 4), suit)

deck <- R6::R6Class(
  "deck",
  public = list(
    # fields -----------------------


    # methods -----------------------
    draw = function(n) {
      sample(self$cards, n)
    },
    reshuffle = function() {
      sample(self$cards)
      invisible(self)
    },
    print = function() {
      "Drawn cards are:"
      "Number of remaining cards:"
    }
  )
)

# create a new instance of this object
mydeck <- deck$new()

# draw cards
mydeck$draw(4)

# reshuffle
```

**Q3.** Why can't you model a bank account or a deck of cards with an S3 class?

**Q4.** Create an R6 class that allows you to get and set the current time zone. You can access the current time zone with `Sys.timezone()` and set it with `Sys.setenv(TZ = "newtimezone")`. When setting the time zone, make sure the new time zone is in the list provided by `OlsonNames()`.

**A4.** Here is an R6 class that manages the current time zone:

```{r}
CurrentTimeZone <- R6::R6Class("CurrentTimeZone",
  public = list(
    setTimeZone = function(tz) {
      stopifnot(tz %in% OlsonNames())
      Sys.setenv(TZ = tz)
    },
    getTimeZone = function() {
      Sys.timezone()
    }
  )
)
```

Let's try it out:

```{r}
myCurrentTimeZone <- CurrentTimeZone$new()

myCurrentTimeZone$getTimeZone()

myCurrentTimeZone$setTimeZone("Asia/Kolkata")
myCurrentTimeZone$getTimeZone()

myCurrentTimeZone$setTimeZone("Europe/Berlin")
```

**Q5.** Create an R6 class that manages the current working directory. It should have `$get()` and `$set()` methods.

**A5.** Here is an R6 class that manages the current working directory:

```{r}
ManageDirectory <- R6::R6Class("ManageDirectory",
  public = list(
    setWorkingDirectory = function(dir) {
      setwd(dir)
    },
    getWorkingDirectory = function() {
      getwd()
    }
  )
)
```

Let's create an instance of this class and check if the methods work as expected:

```{r, eval=FALSE}
myDirManager <- ManageDirectory$new()

# current working directory
myDirManager$getWorkingDirectory()

# change and check if that worked
myDirManager$setWorkingDirectory("..")
myDirManager$getWorkingDirectory()

# revert this change
myDirManager$setWorkingDirectory("/Advanced-R-exercises")
```

**Q6.**  Why can't you model the time zone or current working directory with an S3 class?

**Q7.** What base type are R6 objects built on top of? What attributes do they have?

**A7.** Let's create an example class and create instance of that class:

```{r}
Example <- R6::R6Class("Example")
myExample <- Example$new()
```

The `R6` objects are built on top of environment:

```{r}
typeof(myExample)

rlang::env_print(myExample)
```

And it has only `class` attribute, which is a character vector with the `"R6"` being the last element and the superclasses being other elements:

```{r}
attributes(myExample)
```

## Exercises 14.3.3

**Q1.** Create a bank account class that prevents you from directly setting the  account balance, but you can still withdraw from and deposit to. Throw an error if you attempt to go into overdraft.

**A1.** Here is a bank account class that satisfied the specified requirements:

```{r}
SafeBankAccount <- R6::R6Class(
  classname = "SafeBankAccount",
  public = list(
    deposit = function(deposit_amount) {
      private$.balance <- private$.balance + deposit_amount
      print(paste("Current balance:", private$.balance))
      
      invisible(self)
    },
    withdraw = function(withdrawal_amount) {
      if (withdrawal_amount > private$.balance) {
        stop("You can't withdraw more than your current balance.", call. = FALSE)
      }

      private$.balance <- private$.balance - withdrawal_amount
      print(paste("Current balance:", private$.balance))
      
      invisible(self)
    }
  ),
  private = list(
    .balance = 0
  )
)
```

Let's check if it works as expected:

```{r, error=TRUE}
mySafeBankAccount <- SafeBankAccount$new()

mySafeBankAccount$deposit(100)

mySafeBankAccount$withdraw(50)

mySafeBankAccount$withdraw(100)
```

**Q2.** Create a class with a write-only `$password` field. It should have `$check_password(password)` method that returns `TRUE` or `FALSE`, but there should be no way to view the complete password.

**A2.** Here is an implementation of the class with the needed properties:

```{r}
library(R6)

checkCredentials <- R6Class(
  "checkCredentials",
  public = list(
    # setter
    set_password = function(password) {
      private$.password <- password
    },

    # checker
    check_password = function(password) {
      if (is.null(private$.password)) {
        stop("No password set to check against.")
      }

      identical(password, private$.password)
    },

    # the default print method prints the private fields as well
    print = function() {
      "Password: XXXX"

      # for method chaining
      invisible(self)
    }
  ),
  private = list(
    .password = NULL
  )
)

myCheck <- checkCredentials$new()
myCheck

myCheck$set_password("1234")

myCheck$check_password("abcd")
myCheck$check_password("1234")
```

But, of course, everything is possible:

```{r}
myCheck$.__enclos_env__$private$.password
```

**Q3.** Extend the `Rando` class with another active binding that allows you to access the previous random value. Ensure that active binding is the only way to access the value.

**A3.** Here is a modified version of the `Rando` class to meet the specified requirements:

```{r}
Rando <- R6::R6Class("Rando",
  active = list(
    random = function(value) {
      if (missing(value)) {
        newValue <- runif(1)
        private$.previousRandom <- private$.currentRandom
        private$.currentRandom <- newValue
        return(private$.currentRandom)
      } else {
        stop("Can't set `$random`", call. = FALSE)
      }
    },
    previousRandom = function(value) {
      if (missing(value)) {
        if (is.null(private$.previousRandom)) {
          message("No random value has been generated yet.")
        } else {
          return(private$.previousRandom)
        }
      } else {
        stop("Can't set `$previousRandom`", call. = FALSE)
      }
    }
  ),
  private = list(
    .currentRandom = NULL,
    .previousRandom = NULL
  )
)
```

Let's try it out:

```{r}
myRando <- Rando$new()

# first time
myRando$random
myRando$previousRandom

# second time
myRando$random
myRando$previousRandom

# third time
myRando$random
myRando$previousRandom
```

**Q4.** Can subclasses access private fields/methods from their parent? Perform an experiment to find out.

**A4.** Unlike classical OOP in other languages (e.g. C++), R6 subclasses (or derived classes) also have access to the private methods in superclass (or base class).

For instance, in the following example, the `Duck` class has a private method `$quack()`, but its subclass `Mallard` can access it using `super$quack()`.

```{r}
Duck <- R6Class("Duck",
  private = list(quack = function() print("Quack Quack"))
)

Mallard <- R6Class("Mallard",
  inherit = Duck,
  public = list(quack = function() super$quack())
)

myMallard <- Mallard$new()
myMallard$quack()
```

## Exercises 14.4.4

**Q1.** Create a class that allows you to write a line to a specified file. You should open a connection to the file in `$initialize()`, append a line using `cat()` in `$append_line()`, and close the connection in `$finalize()`.

**A1.** Here is a class that allows you to write a line to a specified file:

```{r}
library(R6)

fileEditor <- R6Class(
  "fileEditor",
  public = list(
    initialize = function(filePath) {
      private$.connection <- file(filePath, open = "wt")
    },
    append_line = function(text) {
      cat(
        text,
        file = private$.connection,
        sep = "\n",
        append = TRUE
      )
    }
  ),
  private = list(
    .connection = NULL,
    # according to R6 docs, the destructor method should be private
    finalize = function() {
      print("Closing the file connection!")
      close(private$.connection)
    }
  )
)
```

Let's check if it works as expected:

```{r}
greetMom <- function() {
  f <- tempfile()
  myfileEditor <- fileEditor$new(f)

  readLines(f)

  myfileEditor$append_line("Hi mom!")
  myfileEditor$append_line("It's a beautiful day!")

  readLines(f)
}

greetMom()

# force garbage collection
gc()
```
