# Functions

## Exercise 6.2.5

### Q1. Function names {-}

Given a name, `match.fun()` lets you find a function.

```{r}
match.fun("mean")
```

But, given a function, it doesn't make sense to find its name in R because there can be multiple names bound to the same function.

```{r}
f1 <- function(x) mean(x)
f2 <- f1

match.fun("f1")

match.fun("f2")
```

### Q2. Correct way to call anonymous functions {-}

This is not correct since the function will evaluate `3()`, which is syntactically not allowed since literals can't be treated like functions.

```{r, error=TRUE}
(function(x) 3())()
```

This is correct.

```{r}
(function(x) 3)()
```

### Q3. Scan code for opportunities to use anonymous function {-}

Self activity.

### Q4. Detecting functions and primitive functions {-}

Use `is.function()` to check if an object is a function:

```{r}
# these are functions
f <- function(x) 3
is.function(mean)
is.function(f)

# these aren't
is.function("x")
is.function(new.env())
```

Use `is.primitive()` to check if a function is primitive:

```{r}
# primitive
is.primitive(sum)
is.primitive(`+`)

# not primitive
is.primitive(mean)
is.primitive(read.csv)
```

### Q5. Detecting functions and primitive functions {-}

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

> Which base function has the most arguments?

`scan()` function has the most arguments.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)

df_formals <- purrr::map_df(funs, ~ length(formals(.))) %>%
  tidyr::pivot_longer(
    cols = dplyr::everything(),
    names_to = "function",
    values_to = "argumentCount"
  ) %>%
  dplyr::arrange(desc(argumentCount))

```

> How many base functions have no arguments? Whatâ€™s special about those functions?

At the time of writing, 253 base functions have no arguments. Most of these are primitive functions

```{r}
dplyr::filter(df_formals, argumentCount == 0)
```

> How could you adapt the code to find all primitive functions?

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
primitives <- Filter(is.primitive, funs)

names(primitives)
```

### Q6. Important components of a function {-}

Except for primitive functions, all functions have 3 important components:

* `formals()`
* `body()`
* `environment()`

### Q7. Printing of function environment {-}

All package functions print their environment:

```{r}
# base
mean

# other package function
purrr::map
```

There are two exceptions to this rule:

* primitive functions:

```{r}
sum
```

* functions created in the global environment:

```{r}
f <- function(x) mean(x)
f
```

## Exercise 6.4.5

### Q1. All about *c* {-}

In `c(c = c)`:
* first *c* is interpreted as a function `c()`
* second *c* as a name for the vector element
* third *c* as a variable with value `10`

```{r}
c <- 10
c(c = c)
```

### Q2. Four principles that govern how R looks for values {-}

1. Name masking (names defined inside a function mask names defined outside a function)

2. Functions vs. variables (the rule above also applies to function names) 

3. A fresh start (every time a function is called a new environment is created to host its execution)

4. Dynamic look-up (R looks for values when the function is run, not when the function is created)

### Q3. Predict the return {-}

Correctly predicted ðŸ˜‰ðŸ˜‰

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}

f(10)
```


## Exercise 6.5.4 

### Q1. Property of `&&` {-}

`&&` evaluates left to right and short-circuit evaluation, i.e., if the first operand is `TRUE`, R will short-circuit and not even look at the second operand.

```{r, eval=FALSE}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)
#> [1] FALSE
x_ok(1)
#> [1] TRUE
x_ok(1:3)
#> [1] FALSE
```

Replacing `&&` is `&` is undesirable because it performs element-wise logical comparisons and returns a vector of values that is not always useful for decision (`TRUE`, `FALSE`, or `NA`).

```{r, eval=FALSE}
x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)
#> logical(0)
x_ok(1)
#> [1] TRUE
x_ok(1:3)
#> [1] FALSE FALSE FALSE
```

### Q2. Principle behind return {-}

The function returns `100`, and the principle at work here is lazy evaluation. When function environment encounters `x`, it evaluates argument `x = z` and since the name `z` is already bound to value 100, `x` is also bound to the same value.

We can check this by looking at the memory addresses:

```{r, eval=TRUE}
f2 <- function(x = z) {
  z <- 100
  print(x)
  
  print(lobstr::obj_addrs(list(x, z)))
}

f2()
```

### Q3. Principle behind return {-}

```{r}
y <- 10
f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}

f1()

y
```

