# Functions

## Exercise 6.2.5

**Q1.** Function names

Given a name, `match.fun()` lets you find a function.

```{r}
match.fun("mean")
```

But, given a function, it doesn't make sense to find its name in R because there can be multiple names bound to the same function.

```{r}
f1 <- function(x) mean(x)
f2 <- f1

match.fun("f1")

match.fun("f2")
```

**Q2.** Correct way to call anonymous functions

This is not correct since the function will evaluate `3()`, which is syntactically not allowed since literals can't be treated like functions.

```{r, error=TRUE}
(function(x) 3())()
```

This is correct.

```{r}
(function(x) 3)()
```

**Q3.** Scan code for opportunities to use anonymous function

Self activity.

**Q4.** Detecting functions and primitive functions

Use `is.function()` to check if an object is a function:

```{r}
# these are functions
f <- function(x) 3
is.function(mean)
is.function(f)

# these aren't
is.function("x")
is.function(new.env())
```

Use `is.primitive()` to check if a function is primitive:

```{r}
# primitive
is.primitive(sum)
is.primitive(`+`)

# not primitive
is.primitive(mean)
is.primitive(read.csv)
```

**Q5.** Detecting functions and primitive functions

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

> Which base function has the most arguments?

`scan()` function has the most arguments.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)

df_formals <- purrr::map_df(funs, ~ length(formals(.))) %>%
  tidyr::pivot_longer(
    cols = dplyr::everything(),
    names_to = "function",
    values_to = "argumentCount"
  ) %>%
  dplyr::arrange(desc(argumentCount))
```

> How many base functions have no arguments? Whatâ€™s special about those functions?

At the time of writing, 253 base functions have no arguments. Most of these are primitive functions

```{r}
dplyr::filter(df_formals, argumentCount == 0)
```

> How could you adapt the code to find all primitive functions?

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
primitives <- Filter(is.primitive, funs)

names(primitives)
```

**Q6.** Important components of a function

Except for primitive functions, all functions have 3 important components:

* `formals()`
* `body()`
* `environment()`

**Q7.** Printing of function environment

All package functions print their environment:

```{r}
# base
mean

# other package function
purrr::map
```

There are two exceptions to this rule:

* primitive functions:

```{r}
sum
```

* functions created in the global environment:

```{r}
f <- function(x) mean(x)
f
```

## Exercise 6.4.5

**Q1.** All about *c*

In `c(c = c)`:
* first *c* is interpreted as a function `c()`
* second *c* as a name for the vector element
* third *c* as a variable with value `10`

```{r}
c <- 10
c(c = c)
```

**Q2.** Four principles that govern how R looks for values

1. Name masking (names defined inside a function mask names defined outside a function)

2. Functions vs. variables (the rule above also applies to function names) 

3. A fresh start (every time a function is called a new environment is created to host its execution)

4. Dynamic look-up (R looks for values when the function is run, not when the function is created)

**Q3.** Predict the return

Correctly predicted ðŸ˜‰ðŸ˜‰

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x^2
    }
    f() + 1
  }
  f(x) * 2
}

f(10)
```


## Exercise 6.5.4 

**Q1.** Property of `&&`

`&&` evaluates left to right and short-circuit evaluation, i.e., if the first operand is `TRUE`, R will short-circuit and not even look at the second operand.

```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)

x_ok(1)

x_ok(1:3)
```

Replacing `&&` is `&` is undesirable because it performs element-wise logical comparisons and returns a vector of values that is not always useful for decision (`TRUE`, `FALSE`, or `NA`).

```{r}
x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)

x_ok(1)

x_ok(1:3)
```

**Q2.** Principle behind return

The function returns `100`, and the principle at work here is lazy evaluation. When function environment encounters `x`, it evaluates argument `x = z` and since the name `z` is already bound to value 100, `x` is also bound to the same value.

We can check this by looking at the memory addresses:

```{r}
f2 <- function(x = z) {
  z <- 100
  print(x)

  print(lobstr::obj_addrs(list(x, z)))
}

f2()
```

**Q3.** Principle behind return

TODO:

```{r}
y <- 10
f1 <- function(x =
                 {
                   y <- 1
                   2
                 },
               y = 0)
{
  c(x, y)
}

f1()

y
```

## Exercise 6.6.1

**Q1.** Explain results

```{r}
sum(1, 2, 3)

mean(1, 2, 3)

sum(1, 2, 3, na.omit = TRUE)

mean(1, 2, 3, na.omit = TRUE)
```

Let's look at arguments for these functions:

```{r}
str(sum)
str(mean)
```

As can be seen, `sum()` function doesn't have `na.omit` argument. So, the input `na.omit = TRUE` is treated as `1` (logical implicitly coerced to numeric), and thus the results. So, the expression evaluates to `sum(1, 2, 3, 1)`.

For `mean()` function, there is only one parameter (`x`) and it's matched by the first argument (`1`). So, the expression evaluates to `mean(1)`.

**Q2.** Finding documentation for `plot` arguments

First, check documentation for `plot()`:

```{r}
str(plot)
```

Since `...` are passed to `par()`, we can look at its documentation:

```{r}
str(par)
```

The docs for all parameters of interest [reside there](https://rdrr.io/r/graphics/par.html).

**Q3.** Reading source code for `plot.default`

Source code can be found [here](https://github.com/wch/r-source/blob/79e73dba5259b25ec30118d45fea64aeac0f41dc/src/library/graphics/R/plot.R#L51-L84).

`plot.default()` passes `...` to `localTitle()`, which passes it to `title()`.

`title()` has four parts: `main`, `sub`, `xlab`, `ylab`.

So having a single argument `col` would not work as it will be ambiguous as to which element to apply this argument to.

```{r eval=FALSE}
localTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)

title <- function(main = NULL, sub = NULL, xlab = NULL, ylab = NULL,
                  line = NA, outer = FALSE, ...) {
  main <- as.graphicsAnnot(main)
  sub <- as.graphicsAnnot(sub)
  xlab <- as.graphicsAnnot(xlab)
  ylab <- as.graphicsAnnot(ylab)
  .External.graphics(C_title, main, sub, xlab, ylab, line, outer, ...)
  invisible()
}
```
